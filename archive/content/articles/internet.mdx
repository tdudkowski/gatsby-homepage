---
title: "Internet"
comment: ""
section: "it"
subsection: "internet"
---

1. [Wstęp](#intro)
2. [Sieci komputerowe, topologia, rodzaje](#net)
3. [Internet - sposób funkcjonowania](#internet)
4. [Warstwy sieci](#model)
5. [Warstwa aplikacji](#application_layer)
6. [Warstwa transportowa (TCP i UDP)](#transport_layer)
7. [Warstwa internetowa (IP i ICMP)](#internet_layer)
8. [Warstwa dostępu do sieci (ARP)](#link_layer)
9. [DNS](#dns)
10. [Adresowanie IP](#ip)
11. [Firewall](#firewall)
12. [URI, URL, FQDN](#uri)
13. [Urządzenia](#kit)
14. [Narzędzia](#tools)
15. [Dodatek](#appendix)
- [Słownik pojęć](#dictionary)
- [Protokoły](#protocols)
16. [Materiały](#resources)
- [Książki](#books)
- [Odnośniki](#links)

### Wstęp

Jest to tylko upubliczniony brudnopis z notatkami dotyczącymi bardziej mnie interesujących zagadnień związanych z sieciami komputerowymi w ogólności, a z internetem w szczególności. 
Źródła, z których korzystałem są wymienione na dole - są to przede wszystkim hasła z Wikipedii oraz artykuły z kilku czasopism. Więc nie jest to jakieś samodzielne opracowanie, w tej chwili jest to tak sobie zorganizowana kompilacja, która będzie podstawą dla bardziej kompletnego opisu internetu. 
Niektóre rzeczy (np. narzędzia) są tu tylko zasygnalizowane, inne zrobione (słownik pojęć) po łebkach. Ale jak będę miał czas to na pewno to poprawię. 
Oczywiście będę wdzięczny za wszelkie sugestie i wskazanie błędów. 

**Ostatnia aktualizacja: 24 VIII 2005**

### Sieci komputerowe, topologia, rodzaje

#### Sieć

Sieć komputerowa to grupa komputerów lub innych urządzeń połączonych ze sobą w celu wymiany danych lub współdzielenia różnego rodzaju zasobów, na przykład:

- korzystania ze wspólnych urządzeń, np. drukarek,
- korzystania ze wspólnego oprogramowania,
- korzystania z centralnej bazy danych,
- przesyłania informacji między komputerami (komunikaty, listy, pliki).

##### Rodzaje sieci komputerowych

asymetryczne/dedykowane
jeden z komputerów (tzw. serwer sieciowy) odgrywa rolę nadrzędną i nadzoruje pracę sieci, architektura klient-serwer

symetryczne/równorzędne "peer to peer" (skrót P2P)
wszystkie komputery mają jednakowe uprawnienia

##### Topologie okablowania sieci komputerowych

gwiazda
scentralizowana, zapewnia duże możliwości zarządzania ruchem i odporność na awarię (o ile nie jest to akurat awaria serwera);
komputery są podłączone do jednego punktu centralnego:

- koncentratora, który tworzy fizyczną topologię gwiazdy, ale logiczną magistralę
- przełącznika (jedna z częstszych topologii fizycznych Ethernetu)

gwiazda rozszerzona
posiada punkt centralny (podobie do topologii gwiazdy) i punkty poboczne (jedna z częstszych topologii fizycznych Ethernetu)

hierarchiczna
podobna do drzewa binarnego

szyna (magistrala)
komputery współdzielą jedno medium kablowe (topologia logiczna Ethernetu) i to pojedyncze łącze (zazwyczaj kabel koncentryczny) obsługuje wszystkie urządzenie sieciowe; szyna pozwala na przeprowadzenie tylko jednej transmisji a danym momenie;

- zalety: prosta w budowie, tania i względnie wydajna w małych sieciach (np. domowych)
- wady: łatwo przechwytywać transmisję, trudno wykryć wąskie gardła i zlokalizować awarię, każda stacja może przechwycić dane przeznaczone dla innej

pierścień
komputery są połączone pomiędzy sobą odcinkami kabla tworząc zamknięty pierścień (np. topologia logiczna Token Ring);

- wady: łatwo przechwycić dane, jak w topologii szyny dwa miejsca awarii: serwer i kabel; awaria jednej stacji może odciąć cała resztę

pierścień podwójny
komputery są połączone dwoma odcinkami kabla (np. FDDI)

sieć (ang. _mesh_)
oprócz koniecznych połączeń sieć zawiera połączenia nadmiarowe; rozwiązanie często stosowane w sieciach, w których jest wymagana wysoka bezawaryjność.

Elementy tworzące sieć komputerową:

- serwer sieciowy: zazwyczaj komputer o dużej mocy obliczeniowej, wydajnym i pojemnym podsystemie dyskowym niezbędnym do przechowywania oprogramowania i danych użytkowników; na tej maszynie można uruchomić aplikacje udostępniające usługi sieciowe, również nazywane serwerami.
- komputery - stacje robocze, (terminale), na których instaluje się oprogramowanie sieciowe; nazywane też klientami
- media transmisji - kable miedziane, światłowody, fale radiowe
- osprzęt sieciowy - karty sieciowe, modemy, rutery, koncentratory (huby), przełączniki (switche), punkty dostępowe (_access points_)
- zasoby sieciowe - wspólny sprzęt, programy, bazy danych
- oprogramowanie sieciowe - to programy komputerowe, umożliwiające przesyłanie informacji pomiędzy urządzeniami sieciowymi; rozróżnia się dwa podstawowe rodzaje oprogramowania sieciowego:
  - klient-serwer (system - użytkownik) - system, w którym serwer świadczy usługi dołączonym stacjom roboczym; w systemie tym programy wykonywane są w całości lub częściowo na stacjach roboczych
  - host-terminal (system baza) - do komputera głównego (hosta) dołączone zostają terminale lub komputery emulujące terminale; w systemie tym programy wykonywane są na hoście

#### Architektura klient-serwer

Jest to skalowalna architektura gdzie każdy komputer lub proces sieci jest albo klientem albo serwerem. 
Oprogramowanie serwera najczęściej (ale nie zawsze) działają na silnych komputerach dedykowanych dla wyłącznego użytku aplikacji serwerowych.

Oprogramowanie klienckie z drugiej strony działa na popularnych PC lub stacjach roboczych. Klient dostaje wszystkie lub większość informacji od serwera i przekazuje mu większość zadań samemu mogąc wykonywać inne zadania. Każda instancja klienta może wysyłać żądania do serwera lub aplikacji serwera. 

Inny typ architektury sieci jest znany jako P2P ponieważ każdy węzęł lub instancja programu jest zarówno klientem jak i serwerem i każda ma równą odpowiedzialność. Zarówno klient/serwer jak i P2P są szeroko używane, każda ma swoje wady i zalety. 

Właściwości serwera:

- pasywny - _passive (slave)_
- czeka na żądania
- na żądania odpowiada i wysyła wiadomość

Właściwości klienta:

- aktywny _active (master)_
- wysyła żądania
- czeka do nadejścia odpowiedzi

Interakcja pomiędzy klientem a serwerem jest często opisywana przy użyciu diagramów sekwencji, są standaryzowane w UML. 

Chudy klient (_thin client_) vs. gruby klient (_fat client_)
Inny typ klienta w architekturze klient-serwer jest znany jako chudy klient tzn. minimalny. Chudy klient używa jak najmniej zasobów hosta PC jak to tylko możliwe, głównie jest to graficzne wyświetlenie informacji z aplikacji serwera, to ułatwia zarządzanie zasobami. 

Arcitektura n-węzłów (_n-Tier Architecture_)
Serwery aplikacji zwykle przechowują dane na trzeciej maszynie, znanej jako serwer bazy danych. To się nazywa trzywęzłowa (_three-tier_) architektura, podczas kiedy ogólna architektura klient/serwer jest dwuwęzłowa.
W ogólności, n-węzłowa lub multi-węzłowa architektura może rozdysponować dowolną ilość oddzielnych usług, włączając przechodnie relacje pomiędzy serwerami aplikacji, każda z nich może ale nie musi użyć oddzielnej lub współdzielonego systemu baz danych. 

Przykłady:

- Popularnym rodzajem klienta jest to przeglądarka internetowa, która łączy się z serwerem WWW przez internet, żeby pobrać i wyświetlić zawartość strony WWW.
- X Window System jest architekturą klient-serwer z pewną nietypową cechą: serwer jest zawsze lokalny (blisko użytkownika) a klient może być lokalny lub zdalny. Lepiej jest wyobrazić sobie serwer (X display) jako udostępniający pewne zasoby (okienowy system wyświetlania), a klienta jako używającego tych zasobów.

##### Serwer

- Oprogramowanie wykonujące pewne zadania dla użytkowników.
  - udostępnianie plików: pozwalanie użytkownikom na przechowywanie i dostęp do plików na wspólnym komputerze
  - aplikacja udostępniająca usługi, oprogramowanie wykonuje zadania na komputerze dla użytkowników - jest to pierwotne znaczenie tego terminu. Pierwotnie oprogramowanie serwera było umieszczone na komputerze mainframe lub minikomputerze. W dużym stopniu zostały zastąpione przez rozbudowane komputery używające technologii mikroprocesorowej używanej także w PC. Najczęściej komputery pełniące funkcję serwera mają wysoką wydajność (czasem redundantną) i awaryjne zasilanie, płyta główna zaprojektowana jest dla pracy 24x7, ma duże ilości ECC RAM i szybkie podsystemy I/O używające technologii takich jak SCSI, RAID, i PCI-X lub PCI Express.
- Oznacza także fizyczny komputer na którym działa oprogramowanie serwera.

Czasem to podwójne znaczenie może prowadzić do pomieszania, np. w przypadku webserwera. Ten termin może oznaczać maszynę która przechowuje i przetwarza strony WWW i w tym znaczeniu jest używane przez firmy oferujące hosting. Ale słowo webserwer może również oznaczać oprogramowanie takie jak Apache HTTP - serwer który działa na maszynie i dostarcza elementy strony WWW w odpowiedzi na żądania przeglądarki. 

Wiele przedsiębiorstw używa licznych serwerów dla swoich potrzeb, zespół serwerów w jednej lokacji jest często nazywany farmą serwerów (_server farm_). Można skonfigurować maszyny do dystrybucji zadań tak, że żadna pojedyncza maszyna nie jest przeciążona żądaniami (tzw. _load balancing_) - jest to często używane kiedy potrzebna jest duża wydajność. 

Serwery mogą być:

bezstanowe:
serwer nie przechowuje informacji pomiędzy żądaniami (przykład: serwer HTTP dla statycznych stron HTML)

stanowe:
może zapamiętać informację pomiędzy żądaniami, zakres może być globalny lub ograniczać się do sesji (przykład: Apache Tomcat)

##### X Window

Serwer X nie jest komputerem z oddzielnym programem, ale zapewnia dostęp do urządzeń komputerowego wejścia i wyjścia takich jak monitory, kbd i myszy. Programy działające w środowsku X łącząc się z serwerem uzyskują dostęp do sprzętu. 
Protokół X jest zaprojektowany do działania w sieci. Jedynym wymogiem dla klienta do połączenia się z serwerem jest połączenie sieciowe. W większości sytuacji jednak, serwer i klient działają na tej samej maszynie. W tym wypadku albo lokalne gniazda UNIX albo interfejs pętli zwrotnej działa jako transparentne medium sieciowe dla połączeń sieciowych pomiędzy klientem a serwerem. 

#### LAN (_Local Area Network_) - WAN (_Wide Area Network_)

Sieć lokalna to najmniej rozległa postać sieci komputerowej. Zwykle ogranicza się do jednego budynku, lub kilku pobliskich budynków (np. bloków na osiedlu). Topologia jest zdeterminowana przez fizyczną strukturę. Chociaż brak jest wyraźnie sprecyzowanych wyznaczników co jest siecią lokalną, a co nie, za taką uważa się sieć o rozmiarach od jednego pomieszczenia do budynków na obszarze ok 1 km2. 

Sieci lokalne dzielimy na:

przewodowe
najczęściej używaną technologią jest Ethernet (za pośrednictwem kart sieciowych zazwyczaj połączonych bubem lub switchami)

bezprzewodowe
najczęściej używaną technologią jest WLAN zwany także WiFi określony standardami ETSI 802.x

Sieci lokalne podłączone są często do Internetu wspólnym łączem, takim jak SDI, Neostrada, DSL itp. 

Sieć rozległa (ang. _Wide Area Network_, WAN) - Sieć łącząca sieci lokalne, inne (mniejsze) sieci rozległe, jak również pojedyncze komputery. Odbywa się to przy pomocy urządzeń sieciowych takich jak rutery oraz urządzeń dostępowych takich jak modemy. Przykładami sieci rozległych są sieci miejskie, sieci korporacyjne, oraz internet. Pokrywa duży obszar i łączy dużą ilość komputerów. Największym przykładem takiej sieci jest internet. 
Sieć WAN działa w warstwie fizycznej oraz warstwie łącza danych modelu odniesienia OSI. Łączy ona ze sobą sieci LAN, które są zazwyczaj rozproszone na dużych obszarach geograficznych. Sieci WAN umożliwiają wymianę ramek i pakietów danych pomiędzy routerami i przełącznikami oraz obsługiwanymi sieciami LAN. 

Główne cechy sieci WAN:

- łączą ze sobą urządzenia rozmieszczone na dużych obszarach geograficznych
- w celu ustanowienia łącza lub połączenia między dwoma miejscami korzystają z usług operatorów telekomunikacyjnych, np. TP S.A., NASK, Energis
- wykorzystują różne odmiany transmisji szeregowej

Protokoły stosowane w sieciach rozległych to np: X.25, Frame Relay, Point to Point Protocol i ATM. 
Standardy sieci WAN są definiowane i zarządzane przez szereg uznanych organizacji, w tym:

- Sektor Standaryzacji Telekomunikacyjnej Międzynarodowej Unii Telekomunikacyjnej (ITU-T, ang. International Telecommunication Union-Telecommunication Standardization Sector), dawniej Committee for International Telegraph and Telephone (CCITT)
- Międzynarodową Organizację ds. Standaryzacji (ISO, International Organization for Standardization),
- Grupę Roboczą ds. Technicznych Internetu (IETF, Internet Engineering Task Force),
- Stowarzyszenie Przemysłu Elektronicznego (EIA, Electronic Industries Association).

### Internet - sposób funkcjonowania

#### Organizacyjnie

Internet jest to jak sama nazwa (międzysieć) wskazuje sieć łącząca wiele sieci. 
Poszczególne sieci są przyłączone w hierarchicznej strukturze, mniejsze sieci są częściami większych struktur. Przy takiej topologii przyłączenie nowej sieci jest proste i wymaga tylko uzgodnienia z osobami zarządającymi siecią do której się przyłącza. Dzięki właściwościom stosu protokołół TCP/IP przyłączanie i odłączanie kolejnych segmentów nie wpływa na działanie pozostałych fragmentów internetu, ani nie wymaga żadnych zmian w konfiguracji komputerów znajdujących się w odległych podsieciach. 

Internet jako całość nie ma żadnej władzy, zarządu ani właściciela. 
Na najwyższym poziomie jest zbiorem połączonych ze sobą sieci szkieletowych. Każda z nich ma swojego właściciela (z reguły jest to jakaś firma telekomunikacyjna, bo musi mieć możliwość budowania łącz dalekiego zasięgu), który ustala panujące w niej reguły, ale jego władza jest ograniczona do własnej sieci. 
Generalną zasadą jest, że "mniejszy płaci większemu". Jeśli łaczą sie podobne sieci nic nie płacą lub rozliczają się w oparciu o róznice ruchu w obu kierunkach, ale sieci miejskie płacą krajowym, instytycje sieciom miejskim itd. Właściciel każdej sieci lokalnej może nią zarządzać według swojego uznania uwzgledniając warunki umowy ze swoim ISP (np. zakaz przyłączania dalszych sieci)

Choć nie ma władzy jednak pewne rzeczy muszą być centralnie koordynowane, np. rozdział adresów IP, musi zapewniać ich niepowtarzalność w skali całego internetu. Ktoś też musi ustalać standardy internetowe. 
Zagadnieniami takimi zajmują się wyłonione ze społeczności internetowej specjalne rady, komitety i grupy robocze. 

Najstarszym takim ciałem jest IAB (Internet Architecture Board), która powstała - jako Internet Control Configuration Board - jeszcze pod patronatem ARPA w 1979 i miała koordynować prace nad wprowadzaniem w sieci ARPANET protokołów TCP/IP. 
Gdy w 1983 ARPANET zamienił się w Internet zmieniła nazwę na Internet Activities Board i jej zadaniem było nadzorowanie całości zagadnień związanych z rozwojem technicznym internetu i chociaż rok póżniej internet przestał być zarządzany przez ARPA nadal funkcjonowała na mocy zwyczaju. 
W 1986 IAB wyłoniła dwie nowe, również nieformalne organizacje:

- IETF (Internet Engineering Task Force) - której zadaniem jest bezpośrednia techniczna praca nad protokołami internetowymi
- IRTF (Internet Research Task Force) - zajmująca się bardziej dalekosiężnymi projektami badawczymi związanymi z internetem

W 1992 powstało ISOC (_Internet Society_) Jej podstawowym celem było ułatwienie korzystania i przybliżenie technologii internetowych, ale docelowo stała się odpowiedzialna za rozwijanie standardów i technlogii umożliwiających rozwój internetu. 
Zostało założone w 1991 roku przez grupę osób z wieloletnim doświadczeniem w pracy na rzecz IETF. Głównym, pierwotnym celem ISOC-u było wsparcie pracy IETF i pokrewnych nieformalnych grup specjalistów zajmujących się rozwojem Internetu. Ze względu na całkowicie nieformalny charakter IETF miała poważne problemy przy organizowaniu swoich zjazdów i opłacaniu sekretariatu. Osoby zaangażowane w prace IETF nie chciały regulować statusu prawnego tego ciała, z obawy, że zabije to ideę tej nieformalnej instytucji. 
Z pewnego punktu widzenia to z ISOC wyłonił się IETF - prawa autorskie do wszystkich IETF RFC ma ISOC (chociaż są dostępne bez opłat i ograniczeń). W innej perspektywy ISOC wyrosło z IETF by wspierać całość jego prac w zorganizowany sposób a nie taki zadaniowy jak funkcjonuje IETF. 

IAB pod obecną już nazwą została włączona w jej struktury władz. 
Większość wysiłków standaryzacyjnych idzie przez IETF i IAB. Niektóre funkcje obu organizacji są wspierane przez dzielone zasoby znane jako Sekretariat (Secretariat). 

Obecnie IAB wybierana jest przez zarząd ISOC spośród kandydatur proponowanych przez IETF i pełni funkcje ciała doradczego dla ISOC oraz nadzorczego dla IETF, która nadal jest luźną grupą bez formalnego członkostwa stanowi siłę napędową rozwoju internetu, bo w jej dyskusjach powstają nowe pomysły dotyczące sieci. 
Z chwilą gdy osiągną status proponowanego standardu, podlegają zatwierdzeniu przez IAB i publikacji jako dokumenty RFC (_Request For Comments_) - ta nazwa wywodzi się z czasów wczesnego ARPANET-u, kiedy zatrudnieni przy budowie sieci informatycy zaczęli spisywać swoje uwagi i propozycje dla współpracowników w postaci pierwszych RFC nie mających jeszcze formalnego standardu. Obecnie treść dokumentów RFC określa podstawy funkcjonowania internetu. 

RFC są przeglądane przez ekspertów i zostają oznaczone według pewnej klasyfikacji:

Required
funkcje, które muszą zostać zaimplementowane w każdym stosie TCP/IP, niezależnie od platformy i systemu

Recommended
funkcje, które powinny być częścią każdego systemu opartego na TCP/IP, ale ich implementacja nie jest konieczna; najczęściej są implementowane ze względu na swoją przydatność

Elective
mogą być zaimplementowane ale nie są konieczne do poprawnej pracy

Limited Use
przeznaczone do celów specjalnych, nie wykorzystuje się ich do normalnego użytkowania, często tworzone w celu testów

Not recommended
standardy, które nie powinny zostać zaimplementowane

Kiedy dokument przejdzie poszczególne ścieżki (Proposed Sandard, Draft Standard, Internet Standard) zostanie mu nadany RFC, który już nie jest później zmieniany. Jeśli zachodzi konieczność zmian w dokumencie publikowane jest uaktualnienie (weryfikacja) z nowym numerem. Ważna jest weryfikacja lub dokument później opublikowany (z większym numerem). 
IAB publikuje kwartalną notatkę IAB Official Protocol Standard, która weryfikuje RFC (podaje najnowsze wersje) aktualnie obowiązujących standardów. 

Z upoważnienia IAB rozdziałem adresów zajmuje się IANA a jej ramieniem wykonawczym jest InterNIC utworzona w 1993 przez AT&T i Network Solutions przy częściowym udziale finansowym NSF. 
Poza przydziałem numerów IP operatorom sieci szkieletowych zajmuje się utrzymywaniem głównych serwerów nazw oraz rejestracją poddomen użytkowników w gTLD (przedtem zajmowało się tym SRI NIC z Stanford Research Institute). 
InterNIC rozdziela grupy adresów pomiędzy operatorów sieci szkieletowych, którzy rozdzielają je pomiędzy operatorów mniejszych sieci itd. dzięki czemu zapewniona jest unikalność adresów pomiędzy wszystkimi komputerami w internecie. Na mocy umów z InterNIC (lub odpowiadającymi mu instytucjami w innych częściach świata, w Europie jest to RIPE) działają także instytucje administrujące adresami krajowymi. 

#### Instytucje

ISOC (Internet Society)

Naczelny organ Internetu. Jego zadania to promocja i upowszechnianie dostępu do sieci, zapewnienie otwartego rozwóju. Jego członkowie spotykają się na konferencji raz w roku. Dla rozwiązania problemów technicznych powołuje rozmaite Task Forces. 
Powierzono mu zadanie ustanawiania norm technicznych obowiązujących w internecie oraz podejmowania decyzji o kluczowym znaczeniu i nadawania podlegającym jej organizacjom prestiżowych i jednoznacznie identyfikowalnych adresów WWW. W pewnym sensie reprezentuje użytkowników Internetu przed rządowymi agencjami odpowiedzialnymi za nadzór nad Internetem w poszczególnych krajach. 
Zgodnie z RFC 1602 określającym relacje między ISOC i IETF, ISOC wspiera IETF w tych wszystkich działaniach, które wymagają osobowości prawnej oraz pomaga w oficjalnych kontaktach między IETF i agencjami rządowymi, ale nie ma prawa w jakikolwiek sposób wypływać na tok prac podejmowanych w IETF. 
Po pewnym czasie jednak Internet Society zaczęła żyć własnym życiem i oprócz współpracy z IETF rozwinęła szereg innych działań. Obecnie ISOC organizuje wiele konferencji, z których nasłynniejsza jest ogólnoświatowa konferencja INET, wydaje 4 czasopisma elektroniczne, "opiekuje się" IETF i IANA, oraz przyznaje doroczne nagrody im. Jona Postela. 
Internet Society utrzymuje się z dobrowolnych datków swoich członków oraz z dotacji czynionych przez firmy i organizacje. 
Internet Society jest stowarzyszeniem całkowicie otwartym i demokratycznym. Może do niego przystąpić każda osoba fizyczna. Dla osób fizycznych nie ma żadnych opłat członkowskich. Wystarczy wypełnić deklarację członkowską dostępną na stronie www ISOC-u i wyrazić chęć należenia. Do Internet Society mogą też przystępować całe przedsiębiorstwa i organizacje. 
Władzą Internet Society jest jego Rada. Prezydium (Board of Trustees) to najwyższe gremium decyzyjne w składające się z 15 członków. 
Jej członkowie wybierani są na trzyletnią kadencję przez oddziały regionalne, wspierające ISOC firmy oraz członków IETF. Rada powołuje Zarząd, którego przewodniczący oraz szef sekretariatu są oficjalnie zatrudnieni, a reszta pracuje społecznie. Oprócz tego ISOC zatrudnia kilkanaście osób w swoich dwóch biurach - w USA i w Szwajcarii oraz opłaca działalność sekretariatów IETF i IANA, a także zespół redakcyjny dokumentów RFC. 
Prawnie Internet Society jest amerykańską organizacją edukacyjną non-profit zarejestrowaną w sądzie miejskim miasta Washington. Istnieje oddział polski: Internet Society Poland. 

IAB (Internet Architecture Board)

"Okrągły stół" ekspertów od Internetu. Tutaj zapadają decyzje o najważniejszych standardach internetowych przygotowanych przez Task Forces.

IETF (Internet Engineering Task Force)

ITEF opracowuje standardy internetu. Składa się z rozmaitych grup roboczych zajmujących się aplikacjami, zarządzaniem, routingiem. Zadaniem jest rozwój i promocja standardów internetowych. Jest to otwarta, w całości składająca się z wolontariuszy organizacją, bez formalnego członkostwa ani wymagań wobec biorących udział w pracach. 
Jest zorganizowana w dużą liczbę grup roboczych, każda z nich zajmuje się jakaś określonym zagadnieniem. Razem AD z IETF Chair tworzą IESG (Internet Engineering Steering Group), który jest odpowiedzialny za całość prac IETF. 
Całościowo jest nadzorowany przez IAB, który jest odpowiedzialny przed ISOC. 
W początkch lat 90-tych IETF była chwalona przez prasę komputerową za szybkość, otwartość i szczupłość w porówaniu z powolnymi i opasłymi biurokratycznymi ciałami w rodzaju International Organization for Standardization i ITU-T. W okolicach 1993 stało się jasne, że internet stanie się potężnym i ważnym medium oraz, że wysiłki OSI zmierzają właściwie donikąd. Wtedy wielu specjalistów przyłączyło się do IETF, grupy robocze rozrosły się a ich prace zwolniły. 
Najbardziej jaskrawym przykładem tego problemu był moment kiedy Tim Berners-Lee stał się szefem W3C by osobiście przewodzić rozwojem standardów WWW, jak to później wyjaśnił w książce "Weaving the Web" stał się sceptykiem po wielu posiedzeniach IETF kiedy każdy zabierał głos a właściwie nic nie zostało zrobione. 

IRTF (Internet Research Task Force)

Odpowiedzialny za perspektywiczny rozwój technicznych standardów internetowych.

W3C (World Wide Web Consortium)

Odpowiedzialne za standardy i rozwój WWW. Przewodniczącym jest Tim Berners-Lee. 
"gdy dojdziemy do punktu, w którym warunkiem odczytania strony będzie posiadanie określonego oprogramowania, wówczas World Wide Web przestanie być ogólnodostępny".

IANA (Internet Assigned Numbers Authority)

Najwyższa z organizacji odpowiedzialnych za przyznawanie nazw w Internecie. Działa na zlecenie ISOC i FNC. IANA przydziela swym organizacjom podrzędnym przestrzenie nazw (na przykład ".pl"), którymi zarządzają one samodzielnie. Całą tą pracę wykonywał kiedyś jeden człowiek - Jon Postel. 
IANA jest kontrolowana przez ICANN (Internet Corporation for Assigned Names and Numbers), ale ostateczną kontrolę nad _DNS root zone_ ma United States Department of Commerce. 
IANA deleguje lokalnych rejestratorów adresów IP - Regional Internet Registries (RIR). Każdy RIR przydziela adresy dla innego obszaru świata, zbiorowo tworzą część Numbers Resource Organization utworzonej w celu reprezentacji ich interesy oraz zapewnienia globalnej koordynacji działań. 
IANA deleguje alokację większych obszarów adresowych IPv4 (zwykle /8 lub więcej na raz) a każdy RIR działa już zgodnie ze swoją polityką, zwykle deleguje przypisanie mniejszych przestrzeni adresów IP (np. /19 /20). 

inne:

- Federal Networking Council (FNC): odpowiedzialna za przydzielanie domen organizacjom rządowym, edukacyjnym i wojskowym (adresy internetowe z sufiksami ".gov", ".mil" i ".edu").
- Asian Pacific Network Information Center (APNIC): Odpowiedzialny za nadawanie adresów internetowych (nazw domen) w obszarze azjatyckim.
- Reseau IP Européen (RIPE): Odpowiedzialny za adresy internetowe w Europie i obszarach przyległych (między innymi adresy internetowe z końcówką ".pl", ".at" i ".fr").
- InterNIC (Internet Network Information Center): Odpowiedzialny za domeny nie związane z konkretnym krajem, jak ".com", ".net", ".org". Był ciałem zarządzajacym przydziałem adresów IP, teraz zajmuje się tym ICANN
- NASK: Naukowa i Akademicka Sieć Komputerowa odpowiedzialna za nadawanie nazw w polskiej domenie ".pl". Działa na zlecenie RIPE.
- Internet Ad Hoc Committee: Opracowuje obecnie propozycję reformy w systemie międzynarodowych domen najwyższego poziomu (top level).

#### Technicznie

Podstawowym wymogiem jaki wojsko postawiło przed siecią jest decentralizacja, dlatego współczesny internet jest związkiem wielu sieci istniejących w obrębie ustalonej wspólnymi standardami struktury. Ideą takiego rozwiązania było, żeby każdy komputer mógł nawiązać połączenie z każdym niezależnie od tego jak bardzo zróżnicowane są sieci do których należą. 

Kluczowym elementem tej struktury są rutery łączące sieci - są to mechanizmy zajmujące się przesyłaniem pakietów danych z jednej sieci do drugiej. Mogą miec postać sprzętową lub być programami funkcjonującymi w systemie operacyjnym. Część z nich jest połączona na stałe z internetem, inne nawiązują połączenie w razie potrzeby. 
Dzięki możliwości przekierowania drogi rutowania (np. w razie awarii) internet spełnił zadanie postawione przez wojsko - może funkcjonować pomimo uszkodzenia podsieci. 

Koncepcja ogólnoświatowej sieci zawdzięcza swoją uniwersalność temu, że pozwala na połączenie ze sobą podsieci o zupełnie odmiennych strukturach i typach okablowania (Ethernet, Token Ring, ATM, ISDN itd), zapewnia łączność pomiedzy różnymi systemami operacyjnymi i osprzętem sieciowym. Na te różnice składają się różne sposoby kodowania fizycznych adresów sieciowych, inne maksymalne wielkości pakietów danych oraz różne metody dołączania sum kontrolnych. 
Warunki współpracy określają uniwersalne standardy, które dbają by odmienne właściwości poszczególnych podsieci były przezroczyste dla aplikacji sieciowych - zajmuje się tym warstwa sieciowa i transportowa czyli TCP/IP

Protokół IP definiuje 20-bajtowy nagłówek, który umieszczony przed właściwymi danymi pełni funkcję etykiety adresowej, oprócz adresu nadawcy i odbiorcy zawiera informacje dodatkowe: długość pakietu suma kontrolna i tzw. licznik stacji (TTL). 

Adres IP to 4-bajtowy numer składający się z:

- Net-ID: identyfikuje sieć do której należy dany host; tą częścią zarządza IANA, co gwarantuje ich unikatowość
- Host-ID: identyfikuje host w obrębie sieci lokalnej; nadawany jest przez administratora podsieci

Ten podział jest podstawowym warunkiem sprawnego kierowania ruchem pakietów IP (tzw. ruting), gdy host wysyła pakiet już na początku dzięki porównaniu Net-ID jest w stanie określić czy adresat jest w tej samej sieci lokalnej. Jeśli nie to wysyła pakiet do rutera, który określa najlepszą drogę według tabeli rutingu składającej się z uaktualnianych ciągle danych jakie wymieniają między sobą rutery. 
Z punktu widzenia rutera wysłanie pakietu oznacza umieszczenie ich w odpowiedniej dla danej sieci ramce. Ponieważ żadna sieć nie jest w stanie na poziomie warstwy pakietowej obsługiwać pakietów IP przesyłki muszą zostać umieszczone w ramkach specyficznych dla danego protokołu. Dzięki temu nie będą się odróżniały od standardowych pakietów danej sieci. 
Ponieważ często zdarza się sytuacja, że pakiety IP są zbyt duże by je w całości przesłać w ramkach, ważnym elementem protokołu IP jest mechanizm fragmentacji danych. Jeśli sytuacja tego wymaga rutery mogą podzielić pakiet IP na kilka specyficznych dla danej sieci przesyłek i wysłać je kolejno. W nagłówku IP są pola pozwalające odpowiednio je złożyć. 

Wysyłany jest specjalny pakiet ARP Broadcast skierowany do wszystkich urządzeń w danej sieci. Każde z nich sprawdza czy zawarty w nim adres IP odpowiada własnemu numerowi i jeśli się zgadza odpowiada. Jeśli żadna nie odpowie oznacza to, że dany adres nie jest znany w tej sieci i jego transmisja zostaje przerwana. 
Ruch w sieci jest kontrolowany przez ICMP jego pakiety są priorytetowe. Określa sposób tworzenia i wymiany informacji sterujących pomiędzy ruterami lub ruterami i hostami. Np. jakiś ruter może ogłosić, że dana podsieć jest przeciążona i ruch należy skierować inną drogą, może na zapytanie ICMP przesłać informację o numerze Net-ID aktualnej podsieci lub jej masce. 
Z protokołu ICMP korzysta ping, popularna funkcja za pomocą której można sprawdzić obecność zdalnego hosta i zmierzyć czas transmisji nadawanych do niego pakietów. 

Aby dokonać identyfikacji konkretnej aplikacji, do której kierowane są pakiety TCP używa tzw. portów, których funkcję pełni 16-bitowa liczba. Najważniejszą informacją zawartą w nagłówku TCP jest identyfikator portu adresata i nadawcy. Gdy oprogramowanie sieciowe otrzyma pakiet TCP lub UDP może za pomocą numeru portu rozpoznać do jakiej aplikacji należy dana przesyłka. 
Większość aplikacji musi mieć pewność, że dana przesyłka dotarła do celu dlatego TCP korzysta z pomocy sum kontrolnych, numerów bloków oraz potwierdzeń do odbiorcy. Wszystkie przesyłki które nie dotarły do adresata lub uległy przekłamaniu są nadawane ponownie. Dopiero gdy określona liczba prób nie odniesie skutku transmisja jest przerywana a nadawca informowany o jej niepowodzeniu. 

Transmisja przy pomocy np. PPP wymaga dodatkowych protokołów, choćby po to by zaznaczyć gdzie pakiety IP się zaczynają i kończą (ponieważ poprzez modem są transmitowane bajt po bajcie). 
Najprostszym i najstarszym jest SLIP, który na końcu każdego pakietu IP dołącza odpowiedni bajt rozpoznawczy. Trochę lepszą jego wersją jest CSLIP, który nie przesyła całych nagłowków IP a tylko różnice pomiędzy nimi. 
Obecnie powszechnie używany jest PPP. Wykorzystuje do przesyłania danych nie tylko specjalną ramkę, ale otwiera również specjalny kanał komunikacyjny dla obu końców łącza co umożliwia:

- sprawdzenie haseł
- uzgodnienie opcji szyfrowania
- podłączenie kilku łączy w celu przyspieszenia transmisji
- przesyłanie pakietów z innych sieci niż IP (tunneling)
- przypisywanie dynamicznego numeru hostowi inicjującemu połączenie

Żeby przyłączyć się do internetu trzeba skorzystać z usług ISP, którym jest firma mająca wykupione podłączenie do niego i zajmująca się jego komercyjnym udostępnianiem. 

#### Usługi

BBS

Wdzwaniana usługa udostępniania plików.

E-mail

Poczta elektroniczna

Gopher (ang. świstak)

Przodek WWW, wprawdzie samo WWW powstało wcześniej jednak zanim się rozwinęły odpowiednie programy Gopher przeżył krótki okres świetności. 
Umożliwia przeglądanie zasobów sieci przez prosty hierarchicznie skonstruowany system menu. 
Zapewnia dostęp do plików (graficznych, tekstowych, dźwiękowych), baz danych jak i system poszukiwania informacji (Veronica). 
Wyparty przez znacznie prostsze w użyciu i mające większe możliwości WWW. 

Fidonet

W pełni amatorska sieć BBS-ów udostępnianych przez użytkowników. 
FTN Fidonet Technology Network. 

Finger

Prosta usługa umożliwiająca sprawdzenie kto jest aktualnie zalogowany na serwerze internetowym. 

FTP

Kopiowanie plików między komputerami
Sieciowe archiwa FTP

IRC (Internet Relay Chat)

Interfejs natychmiastowej komunikacji tekstowej - sieciowe pogawędki w czasie rzeczywistym. Powstała by umożliwić kontakt w czasie rzeczywistym. Ostatnio wyparty przez czaty WWW oraz IM
Rozmowy na IRC-u toczą się na tzw. kanałach, z których każdy ma swoją nazwę określającą tematykę (#polska, #wroclaw #pecet #sex)
Trzeba połączyć się z serwerem za pomocą klienta IRC (np. irssi) i przyłączyć się do, któregoś z otwartych kanałów (są też dostępne za hasłem i ukryte) używająć unikalnego nicku. 
Uprzywilejowany użytkkownik, tzw. op (od "operator") może zmieniać tryb pracy kanału, temat, wyrzucać użytkowników, lub banować ich. 

Listy dyskusyjne

Usługa bazująca na swoistym systemie dystrybucji emaila, umożliwia publiczną dyskusję za pośrednictwem listserwerów. 

Telnet

Umożliwia pracę na zdalnym serwerze. 

Usenet

Grupy dyskusyjne. 

WAIS (Wide Area Information Server - serwer informacji w sieciach rozległych)

Umożliwiał przeszukiwanie rozproszonych baz danych za pomocą prostego interfejsu. 
Wyparty przez WWW. 

WWW (World Wide Web)

Dokumenty hipertekstowe, najpopularniejsza usługa internetu.

### Warstwy sieci

#### Model OSI

Na początku lat 80-tych ISO opracowała warstwowy model protokołów stanowiący wzorzec do konstrukcji wszelkich innych międzyplatformowych rozwiązań. Jest to model OSI (Open Systems Interconnect Reference Model - Model Referencyjny Połączonych Systemów Otwartych). Został opublikowany w celu ułatwienia realizacji otwartych (czyli występujących w środowiskach wielosystemowych) połączeń komputerowych. Wydzielił warstwy funkcjonalne wymagane do obsługi połączeń. 
Pozwala to na podzielenie całego problemu komunikacji na oddzielne części, tzw. warstwy. 

Tak naprawdę podczas sesji komunikacyjnej pracują nie poszczególne protokoły lecz ich stos (złożenie). 

W nawiasie kwadratowym numer warstwy.

[7] warstwa aplikacji (ang. _application layer_)

Protokoły bezpośrednio wykorzystywane przez aplikacje (np. HTTP, FTP). 
Stanowi interfejs pomiędzy aplikacjami użytkownika a usługami sieci. 

[6] warstwa prezentacji (ang. _presentation layer_)

Protokoły przygotowujące i formatujące odpowiednio dane (np. do wydruku). 
Dane z niższych warstw są przekształcane tak aby mogły być odebrane przez aplikację użytkownika, np konwersja między różnymi formatami liczb używanych przez serwer i klienta. 
Nie wszystkie stosy protokołów wyodrębniają tą warstwę, czasem traktowana jest jako pozostałość z epoki terminalowej. Jest odpowiedzialna za wygląd, a ściśle rzecz biorąc kodowanie wszelkich danych, także szyfrowanie i rozszyfrowanie. 
W większości przypadków warstwa prezentacji i sesji są połączone w jedną całość. 

[5] warstwa sesji (ang. _session layer_)

Koordynacja wymienianych informacji za pomocą technik konwersacyjnych. 
Podobnie jak poprzednia pochodzi ze starszych rozwiązań komunikacyjnych. Zarządzanie połączeniami pomiędzy aplikacjami (gniazda - ang. _sockets_). Na tym poziomie nabiera znaczenia rodzaj przesyłanych informacji, kończy się czysta wymiana bitów. Pozwala zrealizować usługi w rodzaju pobierania z serwera zawartości katalogu dyskowego. 
Rzadko wydzielana ponieważ wiele protokołów funkcje tej warstwy dołącza do swoich warstw transportowych. 

[4] warstwa transportowa (ang. _transport layer_)

Odpowiada na żądania usługi od warstwy sesji wysyła żądania do warstwy sieci. Zapewnia przezroczyste przesyłanie danych pomiędzy hostami, oraz zwolnienie wyższych warstw od zajmowania się wiarygodnym i efektywnym przesyłaniem danych. Przesyła wiadomości kanałem stworzonym przez warstwę sieciową. Zajmuje się bezpieczeństwem i pewnością wymiany danych. 
Odpowiada za to, żeby dane dotarły bez zniekształceń do odbiorcy. Zamienia mało wiarygodne bardzo podstawowe usługi sieciowe zapewniane przez warstwę sieciową w wiarygodną komunikację. Zapewnia poprawność komunikacji, integralność przesyłanych danych. Kontrola kompletności przekazywania informacji, właściwego uporządkowania pakietów, jest także odpowiedzialne za korektę błędów i kontrolę przepływu. 
Wszystkie warstwy leżące poniżej pomijają bezpieczeństwo skupiając się na szybkości. 
Funkcja podobna do warstwy łącza danych, ale w odróżnieniu od niej umożliwia również ich weryfikację poza lokalnym segmentem sieci LAN, potrafi np. wykrywać pakiety, które zostały odrzucone przez ruter i żądać ich ponownej transmisji. Ważną funkcją jest układanie nadchodzących danych w kolejności wysyłania, identyfikacja oryginalnej sekwencji pakietów przed wysłaniem ich do warstwy sesji. 
Istnieje wiele usług warstwy transportowej, ale najczęsciej używane są:

- TCP - bardziej skomplikowany, zapewniający połączenie i zorientowany na bajty strumień, z kontrolą błędów, kierowaniem przepływem i dostarczeniem pakietów we właściwej kolejności
- UDP - bardzo prosta datagramowa usługa, która zapewnia kontrolę błędów w ograniczonym stopniu

Niektóre rzeczy takie jak orientacja na połączenie mogą zostać zaimplementowane albo na poziomie warstwy transportowej albo (co jest łatwiejsze) warstwy sieci. 

[3] warstwa sieciowa/sieci (ang. _network layer_)

Ustalenie drogi jaką będą przesyłane dane. 
Dostarczenie pakietu pod wskazany adres, niezależnie od stopnia złożoności sieci. Odnajdywanie optymalnej trasy transmisji pomiędzy urządzeniem nadającym a odbierającym (ruting), w zależności od danych warunków (kontrola przepływu), przy czym dla kolejnych pakietów tej samej wiadomości drogi do celu mogą być różne. 
Zamienia ciąg bitów w kanał komunikacyjny, dba o to by informacje przepływały między odpowiednimi komputerami. Dane wymieniane są w postaci pakietów, ale nie jest sprawdzana ich zawartość, brak mechanizmów korekcji błędów. 
Odpowiada za żądania usług od warstwy transportowej i wydaje żądania do warstwy danych. Adresuje wiadomości i tłumaczy nazwy na adresy fizyczne, także określa drogę z żródła do miejsca przeznaczenia i reguluje ruch używając przełączników, ruterów i kontroli zagęszczenia pakietów danych. 
Zapewnia funkcjonalne i proceduralne środki przesyłu różnych długości sekwencji danych ze źródła do przeznaczenia przez jedną lub więcej sieci, utrzymując jakość usług żądaną przez warstwę transportową. 
Jeśli nie można skontaktować się z miejscem na poziomie tej warstwy to w ogóle nie można się z tym miejscem skontaktować. 
Protokoły dynamicznego trasowania pakietów (RIP czy OSPF) oraz ICMP kontrolują komunikację i informują o osiągalności hosta docelowego

[2] warstwa łącza danych (ang. _link layer_)

Protokoły definiujące zasady komunikacji pomiędzy połączonymi łączem fizycznym urządzeniami (protokoły warstwy wyższej nie wymagają istnienia bezpośredniego połączenia). Dane pakowane są w bloki zwane ramkami (PPP). 
Steruje fizyczną wymianą bitów; w większości przypadków połączona z warstwą fizyczną w jedną całość tworząc kartę sieciową. 
Odpowiedzialna za upakowanie instrukcji, danych w tzw. ramki zwierające informacje wystarczające do pomyślnego przesłania danych do ich miejsca przeznaczenia. Zbiera także bity danych przesłanych przez warstwę fizyczną i składa je ARP zapewniający odwzorowanie adresu logicznego warstwy internetu na adres sprzętowy karty sieciowej, co jest konieczne dla nawiązania komunikacji na obu tych warstwach
Wykrycie oraz usuwanie błędów jakie mogły się pojawić w warstwie fizycznej. 

[1] warstwa fizyczna (ang. _physical layer_)

Warstwa określająca specyfikacje techniczne łączących się urządzeń (np. parametry elektryczne, rodzaje złącz, parametry czasowe, itp.), zwane inaczej interfejsami fizycznymi (interfejsem jest np. RS 232, definiujący standardowy port szeregowy, do którego podłączony jest modem). 
Fizyczna transmisja danych bez kontroli ruchu i bez uwzględnienia rodzaju informacji, ciągłość transmisji nie jest zabezpieczona. 
Przesyłanie i odbieranie strumieni bitów. Nie rozróżnia wysyłanych sygnałów, "widzi" tylko zera i jedynki, jest zajęta tylko fizycznymi właściwościami elektrycznych, optycznych lub innych technik przenoszenia sygnałów. 
Fizyczne parametry urządzeń transmisyjnych, np. standard okablowania

Tak wygląda odniesienie rzeczywistej komunikacji TCP/IP do modelu OSI (za Aeleen Frisch "UNIX - Administracja systemu"). 

```
                OSI                 TCP/IP
                -------------------------------------------------------------------------
                Warstwa aplikacji                | Warstwa aplikacji
                określa jak aplikacje łączą się   |obsługuje wszystko inne. Usługi sieci
                z siecią i zapewnia odpowiednie   |TCP/IP (zazwyczaj implementowane
                usługi    |jako demony) muszą wykonać swoje
                ----------------------------------|z warstwy prezentacji modelu
                Warstwa prezentacji               |OSI i częściowo z warstwy sesji
                określa sposób przedstawienia     |
                danych aplikacji                  |Wiele protokołów, w tym NFS, DNS,
                ----------------------------------|FTP, Telnet, SSH, HTTP itd.
                Warstwa sesji                     |
                tworzy połączenia sieciowe,       |--------------------------------------
                zarządza nimi i je kończy         | Warstwa transportowa
                |zarządza wszystkimi aspektami
                ----------------------------------|dostarczania danych, w tym
                Warstwa transportowa              |inicjowaniem sesji, kontrolą błędów
                zapewnia kontrolę błędów          |i kolejności
                i kolejności danych               |
                przekazywanych siecią             |Protokoły TCP i UDP
                |--------------------------------------
                ----------------------------------| Warstwa internetowa
                Warstwa sieciowa                  |odpowiada za adresowanie, transmisję
                odpowiada za adresowanie          |i rutowanie danych oraz fragmentację
                danych, rutowanie i sterowanie    |pakietów i ich ponowne składanie
                przepływem|
                |Protokoły IP i ICMP
                -------------------------------------------------------------------------
                Warstwa łącza danych              | Warstwa dostępu do sieci
                definiuje metody dostępu          |określa procedury przekazywania
                do nośnika fizycznego przez       |danych siecią, w tym sposoby
                karty sieciowe i związane         |dostępu do nośnika fizycznego
                z nimi sterowniki urządzeń        |
                ----------------------------------|Protokoły Ethernetu i ARP
                Warstwa fizyczna                  |(chociaż aktualnie nie
                Określa parametry działania       |jest zaliczany do TCP/IP
                nośnika fizycznego                |
                -------------------------------------------------------------------------
```

#### Model DoD

Model DoD (skrót DoD pochodzi od angielskiego Department of Defense, czyli Departament Obrony USA) to teoretyczny model warstwowej struktury protokołów komunikacyjnych. Model DoD został stworzony w latach 70-tych XX wieku w DARPA, aby pomóc w tworzeniu odpornych na atak sieci komputerowych. Potem stał się on podstawą struktury internetu.

Podstawowym założeniem Modelu DoD jest podział całego zagadnienia komunikacji sieciowej na szereg współpracujących ze sobą warstw (ang. _layers_). Każda z nich może być tworzona przez programistów zupełnie niezależnie, jeżeli tylko ustali się zasady według, których wymieniają się one informacjami. Założenia Modelu DoD są pod względem organizacji warstw zbliżone do Modelu OSI. Jednak ilość warstw jest mniejsza i bardziej odzwierciedla prawdziwą strukturę Internetu. Model DoD składa się z czterech warstw:

##### Warstwa aplikacji (ang. _process layer_)

Najwyższy poziom, w którym pracują aplikacje użytkownika takie jak, np. serwer WWW czy przeglądarka internetowa. Obejmuje ona zestaw gotowych protokołów, które aplikacje wykorzystują do przesyłania różnego typu informacji w sieci.

##### Warstwa transportowa (ang. _host-to-host layer_)

Zapewnia pewność przesyłania danych oraz kieruje właściwe informacje do odpowiednich aplikacji. Opiera się to na wykorzystaniu portów określonych dla każdego połączenia. W jednym komputerze może istnieć wiele aplikacji wymieniających dane z tym samym komputerem w sieci i nie nastąpi wymieszanie się przesyłanych przez nie danych. To właśnie ta warstwa nawiązuje i zrywa połączenia między komputerami oraz zapewnia pewność transmisji.

##### Warstwa sieciowa (ang. _internet protocol layer_)

Warstwa sieciowa lub warstwa protokołu internetowego to podstawa działania internetu. W tej warstwie przetwarzanie są pakiety posiadające adresy IP. Ustalana jest odpowiednia droga do docelowego komputera w sieci. Niektóre urządzenia sieciowe posiadają tą warstwę jako najwyższą. Są to routery, które zajmują się kierowaniem ruchu w Internecie, bo znają topologię sieci. Proces odnajdywania przez rutery właściwej drogi określa się jako ruting (ang. _routing_).

##### Warstwa dostępu do sieci (ang. _network access layer_)

Warstwa dostępu do sieci lub warstwa fizyczna jest najniższą warstwą i to ona zajmuje się przekazywaniem danych przez fizyczne połączenia między urządzeniami sieciowymi. Najczęściej są to karty sieciowe lub modemy. Dodatkowo warstwa ta jest czasami wyposażona w protokoły do dynamicznego określania adresów IP.

Model DoD a Internet:
Każdy protokół sieciowy można przyporządkować do określonej warstwy Modelu DoD. Pewną szczególną cechą rodziny protokołów TCP/IP używanej w internecie jest podział protokołów z warstwy aplikacyjnej i połączeniowej. Niektóre protokoły z warstwy aplikacji wykorzystują tylko pewne protokoły z warstwy transportowej. 
Protokoły DNS, NTP wykorzystują tylko protokół UDP z warstwy transportowej. Protokoły FTP, SMTP, POP3, SSH, IRC posługują się tylko TCP. Natomiast ED2k czy SMB używają obu protokołów. 
Protokół SSL ma szczególną rolę. Może zostać umieszczony pomiędzy każdym połączeniowym protokołem warstwy aplikacji, a TCP. Dzięki jego wykorzystaniu dane przesyłane przez aplikacje mogą zostać zaszyfrowane. 
Niektóre protokoły z warstwy aplikacji, jak np. SMB nie działają zwykle w Internecie. Są wykorzystane w sieciach lokalnych do udostępniania usług, jak np. zdalne drukarki czy dyski. 
Od ogólnego modelu DoD są w Internecie wyjątki. Przykładem może być tutaj usługa Ping, w której aplikacja wysyła bezpośrednio pakiety ICMP w celu ustalenia jakości połączenia z innym komputerem. 

#### Zestaw protokołów internetowych (ang. _Internet protocol suite_)

Jeszcze innym sposobem opisu jest tzw. zestaw protokołów internetowych

##### Warstwa aplikacji (ang. _application layer_)

Jest to warstwa sieciowych interfejsów programów działających w sieci; procesy w tej warstwie są specyficzne dla danej aplikacji, dane idą od programów sieciowych w ich wewnętrznym formacie i są kodowane w standard protokołu. 
W tej warstwie działają pewne specyficzne programy: HTTP (The World Wide Web), FTP (File transport), SMTP (Email), SSH (Secure remote login), DNS (Name &lt;-&gt; IP Address lookups) i inne (np. IRC, SNMP, SIP, RTP). 
Kiedy są już zakodowane w standard protokołu idą dalej w dół. 
W warstwie transportowej aplikacje najczęściej używają TCP lub UDP, najcześciej zwiazane z dobrze znanymi numerami portów, pierwotnie alokowane przez IANA - niektóre z nich:

- HTTP - TCP port 80 lub 8080
- SSH - TCP port 22
- Telnet - TCP port 23
- DNS lookups - UDP (a czasem TCP) port 53
- RIP routing updates - UDP port 520

Inne: DHCP (Kind-of), Echo, Finger, Gopher, HTTP, HTTPS, IMAP, IMAPS, IRC, NNTP, NTP, POP3, POPS, QOTD, RTSP, SNMP, Telnet, XDMCP.

##### Warstwa transportowa (ang. _transport layer_)

TCP, UDP, ICMP, SCTP, DCCP itd. 
Protokoły na poziomie transportowym są odpowiedzialne za niezawodność dotarcia pakietów do celu i zapewnienie, że dotrą tam we właściwym porządku. W zestawie protokołół TCP/IP warstwa transportowa określa również, dla jakiej aplikacji przeznaczone są dane. 
Protokoły dynamicznego rutingu, które technicznie występują w tej warstwie w zestawie TCP/IP (ponieważ idą przez IP) są generalnie uważane, za przynależne do warstwy sieci (przykładem jest OSPF - protokół IP numer 89). 
TCP (protokół IP numer 6) jest zorientowanym na połączenie mechanizmem transportowym zapewniającym wiarygodny ciąg bajtów, zapewniającym, że dane dotrą kompletne, nie zniekształcone i we właściwym porządku. TCP nieustannie sprawdza jak bardzo obciążona jest sieć i zapełnia ją dostosowując prędkość wysyłania danych tak by nie przeciążyć sieci. Ponadto TCP usiłuje dostarczyc dane we właściwym porządku. Są to główne różnice w porównaniu z UDP i może stanowić wadę np. w streamingu czasu rzeczywistego. 
UDP (protokół IP numer 17) jest bezpołączeniowym protokołem datagramu. Jest to protokół "najlepszych starań" lub "niewiarygodny" ponieważ nie przeprowadza weryfikacji czy pakiety osiągnęły miejsce przeznaczenia i nie daje żadnej gwarancji, że dotrą we właściwym porządku. Jeśli aplikacja potrzebuje takich mechanizmów musi sama ich dostarczyć lub użyć TCP. UDP jest zwykle używany dla takich aplikacji jak media strumieniowe (audio i wideo) kiedy przyjście na czas jest ważniejsze niż wiarygodność, lub dla prostych pytanie/odpowiedź aplikacji jak DNS lookups, gdzie koszt ustanowienia wiarygodnego połączenia byłby nieproporcjonalnie duży. 
Oba protokoły - TCP i UDP są używane by transportować dane aplikacje wysokiego poziomu, są rozróżniane według swojego numeru portu TCP lub UDP. Zazwyczaj pewne dobrze znane porty (ang. _well known ports_) są powiązane z pewnymi określonymi usługami. 

##### Warstwa sieci (ang. _network layer_)

IPv4, IPv6, ARP itd. 
Tak jak to pierwotnie zdefiniowano warstwa sieciowa rozwiązuje problem przesyłania pakietów przez sieć. Przykładami takiego protokołu są X.25 i ARPANET-owy Host/IMP Protocol
Kiedy pojawiła się koncepcja międzysieci (_internetworking_) została dodana dodatkowa funkcja - przesłanie danych z sieci źródłowej do sieci docelowej. Ogólnie rzecz biorąc włącza to rutowanie pakietów poprzez sieć sieci znaną jako internet. 
W zestawie protokołów internetowych IP spełnia zadanie przesyłania pakietów ze źródła do miejsca przeznaczenia. IP może przenosić dane dla pewnej liczby protokołów wyższego rzędu, są one zidentyfikowane przez unikalny _IP Protocol Number_. Np. ICMP i IGMP są odpowiednio protokołami 1 i 2. 
Niektóre protokoły przenoszone przez IP takie jak ICMP (używany do transmitowania danych diagnostycznych) i IGMP (używany do danych typu multicast) są umieszczone nad IP, ale wykonują zadania warstwy sieci, co ilustruje niezgodność pomiędzy modelem internetowym a modelem OSI. 
Wszystkie protokoły rutingu takie jak BGP, OSFP i RIP są również częścią warstwy sieci, chociaż mogłoby się wydawać, że są w stosie umieszczone wyżej.

##### Warstwa łącza danych (ang. _data link layer_)

Ethernet, Wi-Fi, Token ring, FDDI itd. 
Określa jak pakiety są transportowane w warstwie fizycznej, włączając w to dzielenie na ramki (tzn. specjalny wzór bitów, który oznacza początek i koniec pakietu). Ethernet np. włącza pola w nagłówek pakietu, które określają dla której/których maszyny/maszyn jest przeznaczony pakiet. Przykładami protokołów warstwy łącza danych są Ethernet, Wireless Ethernet, SLIP, Token Ring i ATM. 
PPP jest bardziej złożony ponieważ był początkowo zaprojektowany jako oddzielny protokół który działa nad innymi protokołami tej warstwy, HDLC/SDLC. 
Czasem jest dzielona na Logical Link Control oraz Media Access Control. 

##### Warstwa fizyczna (ang. _physical layer_)

RS 232, Rs 449, itd. 
Opisuje fizyczną charakterystykę komunikacji, taką jak charakterystykę medium użytego do komunikacji (kable, światłowód lub łącza radiowe) i wszystkie inne powiązane szczegóły łącza. 
Zestaw protokołów internetowych nie dotyczy fizycznej warstwy żadnej sieci. 

Zestaw protokołów internetowych jest zbiorem protokołów komunikacyjnych, składających się na stos protokołów, umożliwiającą działalność internetu. Ponieważ dwa najważniejsze z nich to TCP i IP czasem jest nazywany złożeniem protokołów TCP/IP. 
Może być opisany przez analogię z modelem OSI, który opisuje warstwy stosu protokołów. Są pomiędzy nimi różnice. W stosie protokołów każda warstwa rozwiązuje pewien zestaw problemów, włączajac w to transmisję danych, oraz zapewnienie dobrze zdefiniowanych usług dla wyższych warstw, które są logicznie bliżej użytkownika i przetwarzają bardziej abstrakcyjne dane, na niższe warstwy przekładając przetworzenie danych w postać, która może być fizycznie przetwarzana. 
Model internetowy został powstał jako rozwiązanie praktycznych problemów inżynieryjnych. Z drugiej strony model OSI jest podejściem bardziej teoretycznym i powstał na wcześniejszym etapie ewolucji sieci, więc model OSI łatwiej zrozumieć, ale tak naprawdę model internetowy wszedł w życie. 

#### Praktycznie

Warstwy w stosie TCP/IP
Model OSI nie jest dość bogaty w dolnych warstwach by uchwycić prawdziwe warstwy, potrzebna byłaby dodatkowa warstwa pomiędzy warstwą sieci a transportową (warstwa internetowa). 
Następujące warstwy istnieją w oryginalnym modelu OSI:

- 7 - Aplikacji (_Application_) np. HTTP, SMTP, SNMP, FTP, Telnet, SSH i Scp, NFS, RTSP
- 6 - Prezentacji (_Presentation_) np. XDR, ASN.1, SMB, AFP
- 5 - Sesji (_Session_) np. TLS, SSH, ISO 8327 / CCITT X.225, RPC, NetBIOS, ASP
- 4 - Transportowa (_Transport_) np. TCP, UDP, RTP, SCTP, SPX, ATP
- 3 - Sieci (_Network_) np. IP, ICMP, IGMP, X.25, CLNP, ARP, RARP, BGP, OSPF, RIP, IPX, DDP
- 2 - Łącza danych (_Data Link_) np. Ethernet, Token ring, PPP, HDLC, Frame relay, ISDN, ATM, 802.11 WiFi, FDDI
- 1 - Fizyczna (_Physical_) np. elektryczność, radio, laser

Najcześciej górne trzy warstwy tego modelu (aplikacji, prezentacji i sesji) są traktowane jako pojedyncza warstwa aplikacji w modelu TCP/IP. Ponieważ nie ma tam warstwy sesji funkcje te przejmują indywidualnie aplikacje, lub w ogóle nie są realizowane. 
Uproszczony model TCP/IP:

- Aplikacji (_Application "layer 7"_) - np. HTTP, FTP, DNS (protokoły rutingu takie jak BGP i RIP, które z różnych powodów działają na odpowiednio TCP i UDP mogą być również uważane za część warstwy sieci)
- 4 - Transportowa (_Transport_) np. TCP, UDP, RTP, SCTP (protokoły rutingu takie jak OSPF, które biegną na IP mogą być również uważane za warstwę sieci)
- 3 - Sieci (_Network_) - dla TCP/IP jest to IP (wymagane protokoły takie jak ICMP and IGMP biegną na IP, ale nadal mogą być rozważane jako warstwa sieciowa; ARP nie biegnie na IP)
- 2 - Łącza danych (_Data Link_) np. Ethernet, Token ring, etc.
- 1 - Fizyczna (_Physical_) np. warstwa fizyczna i techniki kodowania, T1, E1

W skrócie wygląda to tak: dane z aplikacji przekazywane są od warstwy aplikacji w dół do warstwy fizycznej, transmitowane do punktu docelowego, gdzie dokonywana jest czynność odwrotna: dane wędrują w górę od warstwy fizycznej do warstwy aplikacji. 

Transmisję danych można podzielić na dwa rodzaje:

- połączeniowe - dane sa wysyłane po zestawieniu kanału komunikacyjnego
- bezpołączeniowe - dane są po prostu wysyłane na adres, a sama trasa czy kolejność wysyłania poszczególnych pakietów nie ma znaczenia

Komunikacja połączeniowa może być symulowana w kanale bezpołączeniowym poprzez wymianę pakietów danych i potwierdzeń ich odbioru. Możliwa jest też sytuacja odwrotna. 

W komunikacji sieciowej wszystkie dane dzielone są na fragmenty o pewnej, możliwej do jednorazowego przesłania długości nazwane ogólnie pakietami. Każdy protokół posiada własny rodzaj pakietu, np. dla IP nazywa się on datagramem, dla TCP segmentem, a na poziomie warstwy łącza danych ramką. 

Struktura pakietu zawsze jest podobna: na początku znajduje się nagłówek zawierający różne specyficzne dla danego protokołu informacje (w tym również polecenia), a następnie blok danych, których treść nie jest dla protokołu istotna, traktuje on je wyłącznie jako ciąg danych do przesłania. 

Dane po kolei przechodzą do protokołów niższych warstw, które uzupełniają otrzymany pakiet własnym nagłówkiem, przekazują go niżej, aż do warstwy fizycznej, a po dotarciu do celu zaczyna się odwrotny proces. W każdej warstwie następuje "rozebranie" pakietu o jeden stopień, tak aby odczytać dane przesłane przez odpowiednią warstwę po drugiej stronie. A mogą być one najróżniejsze - np. numer kolejny bieżącego pakietu, potwierdzenie otrzymania kolejnego pakietu, informacja o błędzie, informacja o chęci zakończenia połączenia, kontroli parzystości, itp. 
Każda warstwa świadczy pewne usługi w określonym zakresie wobec warstw wyższych, np. warstwa sieciowa, w której działa protokół IP, odpowiada za dostarczenie pakietu pod wskazany adres, niezależnie od złożoności struktury sieciowej, przez którą musi być przesłany (dlatego stał się taki popularny). Nie zawiera jednak żadnych mechanizmów, pozwalających na weryfikację poprawności, czy kontrolę kompletności otrzymanych danych. Tym zajmuje się funkcjonujący szczebel wyżej - czyli w warstwie transportowej - protokół TCP. Czyli IP tylko przesyła dane na właściwy adres, a TCP sprawdza czy dotarły nienaruszone. 

Na samej górze mamy do czynienia z blokami danych na których operują aplikacje użytkownika, są to pliki w jakimś określonym formacie i bezpośrednio nimi zajmują się protokoły warstwy aplikacji. 
Warstwa transportowa dzieli te pliki na własne jednostki nazwane pakietami, które zawierają nagłówek zawierający m.in. adres portu docelowego i portu źródłowego oraz porcję informacji do wysłania. 

TCP zajmuje się ustanawianiem i kończeniem połączeń między procesami, dba o niezawodność transmisji, odpowiednią kolejność danych. TCP gwarantuje poprawność transmisji, musi sprawdzać czy wszystkie wysyłane pakiety dotarły do adresata, a po odebraniu porcji informacji wysyła potwierdzenie do nadawcy. W przypadku braku potwierdzenia odbioru protokół żąda ponownego wysłania aż do chwili nadejścia potwierdzenia. Ten mechanizm zapewnia ciągłość danych, ale obniża wydajność całego systemu. 
UDP natomiast jest znacznie uboższy, nie realizuje kontroli przepływu, ale jest szybki i nieskomplikowany. Używany w aplikacjach, które same dbają o poprawność transmisji. Posiada tylko dwie właściwości, których nie posiada IP: numer portu oraz nieobowiązkowa suma kontrolna. 

Z kolei warstwa sieciowa leżąca poniżej warstwy transportowej, w ogóle nie zajmuje się portami, jedyne co ma tutaj znaczenie to adres sieciowy docelowego i źródłowego komputera. Protokołem działającym w tej warstwie jest IP, który pakuje każdy pakiet TCP lub UDP w inny pakiet (datagram IP) zawierający adresy źródłowy i docelowy IP. Jest bezpołączeniowy co oznacza, że każdy z datagramów jest traktowany niezależnie, a wszelkimi połączeniami pomiędzy kolejnymi paczkami informacji zajmują się wyższe warstwy. Oblicza sumy kontrolne dla pakietów i w przypadku wykrycia błędów nie przesyła go dalej - oczekuje się, że protokół wyższego poziomu ponowi wysłanie. 

Adres często określony jest w postaci przyjaznej dla człowieka (domena internetowa) ale zupełnie niezrozumiałej dla komputera, za translację pomiędzy tymi rodzajami adresów odpowiada rozproszona baza danych - DNS - zawierająca informacje jakiemu dokładnie adresowi IP odpowiada dana domena. 

Po trafieniu do interfejsu sieciowego docelowego komputera zaczyna się odwrotna droga. Dane są "odpakowywane". 

#### Podsumowanie

1. host wysyła zapytanie do znanego sobie serwera DNS (konfiguracja w parametrach protokołu TCP/IP)
2. zapytanie wędruje przez hierarchię NDS i wraca jako adres IP
3. host sprawdzi za pomocą maski podsieci, że adres należy do innego segmentu więc wysyła pakiet na adres rutera (również konfiguracja w parametrach protokołu TCP/IP)
4. pakiet zostanie zapakowany do ramek, zgodnych z istniejącym w danej sieci standardem kart sieciowych i okablowania, ustalenie adresu MAC rutera następuje w wyniku protokołu ARP lub korzystając z tabeli odwzorowań w jego pamięci podręcznej
5. ruter po odebraniu ramek ponownie składa pakiet i stwierdza, że nie należy on do żadnej przyłączonej do niego sieci i wysyła do następnego rutera
6. podział na ramki odpowiednie dla sieci drugiego rutera i wysłanie na jego adres MAC
7. drugi ruter składa z ramek pakiet IP i kiedy stwierdzi, że adres należy do jego sieci, przy pomocy ARP pyta o adres MAC danego IP (jeśli nie ma go we własnej tablicy odwzorowań)
8. pakiet po podziale na ramki idzie do odbiorcy

Dane nie są zamykane w jednym pakiecie, ale są w pakiecie, który jest w innym pakiecie itd., średnio używa się 4 takich warstw, są jak koperta włożone jedna w drugą, jest to tzw "kapsułkowanie" (ang. _encapsulation_). 
Jest to niezbędne, bo trasa przesyłania jest skomplikowana, a na każdym etapie nie powinno się zawierać w danych pakietu więcej informacji niż jest niezbędne. Trasa prowadzi przez różne sieci, różne systemy, koperta zawiera tylko te informacje, które są potrzebne w sieci bieżącej. 
Ruter zdejmuje warstwę pakietu i nakłada drugą zawierającą informację na temat podróży do kolejnej sieci bez potwierdzenia powodzenia transmisji - bezpołączeniowe. 

#### Protokoły

Najpopularniejsze protokoły internetowe

##### DNS (Domain Name Service)

konwersja adresu pomiędzy postaciami liczbowymi i domenowymi (używa TCP i UDP)

##### FTP (File Transfer Protocol - Protokół Transferu Plików)

służy do kopiowania plików pomiędzy komputerami w sieci (używa TCP)

##### ICMP (Internet Control Message Protocol)

kontrola statusu urządzeń w sieci, umożliwia dostrojenie parametrów transmisji i sterowanie przepływem danych pomiędzy ruterami

##### IP (Internet Protokol - Protokół (Międzysieciowy) Internetowy)

wysyłanie danych do węzłów w sieci, określa strukturę adresów internetowych i pakietów danych

##### NFS (Network File System - Sieciowy System Plików)

definiuje system plików umożliwiając ich współdzielenie przez wiele komputerów w sieci (używa UDP)

##### TCP (Transfer Control Protocol - Protokół Kontroli Transferu)

formowanie i przesyłanie danych z kontrolą ich poprawności
określa strukturę zabezpieczonego kanału komunikacyjnego pomiędzy aplikacjami internetowymi

##### Telnet

praca na zdalnym komputerze (używa TCP)

##### TFTP (Trivial File Transfer Protocol - Uproszczony Protokół Transferu Plików)

uproszczona wersja FTP; m.in. brak kontroli uprawnień użytkowników (używa UDP)

##### SMTP (Simple Mail Transfer Protocol - Prosty Protokół Transferu Poczty)

przesyłanie poczty (używa TCP)

##### SNMP (Simple Network Management Protocol - Prosty Protokół Zarządzania Siecią)

zarządzanie siecią, udostępnia dane o zdarzeniach w sieci

##### UDP (User Datagram Protocol - Protokół Datagramu Użytkownika)

przesyłanie danych bez kontroli poprawności dostarczenia ich do adresata
zapewnia transport pakietów danych pomiędzy aplikacjami internetowymi ale bez gwarancji ich dostarczenia

W sieci komputery komunikują się za pośrednictwem urządzeń pośrednich, tzw. węzłów (ang. _node_ lub _hop_)

Stos protokołów TCP/IP jest sposobem na połączenie niepodobnych do siebie systemów komputerowych. Istnieją dokładne wytyczne dotyczące sposobu ich implementacji. Dzięki ich restrykcyjności poszczególne stosy są kompatybilne i umożliwiają komunikację między różnymi systemami. 
Protokół jest rutowalny dlatego umożliwia tworzenie rozległych sieci i daje pewność, że dane biegną najbardziej optymalną drogą. 

TCP/IP to wspólna nazwa dwóch podstawowych protokołów sieci Internet. Powstała oczywiście przez połączenie nazw TCP i IP. Udostępnia metody transmisji informacji pomiędzy poszczególnymi komputerami w sieci, obsługując pojawiające się błędy oraz tworząc wymagane do transmisji informacje dodatkowe. 
TCP/IP zwane jest także stosem protokołów ze względu na strukturę warstwową i zastosowanie modelu OSI. Tymi warstwami dla modelu TCP/IP są:

- warstwa aplikacji (programów użytkowych)
- warstwa transportu
- warstwa sieci (warstwa intersieci, internet)
- łącza danych warstwa interfejsu sieciowego

### Warstwa aplikacji

SMTP, FTP, TFTP, HTTP, POP3

### Warstwa transportowa (TCP i UDP)

Jest długa lista usług które mogą być opcjonalnie zapewniane na tym poziomie, żadna z nich nie jest obowiązkowa, ponieważ nie wszystkie aplikacje potrzebują wszystkich usług. Niektóre z nich są nadmiarowe, lub mogłyby by obniżać wydajność. 

Musi zapewnić:

- Podstawowy transfer danych (_basic data transfer_) - Przesyła ciągi oktetów (8-bitowe porcje danych) w obu kierunkach transmisji. Oktety przed transmisją pakowane są w segmenty danych. Protokół sam decyduje czy blok danych należy wysłać czy poczekać na jeszcze większą porcję. Czasem jednak użytkownik musi mieć pewność, że dane przesłane do protokołu TCP zostały wysłane do sieci (konkretnie do warstwy niższej, czyli IP) i nie są buforowane, wtedy wykorzystywana jest funkcja push powodująca wypchnięcie wszystkich oczekujących na transmisję danych - ale odbiorca nie otrzymuje żadnego znaku, że to ma miejsce i odbiera dane jak zwykły ciąg transmisji.
- Wiarygodność transmisji (_reliability_) - Ma za zadanie naprawić wszystkie błedy jakie mogły pojawić się w niższej warstwie. Musi zapewnić odzyskanie danych, które zostały zagubione, zniekształcone, zniszczone, zduplikowane, albo dostarczone w niewłaściwej kolejności. Każdy oktet otrzymuje swój unikalny numer sekwencyjny, dzięki czemu po odebraniu danych można je zebrać w odpowiedniej kolejności oraz wyeliminować duplikaty. 
Host odbierający musi potwierdzić odbiór segmentu przez wysłanie sygnału ACK (ang. _acknowledgement_ - potwierdzenie), jeśli w określonym czasie komputer wysyłający nie otrzyma potwierdzenia odbioru nastąpi retransmisja danych; ewentualne uszkodzenie lub przekłamanie danych można wykryć dzięki zastosowaniu odpowiednich sum kontrolnych. 
Cały ten system zapewnia, że błędy w transmisji nie powinny mieć wpływu na poprawność przesyłanych danych. W przypadku bardzo złej jakości łączy dane w ogóle mogą zostać nie dostarczone, na to jednak nie ma rady.
- Kontrola przepływu (_flow control_) - Komputer odbierający może sterować ilością danych wysyłanych przez komputer źródłowy ponieważ wysyła z każdym sygnałem potwierdzającym (ACK) tzw. okna, które informuje komputer wysyłający ile jeszcze oktetów może wysłać przed otrzymaniem kolejnego pozwolenia. 
Ilość pamięci w każdym komputerze jest ograniczona i bez kontroli przepływu szybszy komputer mógłby zalać każdego hosta taką ilością informacji z jaką tamten mógłby sobie nie poradzić. Kontrola przepływu zapewnia regulację szybkości przesyłania danych. Czasem jest to zapewnione przez samą sieć, jeśli jednak nie to warstwa transportowa może może dodać tę funkcję.
- Multipleksowanie (_multiplexing_) - Ponieważ zwykle działa wiele programów, procesów, które potrzebują skorzystać z usług TCP/IP trzeba im umożliwić równoczesne korzystanie z sieci. W tym celu TCP udostępnia dodatkowy zbiór adresów (inaczej portów) przypisywanych konkretnym procesom. 
Porty są podstawowym sposobem na adresowanie do wielu jednostek w jednej lokacji, np. pierwsza linia adresu pocztowego jest rodzajem portu i rozróżnia pomiędzy różnymi mieszkańcami tego samego domu. Aplikacja będzie nasłuchiwała na informację na własnym porcie dzięki czemu można używać wielu aplikacji sieciowych w tym samym czasie. 
Numer takiego portu (jest to 16-bitowa liczba) w połączeniu z adresem sieci i hosta wziętymi z warstwy komunikacyjnej tworzy tzw. gniazdo (ang. _socket_), a para gniazd identyfikuje każde połączenie. 

- Połączenia (_connections_) - Opisane powyżej mechanizmy wymagają najpierw zainicjowania a potem utrzymywania pewnych informacji statusowych dotyczących każdego przesyłanego strumienia danych. Kombinacja tych informacji (gniazda, numery sekwencyjne oraz wielkości okien) nazywana jest "połączeniem", każde z nich jest jednoznacznie identyfikowane przez dwa gniazda, po jednym na każdą ze stron. 
Kiedy dwa procesy mają zacząć komunikację muszą najpierw nawiązać połączenie (czyli wymienić informację statusową) a po zakończeniu komunikacji połączenie jest zamykane w celu zwolnienia zasobów
- Dostarczenie w tej samej kolejności (_same order delivery_) - Warstwa sieciowa generalnie nie gwarantuje, że pakiety danych dotrą w tej samej kolejności w jakiej zostały wysłane, ale często jest to pożądana właściwość i zapewnia ją warstwa transportowa. Najprostszym sposobem na zrobienie tego jest danie każdemu pakietowi numeru i pozwolenie odbiorcy na powtórne zamówienie pakietów.
- Przetworzenie na strumień bajtów (_byte orientation_) - zamiast operowania na zestawach pakietów warstwa transportowa może umożliwić komunikację przez strumień bajtów.

#### TCP (Transmission Control Protocol)

TCP jest protokołem komunikacyjnym warstwy transportowej, zdefiniowanym w IETF RFC 793. Zapewnia wiarygodność transmisji (_reliable-delivery_), przesyła ciąg bajtów (_byte-stream_) i jest połączeniowym (_connection-oriented_) protokołem. 
Został stworzony przez Vintona Cerfa i Roberta Kahna w latach 70-tych w ramach projektu ARPANET. 

Przekłada proces komunikacji z poziomu łatwego do użycia przez człowieka na poziom łatwy do użycia (transmisji) przez sieć. 

Jest on częścią większej całości określanej jako stos TCP/IP. 
W modelu OSI TCP odpowiada warstwie transportowej. 
W zestawie protokołów internetowych TCP jest pośrednią warstwą pomiędzy leżącym poniżej IP i aplikacjami z wyższej warstwy, które często potrzebują wiarygodnej, połączeniowej (_pipe-like_) komunikacji - czego IP nie zapewnia, bo zajmuje się tylko przesyłaniem pakietów pomiędzy różnymi hostami. 

Pierwsza specyfikacja powstała w 1974, była to opublikowana w IEEE Transactions praca "A Protocol for Packet Network Intercommunication". Trzy lata później, w lipcu 1977 odbył się eksperyment, w którym tego protokołu użyto do transmisji danych przez różne media (sieć ARPANET, Packet Radio i łącza satelitarne) na dużą odległość (USA - Anglia i z powrotem). 

W pierwotnej wersji protokołu nie było rozróżnienia pomiędzy TCP i IP ale w trakcie eksperymentów nad przesyłaniem zakodowanego głosu okazało się, że retransmisja błędnych pakietów powoduje przerwy w odtwarzaniu dźwięku. 
Oddzielono więc protokół IP odpowiedzialny za adresowanie od TCP odpowiedzialnego za pakietowanie i oprócz TCP powstał UDP, w którym brak jest kontroli prawidłowości przesyłanych pakietów. 
W ten sposób transmisja danych została podzielona między dwie warstwy, z których jedna (IP) zajmuje się dostarczeniem ich do docelowego hosta poprzez różne rodzaje sieci, a druga (TCP lub UDP) komunikuje między sobą procesy na tych hostach. 

TCP jest złożonym i rozwijającym się protokołem. Ale pomimo upływu czasu podstawowe zasady nie uległy większym zmianom od RFC 739 opublikowanego w 1981. 

- RFC 739
- RFC 1122, Host Requirements for Internet Hosts - wyjaśnił wymagania wobec implementacji protokołu TCP.
- RFC 2581, TCP Congestion Control - opisuje uaktualnione algorytmy jakie powinny zostać użyte w celu uniknięcia nadmiernego przeciążenia.
- RFC 3168 (2001) opisuje ECM (_Explicit Congestion Notification_) mechanizm unikania przeciążenia.

Obecnie TCP jest używane w około 95% internetowych pakietów. Najpopularniejsze aplikacje używające TCP to m.in.: HTTP/HTTPS, SMTP/POP3/IMAP i FTP. 
W ciągu ostatnich lat znacznie wzrosła prędkość łączy sieciowych, protokół zaprojektowany dla powolnych sieci (kilka KBps) teraz musi przesyłać 1 Gbps. Implementacje wymagają więć znacznie wiecej mocy - 1 Gb komunikacji TCP pochłania 100% mocy procesora Pentium 2.4 GHz. 

TCP używa pojęcia numerów portów, żeby zidentyfikować wysyłające i odbierające aplikacje. Każda strona połączenia ma skojarzony 16-bitowy numer portu przydzielony do wysyłającej lub odbierającej aplikacji. Oficjalnie uznanych jest 65535 portów. 
Podzielone są na trzy podstawowe kategorie:

dobrze znane:

przydzielone przez IANA, są zwykle używane na poziomie systemu lub procesów roota, dobrze znane aplikacje, które działają jako serwery lub pasywnie nasłuchują na połączenia używają właśnie tych portów;
przykłady: FTP (21), Telnet (23), SMTP (25), HTTP (80)

zarejestrowane:

zwykle używane przez aplikacje końcowego użytkownika jako efemeryczne porty źródłowe podczas kontaktowania się z serwerami, ale mogą także identyfikować usługi, które zostały zarejestrowane przez trzecią stronę. 

dynamiczne/prywatne:

mogą być także używane przez aplikacje użytkownika, ale jest to rzadsze; nie posiadają żadnego znaczenia poza konkretnym połączeniem TCP

W przeciwieństwie do UDP, TCP jest zorientowany na połączenie i zapewnia niezawodność, tworzy wiarygodne połączenie dla wyższych warstw komunikacyjnych przy pomocy sum kontrolnych i numerów sekwencyjnych pakietów, w celu weryfikacji wysyłki i odbioru. Brakujące pakiety są obsługiwane przez żądania retransmisji. 
Host odbierający pakiety TCP porządkuje je według numerów sekwencyjnych tak, by przekazać wyższym warstwom modelu OSI pełen, złożony segment. 
Protokół gwarantuje, że dane wysłane z jednego miejsca trafią do hosta docelowego w całości, bez utraty pakietów i we właściwej kolejności. Rozróżnia także dane skierowane do różnych aplikacji na tym samym komputerze. 
Posiada wbudowany mechanizm kontroli błędów, który naprawia błędy powstające w niższych warstwach, osiąga się to przez tworzenie odrębnych połączeń logicznych i zapewnienie, że wysyłane dane zostaną dostarczone do wyższych warstw we właściwej kolejności. 

Aplikacje wysyłają strumienie bajtów do TCP w celu przesłania przez sieć. TCP dzieli te strumienie bajtów na segmenty odpowiedniej wielkości zwykle określonej przez rozmiar największej jednostki transmisji - MTU (_maximum transmission unit_) poziomu łącza danych sieci, do której podłaczony jest komputer. 

Rozmiar okna TCP
U odbierającego TCP jest to ilość otrzymywanych danych (w bajtach) która może być buforowana w czasie połączenia. Wysyłający host może wysłać tylko taką ilość danych zanim nie musi poczekać na potwierdzenia i uaktualnienie okna odbierającego hosta. Okno stosu TCP/IP jest zaprojektowane do samodostrojenia się w większości środowisk i używa większych domyślnych rozmiarów okien niż we wcześniejszych wersjach. 
Skalowanie okien: dla bardziej wydajnego użycia przepustowości sieci może zostać użyty większy rozmiar okna TCP. Pole okna TCP kontroluje przepływ danych i jest ograniczone do 2 bajtów lub rozmiaru okna 65535 bajtów. 
Ponieważ wielkość tego okna nie może być zwiększona używany jest czynnik skalowania - jest to opcja używana do zwiększania maksymalnego rozmiaru okna z 65535 bajtów do 1 GB. Stosowane tylko w czasie potrójnego uścisku dłoni TCP. Wartość skali okna reprezentuje ilość bitów przesunięcia w lewo 16-bitowego pola rozmiaru okna, może mieć wartość od 0 (brak przesunięcia) do 14. 

Potem TCP przekazuje pakiety do IP w celu przekazania przez internet do modułu TCP jednostki na drugim końcu połączenia. 
TCP nadaje każdemu bajtowi kolejny numer używany dla upewnienia się, że żadne pakiety nie zostały utracone, że dane zostały dostarczone we właściwej kolejności oraz, że nie są zduplikowane. Moduł TCP na drugim końcu odsyła potwierdzenia dla bajtów, które zostały odebrane pomyślnie. Zegar (_timer_) wysyłającego TCP określa limit czasu oczekiwania (_timeout_) - jeśli potwierdzenie nie zostało odebrane w przewidywanej ilości cyklów podróży i (przypuszczalnie utracony/zagubiony) dane będą wtedy retransmitowane. Zapewnia to wykrycie i dostosowanie się do utraty lub opóźnienia. 
TCP sprawdza czy żadne bajty nie zostały zniszczone używając sum kontrolnych - jedna jest wyliczana na komputerze wysyłającym dla każdego pakietu danych przed wysłaniem i sprawdzana u odbiorcy. 

W czasie fazy ustanowienia połaczenia TCP pomiędzy dwoma modułami TCP wymieniane są numery sekwencji począkowej (ISN - _initial sequence numbers_). Te numery sekwencji są używane do identyfikacji danych w strumieniu bajtów i są numerami, które identyfikują (i liczą) bajty danych aplikacji. Zawsze jest para numerów sekwencji włączonych w każdy segment TCP, które są określane jako numer sekwencji i numer potwierdzenia. Wysyłający TCP odnosi się do swojego własnego numeru sekwencji jako numer sekwencji, a do numeru sekwencji odbierającego jako numer potwierdzenia. Aby zapewnić wiarygodność odbiorca potwierdza segment danych przez wskazanie, że został przyjęty do pewnego miejsca w strumieniu bajtów. Rozszerzenie TCP nazwane selektywnym potwierdzeniem (SACK) pozwala odbierającemu na potwierdzenie popsutych bloków. 
Dzięki użyciu sekwencji i numerów potwierdzeń TCP może we właściwy sposób dostarczyć otrzymane segmenty we właściwym strumieniu bajtów do aplikacji. Numery sekwencji są to 32-bitowe niepodpisane numery, które wracają do zera w następnym bajcie w strumieniu po 232-1. Wybór ISN jest podstawowym mechanizmem bezpieczeństwa TCP. 

16-bitowa, suma kontrolna jest wyliczana przez nadawcę i włączana w transmisje segmentów. 
Suma TCP pokrywa także 96-bitowy pseudonagłówek zawierający adres źródłowy, adres przeznaczenia, protokół i długość TCP. To zabezpiecza przed błędnie rutowanymi segmentami. 
Jest jak na współczesne standardy dość słabe zabezpieczenie. Warstwa łącza danych z wysokim prawdopodobieństwem stopnia błędu bitów może wymagać dodatkowych możliwości wykrycia i naprawy błędu łącza. Słabość sumy jest częściowo kompensowana przez powszechne użycie CRC lub lepszą kontrolę na warstwie 2 poniżej TCP i IP - tak jak jest użyte w ramce PPP lub Ethernetu. Jednakże nie znaczy to wcale, że 16-bitowa suma kontrolna TCP jest redundantna. Badania ruchu internetowego pokazały, że programowe i sprzętowe błędy są pomimo tych zabezpieczeń powszechne, a 16 bitowa suma nagłówka TCP wychwytuje tylko większość z nich. 

Procedura nawiązania połączenia ponieważ zawiera trzy fazy nazywana jest potrójnym uściskiem dłoni (ang. _three-way handshake_), jest to sposób na nawiązanie sesji. Ma ona na celu synchronizację wysyłania i odebrania segmentu danych, informowania drugiego hosta o rozmiarze paczki (okna) danych, które jesteśmy w stanie odebrać, oraz utworzenie wirtualnego połączenia w sieci. 

1. Ustanowienie połączenia - inicjalizowane są parametry takie jak numery sekwencji, by można było zapewnić odpowiednią sprawność połączenia; chociaż zainicjowanie połaczenia równocześnie jest możliwe dla pary końcowych hostów, zazwyczaj jeden koniec otwiera gniazdo i biernie nasłuchuje na połączenie z drugiego - jest to powszechnie określane jako bierne/pasywne otwarcie i wyznacza stronę serwera w połączeniu
1. Strona klienta inicjuje aktywne połączenie wysyłając inicjujący segment SYN do serwera; jeśli to host inicjuje połączenie wysyła pakiet zawierający segment TCP z ustawioną flagą SYN (_Synchronize_).
2. Host (serwer) odbierający połączenie powinien odpowiedzieć na prawidłowe żądanie SYN przez SYN/ACK - odsyła pakiet z ustawionymi flagami SYN i ACK (_Acknowledge_ - potwierdzenie).
3. Na końcu inicjujący host (klient) powinient eraz wysłać pierwszą porcję danych, ustawiając już tylko flagę ACK (gasząc SYN). Odpowiedź ACK kończy trzystopniowy uścisk dłoni i fazę ustanowienia połączenia. 
Jeśli host odbierający połączenie nie chce lub nie może odebrać połączenia, powinien odpowiedzieć pakietem z ustawioną flagą RST (_Reset_).
2. Transfer danych
3. Zakończenie połączenia - używa poczwórnego uścisku dłoni, przy czym każda strona może zacząć niezależnie, typowe przerwanie połączenia (_teardown_) wymaga pary segmentów FIN i ACK z każdego końca TCP

Potwierdzenia dla wysłanych danych lub brak potwierdzeń są używane przez wysyłąjącego do pośredniego wnioskowania o stanie sieci pomiędzy wysyłającym a odbierającym. Dzięki użyciu zegara (_timer_) wysyłający i odbierający mogą zmieniać zachowanie strumienia danych, jest to nazywane jest kontrolą strumienia, przeciążenia i/lub unikaniem przeciążenia. 
TCP używa pewnych mechanizmów by osiągnąć wysoką wydajność i uniknąć przeciążenia sieci (np. przez wysyłanie danych szybciej niż odbierający może je przyjąć), te mechanizmy to: użycie przesuwanego okna, algorytm powolnego startu, algorytm unikania przeciążenia, algorytm szybkiej retransmisji i szybkiego odzyskania i inne. 

Aplikacje, w których zalety TCP przeważają nad wadami (większy koszt związany z utrzymaniem sesji TCP przez stos sieciowy) to między innymi HTTP, SSH, FTP czy SMTP/POP3 i IMAP4. 
Jednakże dla wielu aplikacji TCP nie jest właściwym rozwiązaniem. Nowsze protokoły warstwy transportowej są projektowane i wdrażane by zminimalizować wady komunikacji bezpołączeniowej. Dla przykładu niektóre aplikacje czasu rzeczywistego nie potrzebują takiej kontroli wiarygodności transmisji i łatwiej sobie radzą ze stratami danych. 
Przykładowe aplikacje tego typu to: streaming czasu rzeczywistego (np. radio internetowe), wieloosobowe gry czasu rzeczywistego i VoIP. W wielu przypadkach kiedy wymagany jest tylko multipleksing usług właściwszym wyborem będzie UDP. 

#### UDP (User Datagram Protocol)

Wszystkie implementacje TCP/IP muszą również wspierać prostszy protokół. 

UDP jest minimalnym protokołem warstwy transportowej zorientowanym na wiadomość; udokmentowanym w IETF RFC 768. 
UDP często jest używany w aplikacjach działających na zasadzie żądanie - odpowiedź, lub kiedy transmisja skierowana jest do wszystkich urządzeń w danym segmencie (_broadcast_) lub do pewnej grupy urządzeń (_unicast_) - użycie w takim przypadku TCP spowodowałoby nadmiar niepotrzebnych informacji. 
Prośba o retransmisję segmentu danych jest zupełnie nieprzydatna w aplikacjach działajacych w czasie rzeczywistym. 

Został zaprojektowany tak aby jego implementacja była możliwie najprostsza. Nie zapewnia kontroli dostarczenia datagramu ani nie sprawdza czy nie wystąpiły błędy transmisji. 

W modelu TCP/IP UDP zapewnia bardzo prosty interfejs pomiędzy siecią leżącą poniżej a aplikacją z wyższych warstw. UDP nie gwarantuje dostarczenia wiadomości i wysłający UDP nie zachowuje stanu wiadomości UDP już wysłanych do sieci (i z tego powodu czasem skrót UDP jest rozwijany do "Unreliable Datagram Protocol".) UDP umożliwia tylko multipleksowanie i sprawdzanie sum kontrolnych na szczycie datagramu IP. 

Nagłówek UDP zawiera tylko 4 pola, z czego dwa są opcjonalne: porty źródłowy i przeznaczenia są 16 bitowymi polami, które identyfikują proces wysyłający i odbierający. Ponieważ UDP jest bezstanowe i wysyłający UDP może nie zwracać odpowiedzi port źródłowy jest opcjonalny (jeśli nie jest ustawiony powinien być ustawiony na zero). 
Po polach portów są pole o określonej długości określone jako bajty datagramu UDP zawierające dane, minimalna wartość długości pola jest 8 (oktetów). Pozostałe pole nagłówka jest 16 bitową sumą kontrolną obejmującą nagłówek i dane, która również jest opcjonalna, ale prawie zawsze używana. 

Ponieważ nie zapewniające wiarygodności transmisji aplikacje UDP muszą pogodzić się z pewną ilością utraconych, zduplikowanych i błędnych pakietów, niektóre aplikacje takie jak TFTP mogą dodać jakieś podstawowe mechanizmy wiarygodności w warstwie aplikacji jeśli jest to potrzebne. Ale najcześciej aplikacje UDP nie tylko nie wymagają mechanizmu wiarygodności, ale takie mechanizmy by im przeszkadzały. Media strumieniowe, wielosobowe gry czasu rzeczywistego i VoIP są przykładami takich aplikacji, które często używają UDP. 

Brak unikania przeciążenia i mechanizmów kontroli powoduje, że konieczne są oparte na sieci mechanizmy, które by zapobiegły przeciążeniu sieci przez niekontrolowany napływ pakietów UDP. Ponieważ wysyłający UDP nie jest w stanie wykryć przeciążenia potrzebne są oparte na sieci elementy takie jak rutery używające kolejkowanie pakietów i techniki porzucania, które będą czasem jedynym narzędziem które zmniejszy ruch UDP. 
DCCP (Datagram Congestion Control Protocol) jest zaprojektowany jako częściowe rozwiązanie tego potencjalnego problemu poprzez dodanie kontroli przeciążenia końcowego hosta dla szybkich strumieni UDP takich jak media strumieniowe. 

Chociaż całkowita ilość ruchu UDP w przeciętnej sieci nie przekracza kilku procent - tego protokołu używa duża liczba aplikacji: DNS, SNMP (simple network management protocol), DHCP, RIP (Routing Information Protocol). 

### Warstwa internetowa (IP i ICMP)

#### IP (Internet Protocol)

IP jest zorientowanym na dane protokołem używanym do przesyłania danych pomiędzy hostem źródłowym a przeznaczenia poprzez sieć pakietów kumutowanych (_packet-switched internetwork_). 
Dane w międzysieci IP są wysyłane w blokach nazywanych pakietami lub datagramami (te terminy są w zasadzie synonimami w IP). 

IP zapewnia usługi datagramu bez wiarygodności (nazwane czasem "_best effort_", czyli najlepszych starań) tzn. nie daje gwarancji co do pakietów, które mogą dotrzeć zniszczone, w zmienionym porządku, zduplikowane lub całkiem porzucone. Jeśli więc aplikacja wymaga wiarygodności musi go zapewnić innymi sposobami. 

Przełączniki pakietów lub międzysieciowe rutery przekazują datagramy IP poprzez dwie połączone sieci. Brak mechanizmów zapewniających gwarancjię dostarczenia, powoduje, że ten mechanizm jest prosty. Choć jeśli sieć porzuca, zmienia porządek lub w jakiś inny sposób psuje dużą ilość pakietów, efekt otrzymany przez użytkownika będzie kiepski. 

IP jest powszechnym elementem sieci, obecnie najpopularniejszym protokołem warstwy sieci jest IPv4, którego adresy się kończą i nastąpi zmiana na IPv6. Wersje 0 do 3 były zarezerwowane lub nieużywane, wersja 5 była używana dla ekperymentalnego protokołu strumieniowego. Inne numery zostały przydzielone zwykle dla eksperymentalnych protokołów ale nie były zeroko stosowane. 

Adresowanie i rutowanie jest prawdopodobnie najbardziej złożonym aspektem IP. 
Adresowanie odnosi się do tego jak końcowym hostom przydziela się adresy IP i jak podsieci adresów IP są podzielone i grupowane razem. 
Ruting IP jest wykonywany przez wszystkie hosty, ale najważniejszy przez rutery międzysieciowe, które zwykle używają IGPs (_interior gateway protocols_) lub EGPs (_external gateway protocols_), umożliwiających przekazywanie pakietów przez połączone sieci. 

Protokół IP pracuje w warstwie 2 modelu DoD, ale jego funkcjonalność odpowiada warstwie 3 modelu OSI. Przynależność do tej warstwy sprawia, że jest bezpołączeniowy, nie jest w stanie rozpoznać, które pakiety powinny zostać retransmitowane w przypadku wystąpienia błędu, ani nie zajmuje się ustawieniem pakietów w kolejności. 

#### IPv4

Aktualnie obowiązującą wersją IP jest IPv4. Zawsze kiedy mowa o tym protokole bez uwzględnienia wersji chodzi właśnie o IPv4. Opisany jest w IETF RFC 791, opublikowanym we wrześniu 1981. IPv4 był pierwszą szeroko stosowaną wersją tego protokołu i tworzy większość współczesnego internetu. 
Obecnie używany protokół IP wykorzystuje 32 bitowy achemat adresowania, który umożliwia identyfikację sieci i urządzeń do niej podłączonych. 

Ponieważ ilość dostępnych adresów IPv4 jest na wyczerpaniu zostanie zamieniony na następną wersje, którą jest - zachowującą wsteczną kompatybilność - IPv6. Znacznie zwiększa możliwości adresowania i jest gotowa do wdrożenia, jednak przez najbliższe lata IP będzie oznaczało po prostu IPv4. 

Adresowanie:
W wersji 4 adres IP ma 32 bity co teoretycznie daje ponad 4 miliardy (4,294,967,296) unikalnych hostów. Jednak w praktyce przestrzeń adresowa jest znacznie mniejsza stąd więc rosnąca potrzeba zmiany na IPv6. Wiele z adresów jest zarezerwowanych do specjalnych celów takich jak sieci lokalne lub adresy multicastowe. 
Adres IP jest najczęście wyrażony w postaci "kropkowo dziesiętnej" (_dotted decimal_): cztery oktety podzielone przez kropki. Np. host znany jako wikipedia.org ma w rzeczywistości numer 3482223596, zapisany jako 207.142.131.236: 3482223596 równa się 207x2563 \+ 142x2562 \+ 131x2561 \+ 236x2560. 

Rozwiązanie nazwy domenowej np. "www.isoc.org.pl" do właściwego numeru IP jest zadaniem, które wykonuje DNS. 

Historycznie adresy IP miały tylko dwie części, późniejsze zmiany zmieniły to na trzy części: sieć, podsieć i hosta, jednakże powszechne zastosowanie CIDR zmieniło ten stan rzeczy i adres może mieć dowolną liczbę poziomów hierarchii Technicznie to było zawsze możliwe z pojawieniem się podsieci, ponieważ witryna mogła zawierać więcej niż jedną warstwę podsieci. 

Sposoby zapisu: adresy IPv4 są zapisywane w formacie:

- Kropkowo dziesiętnym (_Dotted Decimal_) - najczęściej używany

207.142.131.235

- Kropkowo heksadecymalny (_Dotted Hexadecimal_):

0xCF.0x8E.0x83.0xEB

- Kropkowo oktalny (_Dotted Octal_)

0317.0216.0203.0353

- dziesiętny (_Decimal_):

3482223595

- heksadecymalny (_Hexadecimal_)

0xCF8E83EB


Powyższe adresy działają w większości przeglądarek i wskazują na wikipedia.org. 

Fragmentacja i powtórne złożenie. 
IPv4 umożliwia zastosowanie elementów sieci (np. łączy punkt-punkt) używających pakietów o małych rozmiarach. Zatosowanie fragmentacji i złożenia na lokalnym łączu wymagałoby od rutera na drugim końcu zebrania oddzielnych kawałków i złożenia pakietu (skomplikowany proces szczególnie jeśli pakiety się gubiły by na skutek błędów na łączu). 
Ruter, który wykrywa, że pakiet jest za duży by zmieścić się na następnym łączu i pozwala na podzielenie go na fragmenty (oddzielne pakiety IPv4, z których każdy będzie zawierał część danych oryginalnego pakietu IPv4) dzieli go przy użyciu standardowych procedur, które pozwalają hostowi docelowemu złożyć pakiet z fragmentów, po tym jak je oddzielnie odebrał. 
Kiedy duży pakiet IPv4 jest podzielony na mniejsze (co zwykle, ale nie zawsze ma miejsce na ruterze gdzieś na drodze do przeznaczenia), to wszystkie fragmenty są normalnymi pakietami IPv4, np. mają pełen nagłówek IPv4. Porcja danych oryginalnego pakietu jest podzielona na mniejsze, które są dość małe (łącznie z nagłówkiem) by przejść do następnego łącza i w każdym fragmencie znajduje się jeden segment oryginalnych danych. Prawie wszystkie pola nagłówka mają takie same wartości jak w oryginalnym pakiecie, a w szczególności mają identyczną wartość pola identyfikacji. 
Różnice:

- pole całkowitej długości będzie mniejsze, bo dostosowane do rozmiaru każdego z fragmentów
- flaga pojedynczego bitu "more fragment" będzie ustawiona na 1 za wyjątkiem ostatniego fragmentu
- pole "fragment offset" będzie niezerowe we wszystkich oprócz pierwszego fragmentu

Czyli pakiet jest sfragmentowany jeśli w miejscu przeznaczenia w którymś z przychodzących pakietów:

- flaga pojedynczego bitu "more fragments" jest ustawiona jeden
- lub pole "fragment offset" jest niezerowe

Żeby złożyć fragmenty z powrotem w oryginalny pakiet w miejscu przeznaczenia, host szuka przychodzących pakietów z tą samą wartością pola identyfikacji, wszystkie należą do tego samego oryginalnego pakietu. Pola offsetu i całkowitej długości wskazują gdzie jest miejsce każdej części oraz jaką cześć oryginalnego pakietu zawiera. 
Może to funkcjonować niezależnie od całkowitej wielkości oryginalnego pakietu. Dla pakietu z czystą flagą "more fragments", wartość pola wielkości w tym pakiecie plus wartość pola offsetu daje całkowitą długość oryginalnego pakietu. 

Ruter może powtarzać proces fragmentacji, nawet jeśli ma pojedynczy fragment (np. ostatni ruter po drodze) - dzieli go w taki sam sposób dzieląc na dwa lub więcej nowych fragmentów i dodając właściwe pola offsetu i całkowitej długości. Jedyną komplikacją jest jeśli flaga "more fragments" jest ustawiona na zero, potrzebuje je ustawić na jeden za wyjątkiem ostatniego fragmentu (jest to względnie proste ustawić proces tak, żeby ruter nie potrzebował wiedzieć czy dzieli oryginalny pakiet czy już fragment)

Jeśli pakiet jest sfragmentowany i niektóre z fragmentów zostały stracone, wtedy w całości jest retransmitowany z tym samym numerem identyfikacyjnym i ta druga kopia również jest fragmentowana (z możliwością utraty niektórych fragmentów). Wtedy fragmenty z drugiej kopii mogą zostać użyte do wypełnienia dziur w pierwszym. 

Rzeczywisty przydział pakietów nie jest arbitralny, organizacja - zazwyczaj ISP - żąda przydzielenie bloku numerów z rejestru takiego jak np. American Registry for Internet Numbers (ARIN). Numer sieci zawiera zasięg adresów, które organizacja ma do dyspozycji i jeśli wyczerpie znaczącą ilość przestrzeni adresowej, może zażądać następnego bloku numerów. 
Na przykład ARIN alokował adresy 64.78.200.0 do 64.78.207.255 dla Verado, Inc. Verado alokowało adresy 64.78.205.0 do 64.78.205.15 dla Bomis. Bomis przydzielił konkretny adres 64.78.205.6 dla interfejsu hosta nazwanego www.wikipedia.com. 

Na styczeń 2005, niektóre duże bloki przydziału zawierają:
Klasa A

- [Organization] [Block]
- Internet Assigned Numbers Authority 0.0.0.0 - 2.255.255.255
- General Electric 3.0.0.0 - 3.255.255.255
- Level 3 Communications 4.0.0.0 - 4.255.255.255
- Internet Assigned Numbers Authority 5.0.0.0 - 5.255.255.255
- Department of Defense Network Information Center 6.0.0.0 - 7.255.255.255
- Level 3 Communications 8.0.0.0 - 8.255.255.255
- IBM 9.0.0.0 - 9.255.255.255
- Internet Assigned Numbers Authority 10.0.0.0 - 10.255.255.255
- Department of Defense Network Information Center 11.0.0.0 - 11.255.255.255
- AT&T WorldNet Services 12.0.0.0 - 12.255.255.255
- Xerox Palo Alto Research Center 13.0.0.0 - 13.255.255.255
- Internet Assigned Numbers Authority 14.0.0.0 - 14.255.255.255
- Hewlett-Packard Company 15.0.0.0 - 15.255.255.255
- Digital Equipment Corporation 16.0.0.0 - 16.255.255.255
- Apple Computer, Inc. 17.0.0.0 - 17.255.255.255
- Massachusetts Institute of Technology 18.0.0.0 - 18.255.255.255
- Ford Motor Company 19.0.0.0 - 19.255.255.255
- Computer Sciences Corporation 20.0.0.0 - 20.255.255.255
- Department of Defense Network Information Center 21.0.0.0 - 22.255.255.255
- Internet Assigned Numbers Authority 23.0.0.0 - 23.255.255.255
- Various U.S. Cable Networks 24.0.0.0 - 24.255.255.255
- Royal Signals and Radar Establishment 25.0.0.0 - 25.255.255.255
- Department of Defense Network Information Center 26.0.0.0 - 26.255.255.255
- Internet Assigned Numbers Authority 27.0.0.0 - 27.255.255.255
- Department of Defense Network Information Center 28.0.0.0 - 30.255.255.255
- Internet Assigned Numbers Authority 31.0.0.0 - 31.255.255.255
- AT&T Global Network Services 32.0.0.0 - 32.255.255.255
- Department of Defense Network Information Center 33.0.0.0 - 33.255.255.255
- Halliburton Company 34.0.0.0 - 34.255.255.255
- Merit Network, Inc. 35.0.0.0 - 35.255.255.255
- Internet Assigned Numbers Authority 36.0.0.0 - 37.255.255.255
- Performance Systems International, Inc. 38.0.0.0 - 38.255.255.255
- Internet Assigned Numbers Authority 39.0.0.0 - 39.255.255.255
- Eli Lilly and Company 40.0.0.0 - 40.255.255.255
- Internet Assigned Numbers Authority 41.0.0.0 - 42.255.255.255
- Japan Inet 43.0.0.0 - 43.255.255.255
- Amateur Radio Digital Communications 44.0.0.0 - 44.255.255.255
- Interop Show Network 45.0.0.0 - 45.255.255.255
- Internet Assigned Numbers Authority 46.0.0.0 - 46.255.255.255
- Bell-Northern Research 47.0.0.0 - 47.255.255.255
- Prudential Securities Inc. 48.0.0.0 - 48.255.255.255
- Internet Assigned Numbers Authority 49.0.0.0 - 50.255.255.255
- Department of Social Security of UK 51.0.0.0 - 51.255.255.255
- E.I. DuPont de Nemours and Co., Inc. 52.0.0.0 - 52.255.255.255
- Cap debis ccs (Mercedes-Benz) 53.0.0.0 - 53.255.255.255
- Merck and Co., Inc. 54.0.0.0 - 54.255.255.255
- Department of Defense Network Information Center 55.0.0.0 - 55.255.255.255
- United States Postal Service 56.0.0.0 - 56.255.255.255
- SITA - Société Internationale De Telecommunications Aeronautiques 57.0.0.0 - 57.255.255.255
- Asia-Pacific Network Information Centre (APNIC) 58.0.0.0 - 61.255.255.255
- RIPE Network Coordination Centre 62.0.0.0 - 62.255.255.255
- UUNet Technologies, Inc. 63.0.0.0 - 63.127.255.255
- Internet Assigned Numbers Authority 73.0.0.0 - 79.255.255.255
- RIPE Network Coordination Centre 80.0.0.0 - 80.255.255.255

Część prywatnej przestrzeni adresowej została alokowana w RFC 1918, oznacza to, że te adresy są dostępne dla każdego użytku przez wszystkich więc te adresu mogą być powtórnie użyte. Jednakże nie są one rutowalne w internecie. Są uzywane intensywnie z powodu braku rejestrowalnych adresów., żeby połaczyć takie sieci z internetem wymagany jest NAT. 
Pomimo pewnych działań mających zaoszczędzić istniejącą przestrzeń adresową IPv4 (takich jak NAT i DHCP) liczba 32-bitowych adresów IP nie jest wystarczająca by zapewnić wzrost internetu na dłuższą metę, z tego powodu 128 bitowe adresowanie IPv6 zostanie zastosowane w przeciągu najbliższych 5 do 15 lat. 

#### IPv6

W latach 90-tych opracowano następną wersję IP, która ma zapobiec wyczerpaniu się dostępnej puli adresów IP. 
Różne techniki oszczędzania adresów jak maski podsieci o zmiennej długości (VLSM) lub tłumaczenie adresów za pomocą NAT są rozwiązaniem krótkotrwałym. 
Początkowa nazwa - zanim został wybrany w procesie selekcji IETF - IP Next Generation (IPng). 

IPv6 jest drugą wersją IP jaka będzie powszechnie stosowana (było IPv5 ale nie był to następca IPv4 a raczej eksperymentalny zorientowany na przepływ protokół streamingu multimediów)
Chociaż został adoptowany przez IETF jako następca IPv4 jeszcze w 1994 nadal nie ma więcej niż kilka procent internetu. 

Powodem dla utworzenia IPv6 był brak przestrzeni adresowej, szczególnie w zaludnionych krajach Azji takich jak Indie i Chiny. 
Problem ten częściowo jest rozwiązywany przez NAT, ale sprawia to problemy techniczne, lub w ogóle uniemożliwia działanie takich aplikacji jak VoIP i niektórych gier wielosobowych. 
Istotną przyczyną dla zastosowania IPv6 są nowe możliwości takie jak mobilność, jakość usług, rozszerzenia prywatności itd. 
IPv4 będzie wspierane nadal do 2025, żeby dać czas na naprawę błędów nowego systemu. 

Celem IPv6 jest zastąpienie poprzedniego standardu, IPv4, który ma do około 4 miliardów (4 x 109) adresów, podczas kiedy IPv6 ma ich 2128 inaczej mówiąc 3.4 x 1038 (34 [undecyliony](http://pl.wikipedia.org/wiki/Undecylion)), co jest odpowiednikiem:

- 4.3 x 1020 (430 kwintylionów) na cal kwadratowy powierzchni Ziemi
- 6.7 x 1017 (670 kwadrylionów) na milimetr kwadratowy powierzchni Ziemi

Tą ilość można wyrazić takim porównaniem: jeśli Ziemia zrobiona by była w całości z ziarenek piasku wielkości jednego milimetra sześciennego, można by dać unikalny adres każdemu ziarenku dla 300 milionów planet wielkości Ziemi. 

Adresy IPv6 są złożone z dwóch logicznych części:

- 64-bitowy prefix sieci
- 64-bitowa część adresu hosta, która często jest generowana automatycznie z adresu MAC interfejsu

Czasem argumentuje się, że 128-bitów to za dużo i internet nigdy nie będzie potrzebował tak dużej ilości. Główną przyczyną dla takiej długości nie jest wcale upewnienie się, że adresów nigdy nie zabraknie, ale raczej zapewnienie łatwości przeprowadzenia rutingu dzięki utrzymaniu części adresowej sieci niezfragmentowanej. Taka fragmentacja jest częsta w IPv4, gdzie duża ilość segmentów adresowych może być i często jest przydzielana dla jednej organizacji. 

Adresy IPv6 mają 128 bitów długości, wyrażonych w postaciu ośmiu wartości 16-bitowych, oddzielonych dwukropkami i zapisanych w notacji szesnastkowej (heksadecymalnej), na przykład:

```
1111:2222:3333:4444:5555:6666:7777:8888
```

Każda wartość jest liczona od 0x0 do 0xFFF (dziesiętnie od 0 do 65 535). Granica części hostowej została ustalona po 64 bitach. 
Przyjęto zasadę, że można usunąc zera rozpoczynające każdy segment

Zapisany jest jako osiem 4-cyfrowych (16-bitów) heksadecymalnych liczb oddzielonych dwukropkiem, nieprzerwany ciąg zer może zostać pominięty więć 1080::800:0:417A jest tym samym co 1080:0:0:0:0:800:0:417A. 

- zwykle są zapisywane jako osiem grup po cztery heksadecymalne cyfry, np.: 2001:0db8:85a3:08d3:1319:8a2e:0370:7334 jest poprawnym adresem IPv6
- jeśli czterocyfrową grupą jest 0000 może zostać pominięte, np: 2001:0db8:85a3:0000:1319:8a2e:0370:7344 jest tym samym adresem co: 2001:0db8:85a3::1319:8a2e:0370:7344
- zgodnie z tą regułą jeśli dwa kolejne dwukropki wynikają z takiego ominięcia mogą być zredukowane do dwóch dwukropków, tak długo jak jest to tylko jedna grupa sąsiadujacych dwukropków, tak więc
```
2001:0DB8:0000:0000:0000:0000:1428:57ab
2001:0DB8:0000:0000:0000::1428:57ab
2001:0DB8:0:0:0:0:1428:57ab
2001:0DB8:0::0:1428:57ab
2001:0DB8::1428:57ab
```
są poprawnymi adresami, w przeciwieństwie do: 2001::25de::cade który jest nieprawidłowy bo nie wiadomo jak duża ilość grup 0000 jest po każdej stronie
- zera z przodu mogą zostać pominięte, więc: 2001:0DB8:02de::0e13 jest tym samym co 2001:DB8:2de::e13
- jeśli jest to przebrany adres IPv4 ostatnie 32 bity mogą zostać zapisane dziesiętnie, więc: ::ffff:192.168.89.9 jest tym samym co: ::ffff:c0a8:5909 ale nie tym samym co: ::192.168.89.9 lub ::c0a8:5909
- mapowany adres IPv4 ::ffff:1.2.3.4

format 1.2.3.4 jest kompatybilny z IPv4

Adresy IPv4 są łatwe do konwersji na format IPv6, np. jeśli dziesiętny adres IPv4 to 135.75.43.52 (heksadecymalnie 0x874B2B34) może być konwertowany na 0000:0000:0000:0000:0000:0000:874B:2B34 lub ::874B:2B34. 
I znowu: możliwa jest hybrydowa notacja, w której ten adres to ::135.75.43.52. 
Te kompatybilne z IPv4 adresy mają status _deprecated_ ponieważ przejściowe mechanizmy IPv6 już ich nie używają. 

Segmenty adresowe są określone jak w nowoczesnej alternatywie dla IPv4: numer sieci potem slasz i liczba właściwych bitów w numerze sieci (w formie dziesiętnej). 
Przykład: 12AB::CD30:0:0:0:0/60 zawiera wszystkie adresy zaczynające się od 12AB00000000CD3. 

Adresy specjalne:
Istnieje pewna liczba adresów, które mają specjalne znaczenie w IPv6 oto krótka lista w notacji CIDR.

- ::/128 - adres składający się z samych zer używany jest by określić jakikolwiek adres i używany jest wyłącznie w oprogramowaniu.
- ::1/128 - adres pętli zwrotnej - jest to lokalny adres hosta, który odnosi sie do niego samego, wszystkie wysłane tam pakiety wracają do niego (odpowiednik 127.0.0.1 z IPv4).
- ::/96 - kompatybilny z IPv4 adres używany w w mechanizmach przejściowych w sieciach IPv4/IPv6.
- ::ffff:0:0/96 - mapowany adres IPv4 (IPv4-mapped address) używany w mechanizmach przejściowych w hostach o podwójnym stosie.
- fe80::/10 - prefiks lokalnego łącza określający, że ten adres jest prawidłowy tylko w łaczu lokalnej sieci fizycznej.
- fec0::/10 - prefiks lokalnego łącza określający, że ten adres jest prawidłowy tylko w lokalnej organizacji. RFC 3879 (IX 2004) określa go jako _deprecated_ i przyszłe systemy nie muszą implementować jakiegokolwiek wsparcia dla tego typu specjalnych adresów.
- ff00::/8 - prefiks multicastu, używany w adresach multicastowych.

HMPTODO

| Bity | Nazwa | Przeznaczenie (przykład zastosowania) |
| --- | --- | --- |
| 1 - 3 | Przedrostek formatu (FP) | Typ adresu (pojedynczy, grupowy) |
| 4 - 16 | Identyfikator najwyższego poziomu agregacji (TLA ID)Top Levels Aggregators | Najważniejsze organizacje (główni ISP), operatorzy obsługujący podstawowy ruch w sieci, firmy telekomunikacyjne zapewniający funkcjonowanie szkieletowych, długodystansowych połaczeń sieciowych przez organizacje takie jak IANA |
| 17 - 24 | | Zarezerwowane |
| 25 - 48 | Identyfikator następnego poziomu agregacji (NLA ID)Next Level Aggregators | Organizacje regionalne (lokalni ISP), dla dużych dostawców usług, którzy rozdysponują SLA |
| 49 - 64 | Identyfikator witrynowego poziomu agregacji (SLA ID)Site Level Aggregators | Podziały dla konkretnych witryn (podsieci), odpowiedniki dzisiejszych klas adresowych, przydzielane są organizacjom, które samodzielnie obsługują własną komunikację internetową (uczelnie, instytuty, duże firmy) lub bezpośrednim dostawcom usług internetowych, które z kolei przydzielają swoim użytkownikom lub klientom 64-bitowe adresy hostów. |
| 65 - 128 | Identyfikator interfejsu | Adres konkretnego urządzenia: zmodyfikowany adres MAC |

Jak widać witryny mają 16 bitów na utworzenie podsieci. Cały początkowy przedrostek złożony z 48 bitów dostarczają usługodawcy internetowi (ISP). Jedną z zalet adresów IPv6 jest to, że adresy hostów można tworzyć automatycznie na podstawie adresu MAC urządzenia, co pozwoli (ewentualnie) wyeliminować potrzebę konfigurowania hosta. 
Obecnie tablice przekierowań ruterów mogą liczyć nawet kilkadziesiąt tysięcy wpisów, wprowadzenie modelu hierarchicznego spowoduje znaczące odciążenie - każdy ruter będzie tłumaczył tylko część adresu: rutery obsługujące ruch na poziomie TLA będą interpretowały tylko segment TLA całego adresu i skierują go do właściwego TLA, który skieruje go do właściwego NLA (nie interpretując już TLA), który prześle go do określonego w segmencie SLA lokalnego dostawcy usług. 
Taki sposób organizacji ruchu pakietów pozwala by każdy ruter znał tylko swoje bezpośrednie otoczenie: ruter struktury nadrzędnej i podlegające mu urządzenia struktur niższego rzędu. 

Pakiet IPv6 złożony jest z dwóch części:

- nagłówek (_header_) - pierwsze 40 bajtów pakietu zawiera zarówno adres przeznaczenia i źródła (każdy 128 bitów), również wersję IP (4 bity), klasę ruchu (_traffic class_ - 8 bitów Pacet Priority), wskaźnik przepływu (_flow label_ - 20 bitów, _QoS management_), długość ładunku (16 bitów) i limit skoków (_hops limit_) (8 bitów TTL)
- ładunek (_payload_) - do 64 K w normalnym rozmiarze lub większy z opcją "jumbo payload".

Istnieją dwie trochę odmienne wersje IPv6, obecnie _obsolete_ początkowa wersja opisana w RFC 1883 różniąca się od obecnej proponowanej wersji standardu opisanej w RFC 2460 w dwóch polach: 4 bity zostały przyznane z _flow label_ do _traffic class_, wszystkie inne róznice są drugorzędne. 
Fragmentacja jest przeprowadzana tylko przez hosta. 

W IPv6 również opcje zostały wyrzucone ze standardowego nagłówka i są określone przez pole Next Header - analogiczne z funkcją pola Protokołu z IPv4. 
Przykład: w IPv4 można dodać opcję SSRR (Strict Source and Record Routing) co wymusi konkretną drogę dla pakietu, ale w IPv6 można utworzyć pole Next Header, które będzie wskazywało, że nagłówek rutingu (Routing header) jest następny, wtedy nagłówek rutingu powinien wtedy określić dodatkową informację do pakietu i wskazać, że np. następny jest nagłowek TCP. 
Jest to analogiczne do AH i ESP w IPSec dla IPv4 (które stosuje się również do IPv6). 

IPv6 i DNS. 
Adresy IPv6 są reprezentowane w DNS przez rekordy AAAA (tzw. quad-A) (przez analogię do rekordów A dla IPv4). Zapytania odwrotne (_reversed lookups_) mają miejsce w ip6.arpa (poprzednio ip6.int).Ten schemat jest zdefinowany w RFC 3596 i został uznany za standard w RFC 3363 (sierpień 2002)

Schemat IPv6 pozwoli zachować zgodność z modelem IPv4, przypisując adresy postaci 0:0:0:FFFF:a.b.c.d urządzeniom, które nie obsługują IPv6, gdzie a.b.c.d jest adresem IPv4. Takie adresy zapisuje się jako ::FFFF:a.b.c.d gdzie :: zastępuje ciągły blok zer (dowolnej długości) w adresie IPv6 (ale podwójny dwukropek może wystąpić tylko raz). 
Adres pętli zwrotnej jest zawsze zdefiniowany jako ::1, a adres rozgłoszeniowy - jako FF02::1. 

Kompatybilność jest zapewniona w obie strony:

- adres IPv4 zapisywany jest na ostatnich 32 bitach adresu typu unicast a reszta wypełniana jest zerami
- w drugą stronę stosuje się tzw. tunelowanie - pakiet IPv6 jest pakowany do postaci pakietu IPv4 (enkapsulacja) przesyłany do odbiorcy za pośrednictwem sieci zgodnej w IPv4 i przekształcany z powrotem na IPv6 (dekapsulacja).

Mechanizmy tunelowania oraz szyfrowania przesyłanych danych, oprócz zapewnienia komunikacji pomiędzy sieciami pracującymi w w różnych wersjach protokołu ułatwiają również zestawienie VPN czyli bezpośrednich łącz komunikacyjnych przy wykorzystaniu sieci publicznej. 

Ważne dokumenty: RFC 791, RFC 1519 (adresy IPv4), RFC 2373 (adresy IPv6). 

Ponadto IPv6 zawiera dodatkowe informacje sterujące, posiada elastyczny format nagłówka i zapewnia przyszły rozwój (rozszerzalność) protokołu oraz wspiera rezerwowanie zasobów (QoS). 
Towarzyszy mu cały zestaw protokołów zabezpieczających IPSec zapewniających potwierdzenie tożsamości nadawcy i odbiorcy pakietu oraz szyfrowanie przesyłanych danych. IPSec działa niezależnie od aplikacji funkcjonujących w wyższych warstwach, więc nie zastępuje stosowanych w nich zabezpieczeń, a tylko je uzupełnia zabezpieczając przed próbami podszywania się pod innego nadawcę czy zmiany zawartości przesyłanego pakietu. 

Trzy typy adresów:

- unicast - odpowiada point-to-point czyli o jednoznacznie zdefiniowanym odbiorcy, w celu ułatwienia organizacji ruchu pakietów w sieci lokalnej zdefiniowano dwa dodatkowe typy adresów unicastowych; rutery pośredniczące w komunikacji z resztą internetu nie będą tak adresowanych pakietów przesyłać dalej
  - segmentowy (LLUA link local unicast address) - ograniczony do określonego fagmentu intranetu
  - ośrodka (SLUA site local unicast address) ograniczony do wewnętrznej sieci firmy
- multicast odpowiednik typu broadcast z IPv4, określa wielu odbiorców jednego pakietu
  - czasowe (transient) - definiuje się pod kątem konkretnego zastosowania, np. w celu zestawienie telekonferencji
  - trwałe (permament) - funkcjonalne typy odbiorców, np. serwery prowadzące mirror danego serwisu muzycznego
- anycast - pakiety adresowane sa do grupy odbiorców, ale ich transmisja kończy się gdy dowolny z nich dotrze na miejsce przeznaczenia, mogą być używane tylko przez rutery, więc ich najpowszechniejszym zastosowaniem bedzie rozsyłanie zapytań w celu określenia najszybszej dostępnej ścieżki transmisji danych.

Dwa mechanizmy automatycznej konfiguracji i przydzielania adresów IP:

- autokonfiguracja z uwzględnieniem stanu (_stateful autoconfiguration_) analogiczny do DHCP host otrzymuje z serwera adres IP ze zdefiniowanej uprzednio puli wraz z informacją o dmyślnym ruterze i adresie serwera nazw
- autokonfiguracja bez uwzględnienia stanu (_stateless autoconfiguration_) - na podstawie numeru MAC host konstruuje 64-bitowy identyfikator hosta (LLUA Link Local Unicast Address) po czym rozsyła do ruterów SLA tzw. zapytanie konfiguracyjne (_router solicitation_) w odpowiedzi otrzymuje prefiks adresu zawierający pozostałe segmenty po czym automatycznie konfiguruje adres IP przez dodanie utworzonego ID do otrzymanego prefiksu. W tej technice, żeby zmienić adresy wszystkich hostów wystarczy tylko zdefiniować na ruterze nowy prefiksu, a ruter sam go roześle do obsługiwanych hostów.

[6bone.net](http://www.6bone.net/) - zamknięty 6 VI 2006

#### ICMP (Internet Control Message Protocol)

ICMP jest częscią zestawu protokołów internetowych jak to zostało zdefiniowane w RFC 792. Wiadomości ICMP są zwykle generowane w odpowiedzi na błędy w datagramach IP (jak to określono w RFC 1122) lub dla celów diagnostycznych lub rutingu. 
Wersja dla IPv4 jest znana jako ICMPv4 ponieważ jest to część IPv4. IPv6 ma analogiczny protokół. 

Urządzenia łączące sieci (_gateways_) komunikują się ze sobą przy użyciu protokołu GGP (_Gateway-to-Gateway Protocol_), ale do połączeń gatewaya z hostem używany jest ICMP.

Używa IP jako warstwy usługowej podobnie jak TCP i UDP, ale zwykle przedstawia się go na tym samym poziomie co IP, bo traktowany jest jako integralna część modułu IP w oprogramowaniu karty sieciowej i każdy moduł musi obsługę tego protokołu zawierać. 
Wiadomości ICMP mogą być wysyłane w kilku różnych sytuacjach - błędach zachodzących w sieci: jeśli datagram nie może dotrzeć do hosta docelowego, w gatewayu brak miejsc na buforowanie datagramów, lub kiedy gateway może skierować ruch na krótszą i mniej obciążoną trasę. 

Wiadomości ICMP są opakowane w nagłówek IP (więc używają warstwy IP), wiadomość znajduje się w części danych datagramu IP. Zwykle powstaje z normalnego datagramu IP, który wygenerował odpowiedź ICMP. 
IP kapsułkuje odpowiednią wiadomość ICMP z nowym nagłowkiem IP (żeby otrzymać odpowiedź ICMP do wysyłającego hosta) i wysyła otrzymany datagram w zwykły sposób. 
Dla przykladu: każda maszyna (np. pośredniczące rutery), która przekazuje datagramy IP musi obniżyć TTL w nagłówku IP o jeden, jeśli TTL sięga 0 wiadomość ICMP "Time to live exceeded in transit" jest wysyłana do źródła datagramu. 

Każda wiadomość ICMP jest kapsułkowana dokładnie w pojedynczym datagramie IP i podobnie jak UDP ICMP nie gwarantuje dostarczenia. 

Chociaż wiadomości ICMP są zawarte w datagramie IP, są przetwarzane jako specjalny przypadek w odróżnieniu od reszty ruchu IP, a nie są traktowane jak po prostu pod-protokół IP. W wielu przypadkach niezbędne jest skontrolowanie zawartości wiadomości ICMP i dostarczenie właściwej wiadomości błędu do aplikacji, która wygenerowała błędny pakiet, który spowodował wysłanie wiadomości ICMP

Wiele popularnych narzędzi jest bazowanych na wiadomościach ICMP. 
Polecenie traceroute jest zaimplementowane przez wysłanie datagramów ze specjalnie ustawionym polem TTL i wyczekiwaniem na wiadomości ICMP "Time to live exceeded in transit" i "Destination unreachable" generowane w odpowiedzi. 
Również ping jest zaimplementowany przez użycie wiadomości ICMP "Echo" i "Echo reply". 

Lista dozwolonych wiadomości kontrolnych (niekompletna):

- 0 - Echo Reply
- 1 - Reserved
- 2 - Reserved
- 3 - Destination Unreachable
- 4 - Source Quench
- 5 - Redirect Message
- 6 - Alternate Host Address
- 7 - Reserved
- 8 - Echo Request
- 9 - Router Advertisement
- 10 - Router Solicitation
- 11 - Time Exceeded
- 12 - Parameter Problem
- 13 - Timestamp
- 14 - Timestamp Reply
- 15 - Information Request
- 16 - Information Reply
- 17 - Address Mask Request
- 18 - Address Mask Reply
- 19 - Reserved for security
- 20-29 - Reserved for robustness experiment
- 30 - Traceroute
- 31 - Datagram Conversion Error
- 32 - Mobile Host Redirect
- 33 - IPv6 Where-Are-You
- 34 - IPv6 Here-I-Am
- 35 - Mobile Registration Request
- 36 - Mobile Registration Reply
- 37 - Domain Name Request
- 38 - Domain Name Reply
- 39 - SKIP Algorithm Discovery Protocol
- 40 - Photuris, Security failures
- 41-255 - Reserved

### Warstwa dostępu do sieci (ARP)

#### ARP (Address Resolution Protocol)

MAC - sprzętowy adres karty sieciowej zaszyty na stałe. Identyfkuje konkretne urządzenie a nie jak adres IP interfejs sieciowy. Składa się z dwóch części: 6 liczb poprzedzielanych dwukropkiem, gdzie pierwsze cztery identyfikują producenta, pozostałe są unikalnym numerem urządzenia. Nie mogą się pojawić dwie karty o tym samym adresie MAC - zapewniają to odpowiednie regulacje organizacyjne. 
Rzecz w tym, że jeśli w jednej sieci lokalnej znajdą się dwie lub więcej kart o tym samym numerze MAC komunikacja jest niemożliwa. Tylko karta sieciowa ma swój numer MAC, bo ma więcej niż jeden koniec. W modemie nie ma takiej potrzeby. 

Wygląda na przykład tak:

```
H6:ef:45:sf:3g:68
```

ARP jest metodą na znalezienie adresu sprzętowego (MAC) hosta z jego adresu IP. Wysyłający nadaje pakiet ARP zawierający internetowy adres innego hosta i oczekuje na odpowiedź w postaci adresu ethernetowego. Każdy host przechowuje w buforze tłumaczenia adresów co zmniejsza obciążenie sieci. ARP pozwalają być adresom IP niezależnym od adresów ethernetowych ale może działać tylko kiedy wszystkie hosty go wspierają. 
ARP jest zdefiniowany w RFC 826. 
Alternatywą dla hostów, które nie wspierają ARP jest użycie prekonfigurowanego mapowania adresów IP na adresy MAC. 

Warianty protokołu ARP:
ARP może być użyty do tłumaczenia (rozwiązywania, _resolve_) adresów MAC na wiele różnych protokołów warstwy trzeciej. ARP został również zaadoptowany do tłumaczenia innych rodzajów adresów warstwy drugiej, np. ATMARP jest używany do tłumaczenia adresów ATM NSAP na IP poprzez protokół ATM. 

Miejscem styku ze sprzętem jest warstwa łącza danych, która podzielona jest na dwie podwarstwy: górną LLC i dolną MAC. 
Zasadnicze znaczenie ma MAC, odpowiada ona za takie przygotowanie odebranego z warstwy sieciowej pakietu IP, aby nadawał się do transmisji w sieci o określonej topologii. Sieci lokalne wykonane są zwykle w standardzie Ethernet o topologii magistrali, ale istnieją inne rozwiązania, każde z nich ma własne interfejsy, kable, sygnalizacje i szybkości transmisji wykorzystując jednocześnie najbardziej właściwe dla realizacji tego celu ramki. 
Ramka to odpowiednio sformatowana ilość informacji jaką można przesłać za jednym zamachem, a formatowanie polega na ogół na podziale pakietu IP na mniejsze części, zgodnie z wymogami standardu i opatrzenie każdej z nich nagłówkiem zawierającym m.in. adres docelowy i źródłowy. Ale nie IP tylko MAC. Informację o tym zbiera protokół ARP, który jest dla użytkownika zupełnie niewidoczny i nie wymaga żadnej konfiguracji. 
Działa w tle ogłaszając komunikaty, których celem jest odnalezienie właściwego adresata dla przesyłki, którą jest pakiet IP już podzielony na ramki i gotowy do wysyłki. 

Jeśli karta stwierdzi, że dany adres IP należy do tej samej podsieci, wysyła w sieć pytanie "jaki jest adres MAC komputera o danym adresie IP?". W polu adresu MAC takiej ramki są same jedynki, co określa wszystkie urządzenia podłączone do danego segmentu, więc przez wszystkie jest odbierany i przetwarzany. 

Adres rozgłoszeniowy fizyczny (ang. broadcast address):

hh:hh:hh:hh:hh:hh

a może?[?]

FF:FF:FF:FF:FF:FF

Taką ramkę (ARP-request) odbierają wszystkie karty w sieci lokalnej

- adres IP nadawcy
- adres fizyczny nadawcy
- adres IP odbiorcy
- adres fizyczny odbiorcy czyli w tym przypadku rozgłoszeniowy

Każdy komputer na poziomie warstwy 3 porównuje podany w zapytaniu adres IP z własnym i odpowiada tylko ten, który wykryje zgodność - wyśle wypełnione pola nadawcy, czyli swój adres IP i fizyczny. 
Ramka odpowiedzi (ARP-reply) zawierająca adres sprzętowy skierowana jest tylko do pytającego, gdyż podał on swój adres. 

Wtedy pytający wkłada ten adres do swoich ramek i je wysyła. 
Proces jest przyspieszany przez buforowanie w tzw. cache ARP, zawierającym tablicę ostatnio używanych odwzorowań pomiędzy adresami IP i MAC, jego zawartość uaktualniana jest dynamicznie bez ingerencji użytkownika, ale istnieje możliwość ręcznego wprowadzenia odwzorowań statycznych instrukcją:

```
arp
```

#### Zasady dostępu do medium transmisyjnego

Metoda określajaca kolejność nadawania przez dane medium (kabel lub eternet). 

- CMA/CD - najczęstszy w sieciach Ethernet tzw. wielodostęp z wykrywaniem zajętości kanału i detekcją kolizji, "kto pierwszy ten lepszy" opisana standardem IEEE 802.3; jeśli dochodzi do kolizji wszyscy przerywają nadawanie
- Token Ring - pierścień z dostępem do znacznika, każde urządzenie uzyskuje dostęp w sposób cykliczny, w sieci krąży tzw. znacznik (token) który otrzymuje każdy z kolei i wtedy może nadawać (standard IEEE 802.5); stosowana w sieciach o tej samej nazwie oraz FDDI
- Token Bus - magistrala z dostępem za pomocą znacznika; podobna do Token Ring z tym, że znacznik nie jest przekazywany cyklicznie a według numeracji stacji, która nie musi być zgodna z kolejnością ich włączenia do linii (zdefinowana w IEEE 802.4), obecnie raczej nie używana
- Request Priority (Priorytet na żądanie) - scentralizowana metoda sterowania dostępem do medium, istnieje jednostka zarządzająca, która stale odpytuje stacje na okoliczność chęci przeprowadzenia transmisji (standard (IEEE 802.12); używana w systemie 100VG-AnyLAN

### DNS (Domain Name System)

#### Powstanie DNS

System używania nazwy jako bardziej przyjaznej dla człowieka abstrakcji adresu maszyny w sieci poprzedza powstanie TCP/IP i sięga czasów ARPANET-u. Od początków istnienia internetu potrzebne było przedstawienie adresów internetowych w formie przyjaznej dla człowieka. 
W małych sieciach takie odwzorowanie można przeprowadzić przy pomocy tablic zawierających odpowiednie rekordy. W większej skali tablica stałaby się ogromna, przeszukiwanie nieefektywne i trudne byłoby utrzymywanie synchronizacji pomiędzy wszystkimi serwerami zawierającymi dane. 

Z początku istniał serwer z plikiem host, który zawierał mapowania adresów IP na nazwy. Każdy komputer w sieci pozyskiwał plik nazwany HOSTS.TXT z SRI (obecnie SRI International), który mapował adres na nazwę. Technicznie ten system nadal istnieje - większość współczesnych systemów operacyjnych może sprawdzać swój plik hostów zanim sprawdzi DNS.

Gdy pojawiała sie nowa maszyna, administrator sieci do której należała przesyłał pocztą informację do InterNIC, tam uaktualniano plik hosts.txt i rozsyłano go po świecie. 

Na początku gdy internet składał się z niewielkiej ilości komputerów i ten system wystarczał. 
Rowiązanie to miało wbudowane ograniczenia ponieważ oczywistym wymaganiem było, że jeśli jakiś komputer zmieniał adres, to każdy system który chciał się z nim skomunikować musiał uaktualnić swój plik hosts. Kiedy wpisy zaczęły się pojawiać kilka razy dziennie, listy stawały się coraz dłuższe, serwer nie był w stanie obsłużyć żadań a plik był wiecznie nieaktualny, pomimo tego, że był uaktualniany i dystrybuowany coraz szybciej. 
Rozwój sieci wymagał bardziej skalowalnego systemu, gdzie zmiana nazwy wymaga zmiany tylko w jednym miejscu i w którym inne hosty mogą sie dowiedzieć o tej zmianie dynamicznie. Tym właśnie jest DNS. 

Paul Mockapetris wymyślił DNS w 1983; oryginalna specyfikacja pojawiła się w RFC 882 i 883, w 1987 publikacja RFC 1034 i RFC 1035 uaktualniła specyfikację DNS i uczyniła RFC 882 i 883 _obsolete_. Wiele innych RFC jest rozszerzeniami tego protokołu. 

DNS to rozproszona baza danych, w której każdy host zawiera jednynie część informacji, każdy serwer nazw ma pod swoją kontrolą obszar sieci zwany strefą, przy czym strefy mają strukturę hierarchiczną. Do wymiany komunikatów pomiędzy serwerami nazw jako protokołu transportowego używa się UDP, a do wymiany informacji zawartej w lokalnej bazie każdego serwera używa się TCP. 

Jest hierarchicznie dystrybuowaną usługą tłumaczenia nazw na adresy IP i odwrotnie. Dzięki zagwarantowanej nadmiarowości (konfiguracja serwera zapasowego) jest niezawodna. 
Rozproszona struktura wynika z tego, że różne serwery zarządzają różnymi częściami drzewa nazw, a ta hierarchiczna (drzewiasta) natura gwarantuje unikalność każdej nazwy. 
Struktura adresowa DNS nie musi mieć cokolwiek wspólnego z IP; w skład jednej domeny nie muszą wchodzić komputery znajdujące się fizycznie w tej samej sieci. 

Wszyscy więksi operatorzy prowadzą dla potrzeb swoich podsieci odrębne serwery DNS, na których przechowywane są kopie danych strefowych.

#### Działanie DNS

Usługa nazewnicza domen (DNS) zajmuje się tłumaczeniem nazw hostów na adresy IP i odwrotnie, oraz rozpowszechnia w całym internecie bazę nazw przypisanych adresom IP. Zapewnia usługę rozwiązywania nazw. 
Jest to system przechowywania informacji o nazwach hostów i nazw domenowych w rodzaju rozproszonej bazy danych w sieci, najważniejszą funkcją jest zapewnienie adresu IP dla każdej nazwy hosta i serwerów pocztowych dla każdej domeny. 

Składa się z dwóch odrębnych działań. 

- procedury odwzorowywania nazwy hosta na adres IP
- dystrybucji danych opisujących odwzorowanie

DNS to system serwerów oraz protokół komunikacyjny zapewniający zamianę adresów znanych użytkownikom internetu na adresy zrozumiałe dla sieci komputerowej. Dzięki wykorzystaniu DNS nazwa mnemoniczna, np. pl.wikipedia.org może zostać zamieniona na odpowiadające jej adres IP, czyli 207.142.131.245. 
Zapewnia to podstawową usługę w sieci, bo podczas kiedy komputery pracują na adresach IP dla adresowania i rutowania pakietów to ludzie potrzebują używać nazw hostów i domen, np. w URL-ach i adresach mailowych. Więc DNS pośredniczy pomiędzy potrzebami i preferencjami ludzi (wetware) i software. 

Strukturalnie rzecz biorąc, DNS to rozproszona baza danych, której zawartość rozsiana jest po całym internecie, a poszczególne serwery DNS na stałe przechowują tylko pewien podlegający im podzbiór danych. Obsługa zapytań stawianych tej ogromnej rozproszonej bazie danych funkcjonuje dzięki temu, że DNS może przesyłać dalej żądania translacji do właściwego serwera w sposób automatyczny, który daje się bardzo dobrze skalować. 

Serwery nazw przechowują dwa rodzaje informacji. HMPTODO

- kompletna baza, w której znadują się dane odnośnie całej strefy nazw, są odświeżane w określonych odcinkach czasu
- przechowywane informacje, kórych żądał w ostatnim czasie lokalny resolver

System DNS składa się z:

- serwera (Name Server) - zawierającego bazę danych o innych komputerach w sieci; nie zawiera informacji o wszystkich maszynach w sieci, ma jedynie adresy lokalnych maszyn zdefiniowane w strefach, które obsługuje oraz informacje o adresach innych serwerów DNS, jeśli chce znaleźć informacje o adresie, którego nie ma w swojej bazie danych wysyła zapytanie do innych serwerów w celu odnalezienia tej nazwy, czyli przechowuje tylko niewielki fragment tzw. przestrzeni nazw domeny, ale może także przechowywać dane pochodzące z innych części przestrzeni nazw w pamięci podręcznej
  - rekursywny serwer DNS, który szuka w systemie odpowiedzi na pytania resolwerów i zwraca im odpowiedzi
  - autorytatywny serwer DNS, który daje odpowiedzi na zapytania z rekursorów, albo w formie odpowiedzi, albo w formie delegacji (odniesienia do innego autorytatywnego serwera DNS).
- klienta (resolver) - program klienta dzialający na komputerze użytkownika generujący zapytanie DNS (DNS request) na żądanie programów; kieruje zapytania do serwera DNS, jest to program zainstalowany na komputerze, który korzysta z internetu, konfigurowany za pomocą plików:
  - /etc/host.conf - wskazuje jakich usług nazw powinien używać resolver oraz w jakiej kolejności ma to robić, przykładowy wpis
```
order hosts,bind
multi on
```
oznacza, że resolwer najpierw sprawdzi plik /etc/hosts a potem będzie wysyłał zapytania do serwera DNS, parametr multi on wskazuje host z pliku /etc/hosts otrzyma wszystkie prawidłowe adresy a nie tylko pierwszy z nich
  - /etc/resolv.conf - przykładowo:
```
search domena.com.pl
nameserver 127.0.0.1
nameserver 194.204.159.1
nameserver 194.204.152.34
```
    - Polecenie search definiuje listę domen, jaka będzie używana w celu rozszerzenia nazwy hosta zanim zostanie wysłana do serwera nazw, umożliwia to używanie krótkich nazw hostów - jeśli użytkownik wprowadzi tylko nazwę hosta to będzie ona rozwinięta o nazwę domeny przed wysłaniem do serwera nazw.
    - Polecenie nameserver wskazuje adres serwera DNS, mogą być ich maksymalnie trzy, zapytania będą kierowane do nicj w takiej kolejności w jakiej zostały wpisane dopóki nie zostanie uzyskana odpowiedź lub nie minie czas oczekiwania resolvera, jeśli serwer nie działa lub jest nieosiągalny zapytanie jest kierowane do następnego.

Dwa znaczenia DNS

- DNS to złożony system komputerowy oraz prawny:
  - zapewnia rejestrację nazw domen internetowych i ich powiązanie z numerami IP
  - realizuje bieżącą obsługę komputerów odnajdujących adresy IP odpowiadające poszczególnym nazwom
- DNS oznacza również protokół komunikacyjny jakim posługują się maszyny w sieci do pobierania potrzebnych im adresów. Dodatkowo protokół DNS zawiera opis w jaki sposób serwery DNS mają synchronizować między sobą swoje bazy adresowe, oraz sposób łączenia się klientów z serwerami DNS. Częścią specyfikacji protokołu jest również zestaw zaleceń, jak aktualizować wpisy w bazach domen internetowych.

Podstawą technicznego systemu DNS jest ogólnoświatowa sieć serwerów. Przechowują one informację na temat adresów domen. Każdy wpis zawiera nazwę oraz odpowiadający jej adres IP. Wpisy udostępniane są automatycznie, co pozwala na pracę Internetu. 
Po całym świecie rozsiane są DNS, które odpowiadają za obsługę poszczególnych adresów internetowych. Listę 13 głównych serwerów odpowiedzialnych za obsługę poszczególnych domen najwyższego poziomu można pobrać z [ftp://ftp.rs.internic.net/domain/named.root](ftp://ftp.rs.internic.net/domain/named.root)

Najważniejsze cechy systemu DNS:

- Nie ma jednej centralnej bazy danych adresów IP i nazw. Najważniejsze jest te 13 serwerów, które są rozrzucone na różnych kontynentach.
- Serwery DNS przechowują dane tylko wybranych domen.
- Każda domena ma co najmniej 2 serwery DNS obsługujące ją; jeśli więc nawet któryś z nich będzie nieczynny, to drugi może przejąć jego zadanie.
- Serwery DNS przechowują przez pewien czas odpowiedzi z innych serwerów (ang. _caching_), co skraca proces zamiany nazw na adresy IP.
- Każdy komputer może mieć wiele różnych nazw. Na przykład komputer o adresie IP 207.142.131.245 ma nazwę pl.wikipedia.org oraz de.wikipedia.org
- Czasami pod jedną nazwą może kryć się więcej niż 1 komputer po to, aby jeśli jeden z nich zawiedzie, inny mógł spełnić jego rolę.
- Jeśli chcemy przenieść serwer WWW na inny szybszy komputer, z lepszym łączem, ale z innym adresem IP, to nie musimy zmieniać adresu WWW strony, a jedynie w serwerze DNS obsługującym domenę poprawiamy odpowiedni wpis.
- Protokół DNS posługuje się do komunikacji głównie protokołem UDP.
- Serwery DNS działają na porcie numer 53.

Diagnostyka: użytkownik komputera ma kilka narzędzi umożliwiających sprawdzenie dlaczego jakaś nazwa mnemoniczna nie jest poprawnie zamieniana na adres IP. Służy do tego polecenie host. Dla przykładu po wpisaniu:

```
host pl.wikipedia.org
```

otrzymamy listę adresów IP komputerów, które obsługują stronę internetową pl.wikipedia.org:

```
Komputer:~# host pl.wikipedia.org
pl.wikipedia.orgA 207.142.131.245
pl.wikipedia.orgA 207.142.131.246
pl.wikipedia.orgA 207.142.131.247
pl.wikipedia.orgA 207.142.131.248
pl.wikipedia.orgA 207.142.131.235
pl.wikipedia.orgA 207.142.131.236
```

Konfiguracja
Zwykle dane o konfiguracji protokołu DNS w domowym komputerze przekazywane się przez dostawcę Internetu (ISP). 
Większość operatorów udostępnia w swojej sieci protokół DHCP. Dzięki niemu komputer automatycznie może pobrać adres serwera DNS operatora. Serwer ISP działa najszybciej, bo ma zgromadzone w swojej pamięci najważniejsze adresy i jest blisko użytkownika Internetu. 
Serwery DNS Telekomunikacji Polskiej, to 194.204.152.34 oraz 194.204.159.1. Kiedy system automatycznego pobierania adresów serwera DNS nie działa, wtedy można je ręcznie wprowadzić. 
Lokalną listę serwerów DNS zawiera plik: /etc/resolve.conf, dla przykładu, jeżeli chcemy ręcznie ustawić serwery TPSA jako aktywne to możemy wpisać do tego pliku ich adresy:

```
194.204.152.34
194.204.159.1
```

i wtedy komputer wykorzysta je do odnajdywania nazw DNS. 
Plik: /etc/hosts zawiera listę zdefiniowanych przez użytkownika nazw komputerów:

```
127.0.0.1 localhost #adres lokalnego interfejsu sieciowego
192.168.0.1brama #serwer dostępu do sieci
192.168.0.2kasia #inne komputery w sieci lokalnej
192.168.0.3janek
```

Użytkownik może do tego pliku wpisać własne nazwy dla komputerów lokalnych. Dzięki temu, nie będzie musiał wpisywać ich adresów IP, tylko łatwe do zapamiętania nazwy. Nazwa mnemoniczna localhost oznacza komputer, na którym pracujemy (IP 127.0.0.1). 

#### Bezpieczeństwo

System DNS został zaprojektowany wiele lat temu przez naukowców. Nie przewidzieli oni istnienia światowej sieci używanej do prowadzenia poważnych operacji, ani tego, że sieć może być nadużywana. 

Najprostszym przypadkiem jest phishing wykorzystujący podobieństwo adresów. 
Na przykład klient banku używającego adresu bank.pl dostaje mail z prośbą, żeby wszedł na wskazaną linkiem w mailu podstronę bank.pt i zaktualizował dane, w przeciwnym wypadku konto zostanie zablokowane. Klient, który w pośpiechu wykona to polecenie najczęściej nie zauważy, że adres jest podobny, ale nie taki sam (bank.pl - bank.pt), a cała podstrona była tylko zręcznie wykonaną podróbką. Ponieważ podał login i hasło to o ile bank nie stosuje dodatkowych zabezpieczeń w rodzaju tokenów oszuści, którzy wysyłali mail i stworzyli fałszywą stronę mają dostęp do pieniędzy nieuważnego klienta. 
Tego typu oszustwo jest od niedawna jeszcze łatwiejsze: do nazw domenowych dopuszczono znaki spoza ASCII, więc można zarejestrować domenę, która będzie wyglądać nie podobnie, ale identycznie. Dlatego koniecznie używając usług banków internetowych należy wyłączyć obsługę znaków międzynarodowych i zastosować ochronę antyspoofingową. 

Pewną ochroną przed tego typu zagrożeniami jest SSL, który zapewnia uwierzytelnienie - weryfikację tożsamości organizacji, która jest właścicielem strony WWW. 

DNS poisoning, DNS spoofing, czyli zatruwanie DNS-u jest bardzo groźne, bo nawet po wykryciu fałszywe dane jakiś czas funkcjonują w buforach. Zapobiega się temu używając SSL.

#### Hierarchia nazw domen

System DNS jest rozproszoną oraz hierarchiczną bazą danych. Decentralizacja tego systemu osiągana jest przez tzw. delegację domen. 
Każda domena jest podzielona na subdomeny, np. domena root (.) składa się z domen .com, .edu, .pl itd. Każda poddomena może być delegowana do innej organizacji, która będzie odpowiedzialna za utrzymywanie dalszych subdomen w tej domenie (np. domena .pl jest oddelegowana do NASK). 
Delegacja domeny jest jedną z czynności konfiguracji serwera nazw, jeżeli domena zostałą oddelegowana do pewnego serwera to teraz on jest odpowiedzialny za jej rozwój. Kierując wniosek o rejestrację domeny w NASK i podając adresy serwerów nazw, mamy do czynienia z delegacją domeny, wszelkie zapytania dotyczące serwerów w naszej domenie będą kierowane do naszych serwerów nazw. Serwer nadrzędny przekazujący subdomenę nie będzie musial zawierać informacji o wszystkich hostach w naszej domenie, lecz tylko znać adresy serwerów nazw odpowiedzialnych za subdomenę. Jeśli użytkownik wpisze adres nazwa.wroc.edu.pl to kolejno będą przeszukiwane serwery nazw odpowiedzialne za domeny: .pl, .edu.pl, .wroc.edu.pl, nazwa.wroc.edu.pl. 

W rzeczywistości jest to trochę bardziej skomplikowane. Najpierw odpytywany jest DNS obsługujący daną maszynę, może on mieć daną informację (bo ktoś o nią pytał i jest w buforze) albo odesłać pytanie do serwerów właściwych dla danych domen. Dopiero gdy brak jest tych danych odpytywane są serwery domen nadrzędnych. 
W najgorszym przypadku zapytanie trafi do któregoś z Root Level Servers, który prześle je do właściwej hierarchii. 
Dla odciążenia jest ich dziewięć (oznaczonych literami od A do I) - mają strategiczne znaczenie dla całego internetu.

DNS składa się z hierarchiczego zestawu serwerów DNS, każda domena lub subdomena ma jeden lub więcej autorytatywnych serwerów DNS, które publikują informacje o domenach i serwerach nazw każdej domeny leżącej "poniżej". Hierarchia autorytatywnych serwerów jest zgodna z hierachią domen, na szczycie każdej hierachi są rootserwery, które odpowiadają kiedy szuka (rozwiązuje) się nazwy domeny TLD. 

Każdy serwer nazw musi adresy serwerów głównych, a jego adres musi być znany wszystkim hostom w obsługiwanej przez niego domenie. 

Nazwa domenowa musi się składać z dwóch lub więcej części (technicznie etykieta) rozdzielonych kropkami. 

- etykieta najbardziej na prawo zawiera _top-level domain_ (TLD) (np. adres isoc.org.pl ma domene TLD .pl).
- każda etykieta określa poddział (subdivision) lub subdomenę domeny na górze, określenie subdomena wyraża relatywną zależność, a nie absolutną; dla przykładu: org.pl jest poddomeną domeny .pl a isoc.org.pl poddomeną domeny .org.pl
- leżąca najbardziej na lewo (zwykle) część nazwy domenowej jest nazwą hosta; podczas kiedy reszta nazwy po prostu określa drogę budowania logicznej ścieżki do żądanej informacji, to właśnie nazwa hosta jest nazwą rzeczywistego systemu docelowego, którego IP jest potrzebne; np. www.isoc.org.pl ma nazwę hosta "www".

TLD znajduje się na samym końcu nazwy domeny, na lewo od niej jest Second Level Domain itd, na samym początku jest nazwa komputera (np. www). 
Teoretycznie takie zagnieżdzenie może mieć 127 stopni, a pojedynczy segment, element nazwy (nazwa hosta lub subdomeny) nie może być dłuższy 63 znaków, a cała nazwa nie może przekroczyć całkowitej długości 127 (255[?]) znaków. W praktyce jednak niektórzy rejestratorzy wprowadzają dodatkowe ograniczenia. 
Pierwszy znak w nazwie hosta lub domeny musi być literą (z przedziału A-Z lub a-z), oprócz małych i dużych liter w nazwie mogą występować tylko cyfry oraz znak minusa; w systemie DNS nie są rozróżniane małe i DUŻE litery

Międzynarodowe nazwy domen
Nazwy domen muszą używać zestawu znaków ASCII przez co wiele języków nie może prezentować swoich nazw natywnie. ICANN zaprobowała system oparty na Punycode IDNA który mapuje ciągi znaków unkodowych na poprawny zestaw znaków DNS jako obejście tego problemu i część rejestratorów zaaprobowała IDNA. 

Nowe domeny można tworzyć tylko w obrębie już istniejących, a wszystkie muszą należeć do którejś z TLD. 

Przykład:

- .com - Top Level Domain
- google.com - Second Level Domain - jej właściciel ma prawo do tworzenia kolejnych domen w jej obrębie, na niego przechodzi obowiązek albo utrzymywania właściwych dla tych domen serwerów DNS, albo zlecenie tego swojemu ISP
- scholar.google.domain - Third Level Domain itd.
- www.google.com - to nie Third Level Domain ale nazwa hosta (serwer HTTP) jest na początku, nie jest konieczna, bo przeglądarka nie z adresu a z określenia protokołu transmisji (http://) dowiaduje się, że dany adres URL należy do sieci WWW; z tego samego powodu serwer FTP nie musi się nazywać ftp.
- user@gmail.com - adres pocztowy nie musi zawierać informacji o nazwie serwera pocztowego, wystarczy wskazanie domeny, ponieważ system DNS przy transmitowaniu wiadomości e-mail system DNS ma dodatkowe zadanie ustalenia serwera poczty obsługującego daną domenę, informacja ta może być wprowadzana przez administratorów DNS w odpowiednich miejscach w zbiorach Zone-Files. 
Więc najpierw pytający musi się dowiedzieć jaka jest nazwa serwera pocztowego dla domeny a potem jaki jest jego adres IP.

Strefa to jedna lub kilka domen wraz z subdomenami, które są administrowane przez jeden serwer DNS

Przestrzeń nazw została zbudowana na modelu domenowym, nazwa danego hosta tworzona jest od prawej do lewej. Najpierw są nazwy domeny górnego poziomu, następnie poddomeny i na końcu nazwa hosta oddzielone kropkami. 

Struktura usługi DNS definiuje hierarchię nazw domen uporządkowanych w strukturę drzewa, odchodzącą od domeny głównej (ang. root domain) oznaczanej przez pojedynczą kropkę ".". 
Od domeny głownej odchodzi szereg domen najwyższego poziomu (ang. Top Level Domain), których nazwy mają postać przyrostka informującego o typie organizacji (organizacyjne: gTLD) lub dwuznakowego kodu państwa (geograficzne: ccTLD). 

gTLD (global Top Level Domain):

- .com - jednostka komercyjna
- .org - oryginalnie przewidziana dla jednostek niekomercyjnych
- .net - oryginalnie przewidziana dla organizacji związanych z infrastrukturą internetu (np. ISP) firmy i organizacje zajmujące się administrowaniem i utrzymywaniem sieci komputeowych
- .biz - jednostki biznesowe
- .info - informacyjne, ogólne
- .int - organizacje międzynarodowe lub nie dające się zlokalizować w żadnym konkretnym państwie; istniejące na mocy układów międzynarodowych
- .gov - jednostki rządowe USA
- .edu - wyższe uczelnie amerykańskie; przyznające stopnie naukowe
- .mil - USArmy
- .coop - organizacje / stowarzyszenia współpracy
- .name - osoby prywatne
- .aero - przemysł lotniczy
- .museum - muzea

ccTLD (countrycode Top Level Domain):

- .us - USA
- .uk - Wielka Brytania
- .de - Niemcy
- .pl - Polska w obrębie takiej domeny powtarzana jest hierachia gTLD
- .edu.pl
- .com.pl
- .org.pl
- .gov.pl
- eu - planowana domena dla Unii Europejskiej
- ...

Nazwy domenowe muszą zapewnić mechanizm określania zasobów w taki sposób by ich nazwy mogły byc używane przez różne systemy, sieci, czy rodziny protokołów. 

Kombinacja nazwy hosta, nazwy domeny i nazwy domeny nadrzędnej jednoznacznie identyfikuje host w sieci internet i tworzy tzw. w pełni kwalifikowalną nazwę domenową (FQDN - Full Qualified Domain Name). 

Nazwa ta używana jest jako argument dla funkcji czy też lokalnego agenta zwanego resolverem (ang. resolver), który potrafi odnaleźć i sprowadzić informację zwiazaną z daną nazwą np. adres IP określonego komputera. 
Resolver od strony użytkownika jest pojedynczą bazą danych, swego rodzaju interfejsem, który ukrywa rzeczywistą strukturę DNS i przepływ zapytań pomiędzy poszczególnymi serwerami nazw. 
Od strony resolvera informacje o nazwach domenowych zawarte są w rozproszonej bazie danych, której cześciami składowymi są poszczególne serwery nazw. Baza ta jest redundantna, tzn. jeden rekord może się znajdować na dwóch lub więcej serwerach. resolver na początku musi znać adres przynajmniej jednego serwera nazw. Po otrzymaniu zapytania od użytkownika kontaktuje się ze znanym sobie serwerem, od którego otrzymuje żądaną informację bądź też odniesienie do innego serwera nazw. 

Strefy czyli fragmenty przestrzeni nazw domeny są zdefiniowane w określonym pliku strefowym (zone file), każdy serwer odpowiada tylko za pewna część nazw i adresów. 
W plikach Zone-Files, w których znajdują się wykazy nazw wszystkich hostów występujących w ramach danej domeny wraz z odpowiadającymi im adresami IP. Ponadto w tym miejscu mogą być zdefiniowane poszczególne subdomeny należące do bieżącej domeny oraz inne serwery DNS jeżeli dana subdomena tworzy samodzielną strefę na innym serwerze DNS. Korzystając ze zbioru Zone-Files serwer może więc udzielać informacji dla wszystkich umieszczonych w nim domen. Serwery DNS mogą ponadto wykorzystywać kilka różnych Zone-Files. 
Nazwa domeny składa się z identyfikatora hosta i nazw poddomen aż do domeny głównej root ".". 
Domeny główne (Top Level Domains) takie jak .org i .com są obsługiwane przez tzw. główne serwery nazw (Root Level Servers) ich lista jest przechowywana w pliku named.root. 

Serwer DNS oprócz zamiany nazwy hosta na numer IP realizuje także usługę odwrotną, tzw. Reverse DNS, (_Inverse Lookup_). W tym celu stworzono specjalną domenę .in-addr.arpa. Komputer o adresie a.b.c.d ma w niej adres d.c.b.a.in-addr.arpa (uwaga: oktety IP wpisuje się w odwrotnym porządku). Więc takie wyszukanie polega na odwróceniu oktetów w adresie IP i potraktowaniu go jako subdomeny w ramach domeny .in-addr.arpa. 
Strefy odwrotne zdefiniowane są w oddzielnych plikach (reverse zone files). 
Wszystkie adresy IP są umieszczone w domenie .in-addr.arpa w formie d.c.b.a.in-addr.arpa - jeśli chcemy wiedzieć jaka nazwa jest skojarzona z danym IP musimy zapytać o ten adres. Nie każdy serwer ujawnia takie informacje. Administrator serwera DNS decyduje na poziomie strefy czy ta funkcja jest w niej dozwolona. 

DNS umożliwia zmianę ISP bez zmiany adresu, wystarczy w pliku konfiguracyjnym serwera DNS zmodyfikować wpis dotyczący przenoszonego serwera. 

#### Wyszukiwanie DNS

Seria zapytań: DNS query czyli kolejne przepytywanie serwerów DNS. 

Serwery mogą też działać w trybie rekursywnym, w którym podają użytkownikowi ostateczną odpowiedź same wykonując proces poszukiwań serwera właściwego dla danej nazwy. Aby system działał sprawnie wprowadzono kilka zasad. 

- każde zapytanie jest kierowane najpierw do resolvera, który ma zadanie odnaleźć dane
- resolver oraz wszystkie serwery buforują dane aby zmniejszyć ruch w sieci oraz przyspieszyć udzielanie odpowiedzi
- w buforach odpowiedzi są przechowywane przez czas określony parametrem TTL (czyli zmiany nie rozchodzą sie natychmiast, stare wartości jakiś czas nadal pozostają na serwerach).

Przykład rekursji DNS
Załóżmy, że aplikacja potrzebuje znaleźć adres IP dla hosta www.isoc.org.pl, więc wysyła zapytanie do lokalnego rekursora. 

- zanim zacznie, rekursor musi wiedzieć gdzie znaleźć rootserwery, administratorzy rekursywnych serwerów ręcznie określają (i okresowo uaktualniają) plik zwany _the root hints zone_ który określa adresy IP tych serwerów.
- proces zaczyna się od wypytywania jednego z tych serwerów, np. "jaki jest adres IP dla www.isoc.org.pl?"
- rootserwer odpowiada delegacją czyli mówi "nie wiem jaki jest adres serwera www.isoc.org.pl, ale dla domeny .pl informacje ma serwer..."
- lokalny rekursor pyta wskazany w odpowiedzi serwer o to samo i dostaje podobną odpowiedź: "nie znam adresu hosta www.isoc.org.pl, ale dla domeny .org.pl informacje ma serwer..."
- ostatecznie ten serwer odpowiada na pytanie żądanym adresem.

Kiedy aplikacja (np. przeglądarka WWW) chce znaleźć adres IP nazwy domenowej, nie musi podążać poprzez wszystkie zarysowane wyżej kroki, ponieważ często korzysta z bufora. 

A skąd serwer DNS wie jaki adres IP ma dana domena? Odpowiedź jest podana w pierwszym kroku - adresy IP rootserwerów są ręcznie wpisywane w konfiguracji, a serwery nazw, które są autorytatywnymi dla TLD zmieniają się bardzo rzadko. 
Jednakże serwery nazw które zapewniają autorytatywne odpowiedzi dla większości popularnych domen mogą zmieniać się względnie czesto, jako część usługi rejestracji nazwy domenowej rejestrator zapewnia rejestr z serwerami nazw które będą autorytatywne dla tej domeny i właśnie z tego rejestru korzysta serwer DNS. 
Zwykle serwery nazw są tam określone według nazwy a nie adresu IP. Generuje to następny strumień zapytań DNS by rozwiązać nazwę serwera nazw, kiedy adres IP serwera nazw jest zarejestrowany w strefie macierzystej (_parent zone_) nazywa się to _glue record_. 

Bufor i TTL
Żeby zmniejszyć ilość zapytań DNS generowany przez system projektanci zapewnili mechanizm zmniejszenia obciążenia serwerów DNS. Kiedy resolwer DNS (np. klient) otrzyma odpowiedź przechowa ją w buforze przez określony parametrem TTL czas. Wartość tego parametru ustawiona jest przez administratora serwera udzielającego odpowiedzi. Kiedy takie pytanie się powtórzy resolwer zamiast przesłać je dalej użyje wartości zachowanej w buforze, chyba, że czas TTL upłynął (lub administrator oczyścił bufor). 

Czas propagacji
Ważną konsekwencją tej architekturze opartej na dystrybucji i buforowaniu danych jest to, że zmiany w DNS nie są globalnie widoczne natychmiast. Przykład: jeśli administrator ustawił TTL na 6 godzin dla hosta www.isoc.org.pl a potem zmienił adres IP na który się rozwiązuje www.isoc.org.pl o 12.01 to administrator musi uwzględnić, że osoba, która zbuforowała odpowiedź o 12.00 nie skorzysta z serwera i nie uzyska nowej wartości aż do 18.00. Okres pomiędzy 12.01 a 18.00 nazywany jest czasem propagacji, który najlepiej jest określić jako okres zaczynający się kiedy wprowadza się zmianę w rekordzie DNS a kończy kiedy upływa maksymalna ilość czau określona przez TTL. 
To prowadzi do wniosku, że kiedy zmienia się wpisy w DNS nie wszyscy widzą to samo (RFC 1537). 

DNS w realnym świecie
W rzeczywistym świecie użytkownicy nie mają bezpośrednio do czynienia z resolwerem DNS, używają programów takich jak przeglądarki internetowe (np. Opera lub Firefox) lub klientów poczty (jak Thunderbird). Kiedy użytkownik robi zapytanie które wymaga zapytania DNS (ang. _lookup DNS_) - w rzeczywistości takie jest każde zapytanie które używa internetu - taki pogram wysyła zapytanie do resolwera DNS wbudowanego w system operacyjny. 
Ten resolwer praktycznie zawsze ma bufor zawierający ostatnie zapytania. Jeśli jest tam odpowiedź natychmiast ją dostarcza, a jeśli jej nie ma wysyła zapytanie do przydzielonego serwera (lub serwerów) DNS. W przypadku większości domowych użytkowników ISP przydziela taki serwer, więc użytkownik albo skonfiguruje to ręcznie albo zajmuje się tym DHCP. 
Niektóre aplikacje (np. przeglądarki WWW) mają własne bufory DNS w celu zmniejszenia użycia biblioteki resolwera DNS. Te bufory zwykle mają bardzo krótki czas przechowywania: czasem około minuty. 

DNS posiada również inne funkcje. 

- Nazwy hosta i adresy IP niekoniecznie pasują jeden do jednego. 
Wiele nazw hostów odnosi się do jednego adresu IP: co w połączeniu virtual hosting, pozwala jednej maszynie obsługiwać wiele witryn. 
Jeden host może odpowiadać wielu adresom IP, w celu zmniejszania błędów i rozładowania ruchu (fault tolerance and load distribution) a także pozwala witrynie zmienić fizyczną lokalizację w sposób niewidoczny dla użytkownika.
- Jest wiele zastosowań poza tłumaczeniem nazw na adresy IP, dla przykładu MTA używają DNS do dnalezienia serwera pocztowego dla danej domeny.
- Sender Policy Framework
- Żeby zabezpieczyć działanie w przypadku awarii komputera wiele serwerów DNS obsługuje każdą domenę. Szczególne znaczenie ma 13 rootserwerów na całym świecie. Programy DNS i systemy operacyjne mają wbudowane ich adresy IP. USA hostuje przynajmniej nominalnie wszystkie rotserwery oprócz dwóch. Ale ponieważ wiele rootserwerów ma zaimplementowany anycast, gdzie wiele różnych komputerów może mieć dzielić ten sam adres IP i dzielić między siebie obszary sieci, większość fizycznych rootserwerów operuje spoza USA.

DNS używa TCP i UDP na porcie 53, żeby obsłużyć zapytania. Prawie wszystkie zapytania DNS zawierają jedno żądanie UDP, po którym idzie odpowiedź UDP z serwera. TCP jest używane kiedy w grę wchodzi kiedy dane odpowiedzi przekraczają 512 bajtów, albo dla takich zadań jak transfer strefy. 

#### Serwer DNS

Podstawowe konfiguracje serwera nazw:

- Serwer podstawowy (_Master Server_) - główny serwer domeny, ładuje bazę danych z pliku znajdującego się na dysku lokalnym, posiada kompletne o domenie i dlatego określany jest jako autorytatywny (_authoritative_), jego odpowiedzi są zawsze uważane za dokładne
- Serwer pomocniczy (_Slave Server_) - serwer zapasowy, który odpowiada za domenę w czasie awarii serwera podstawowego, z niego pobiera bazę danych i dlatego również uważany jest za autorytatywny; demon named podczas startu ładuje dane z zapasowej kopii bazy na dysku; później jej zawartość jest porównywana z bazą na głównym serwerze i w razie potrzeby modyfikowana
- Serwer buforujący (_Caching Server_) - nie jest serwerem autorytatywnym, gdyż wszystkie dane jakie posiada pochodzą z innych serwerów i są przechowywane w pamięci podręcznej, jeżeli nie ma informacji o żądanych domenach, to pyta o nie inne serwery i buforuje te informacje i przy następnym pytaniu skorzysta z bufora, co zwiększa efektywność i zmniejsza ruch w sieci

Serwer nazw może być jednocześnie serwerem podstawowym dla pewnej domeny i pomocniczym dla innej. 
Ponieważ niesprawny DNS oznacza w praktyce odcięcie od sieci koncepcja systemu DNS zakłada, że w celu zapewnienia niezawodnego działania oprócz podstawowego DNS (Primary DNS) musi być zawsze określony także serwer zapasowy (Secondary DNS Server). Więc każda domena czy strefa musi być obsługiwana przez co najmniej dwa komputery, każdy z nich powinien się znajdować w różnych sieciach i korzystać z różnych zasobów (łączy ze światem i sieci energetycznych). Jeden host nazywany jest nadrzędnym a pozostałe podrzędnym. Dzięki temu zawsze istnieją przynajmniej dwa komputery, które mogą udzielić informacji dotyczących określonej strefy. Wszystkie informacje wprowadzane są do serwera nadrzędnego, a pozostałe maszyny je od niego pobierają. Serwery DNS i resolvery są tak skonfigurowane, że jeśli nie mogą się połączyć z serwerem nadrzędnym próbują skontaktować się z podrzędnymi. 
Host obsługujący konkretną domenę zawiera tzw. delegacje (czyli odsyłacze) do serwerów DNS poddomen oraz adresy serwerów domeny głównej.

Typy rekordów DNS HMPTODO

- rekord A, lub rekord adresu mapuje nazwę hosta na jego 32-bitowy adres IPv4.
- rekord AAAA, lub rekord adresu IPv6 mapuje nazwę hosta na jego 128 bitowy adres IPv6.
- rekord CNAME, lub rekord nazwy kanonicznej sprawia, że nazwa jednej domeny jest aliasem drugiej; taki alias przejmuje również wszystkie subdomeny i rekordy DNS jak oryginał.
- rekord MX, lub rekord wymiany maili (_mail exchange record_) mapuje nazwę domeny na listę serwerów wymiany poczty dla tej domeny.
- rekord PTR (_pointer record_) - mapuje nazwę hosta na kanoniczną nazwę dla tego hosta, ustawienie rekordu PTR dla nazwy hosta w domenie in-addr.arpa, która wiąże się z jego adresem IP jest implementacją odwrotnego wyszukiwania DNS dla tego adresu. Dla przykładu: adresem IP dla www.isoc.org.pl jest a.b.c.d ale rekord PTR mapuje d.c.b.a.in-addr.arpa na jego nazwę kanoniczną.
- rekord NS, lub rekord serwera nazw - mapuje nazwę domeny na listę serwerów DNS dla tej domeny, w ten sposób tworzy się delegacje.
- rekord SOA (_start of authority record_) - określa serwer DNS który zapewnia autorytatywne informacje o tej domenie.
- rekord SRV znany także jako _Service record_ - informacja o doestępnych usługach, ma cztery pola i specyficzną składnię: podkreślenie, nazwa usługi, kropka, podkreślenie, protokół, kropka, nazwa domeny;
te cztery pola to:
  - Priorytet - rekord MX
  - Waga - używana do dostosowania ruchu do wydajności serwera
  - Port usługi
  - Nazwa hosta, przykład:
```
_http._tcp.example.com. SRV 10 5 80. www.example.com
```
- rekord TXT pomaga administratorowi umieścić arbitralny tekst w rekordzie DNS, jest używany również w specyfikacji Sender Policy Framework.

Inne rodzaje rekordów po prostu zapewniają informację (np. rekord LOC daje fizyczną lokalizację hosta), lub dane eksperymentalne (dla przykładu rekord WKS daje listę serwerów oferujących dobrze znane usługi takie jak HTTP lub POP3 dla domeny). 

oprogramowanie DNS

- BIND (Berkeley Internet Name Domain)
- djbdns (Daniel J. Bernstein's DNS)

#### Dynamiczny DNS

Dynamiczne przydzielanie adresów IP, najczęściej przez DHCP. Również tworzy on pary IP - nazwa domenowa i informacje o tym wysyła do serwera DNS, który automatycznie uaktualnia wpisy dotyczące stref dynamicznych. 
Żeby to było możliwe oprogramowanie serwera musi mieć specjalne opcje. BIND do rekordu SOA dodawane jest polecenie allow-update z numerem IP odpowiedniego komputera, informacje przesyłane między serwerem DHCP a DNS są podpisane kluczem kryptograficznym. 
Zmiany dokonywane są w nadrzędnym serwerze danej strefy, maszyny podrzędne po otrzymaniu polecenia uaktualnienia informacji przekazują ją do komputerów nadrzędnych i dokonywany jest transfer strefy. Dla ułatwienia zarządzania dla adresów dynamicznych tworzone są osobne strefy. 
W domenach dynamicznych czasy TTL są krótkie i powinny być takie same dla wszystkich rekordów. 

#### BIND (Berkeley Internet Name Domain)

BIND jest najpopularniejszą implementacją serwera nazw, składa się z:

- demona serwera nazw: oddzielny proces o nazwie named
- bibliotek stanowiących kod resolvera

Główny plik konfiguracyjny to /etc/named.conf. Podobnie jak w języku C komentarze mogą być wprowadzane za pomocą dwóch slaszy (//komentarz) lub (/\*komentarz\*/). 
Elementy odnoszące się do wspólnego zasobu grupowane są w nawiasach klamrowych, a każda instrukcja kończy się średnikiem. Zwykle plik konfiguracyjny zawiera instrukcję options a w niej polecenie directory wskazujące na katalog, w którym będą umieszczone wszystkie pliki stref, pozwala to na dopisanie względnych nazw plików do definicji stref, przykładowo może to wyglądać tak:

```
options {directory "/var/named";};
``` 

Strefy definiowane są za pomocą instrukcji zone, która zawiera nazwę strefy, typ serwera dla tej strefy, wskazuje na źródło z informacją o strefie oraz dodatkowe opcje. Polecenia zone wpisywane są oddzielnie dla każdej strefy, a w przypadku obsługi wielu domen instrukcje mogą występować wielokrotnie. 

```
zone "." {type hint; file "root.hints";};
``` 

root.hints zawiera wskazówki dotyczące domeny głównej, wpisane są w konwencji RR (nazwa ttl klasa typ dane), np:

```
A.ROOT-SERVERS.NET. 5W IN A 198.41.0.4
```

```
zone "domena.com.pl" {type master; file "named.domena.com.pl";};
``` 

jest to serwer podstawowy (nadrzędny) dla domeny domena.com.pl
 
```
zone "0.0.127.in-addr.arpa" {type master; file "0.0.127";};
```

odnośnik do pliku 0.0.127:

```
$TTL 1D
0.0.127.in-addr.arpa IN SOA domena.org. admin.domena.org. (2005010401 10H 1H 3W 12H)
@ IN NS domena.org.
1 IN PTR localhost.
```

gdzie pierwszy wiersz określa domyślną wartość parametru TTL - w tym przypadku informacje o strefie będą przechowywane przez jeden dzień;
w drugim wierszu definicja strefy: nazwa właściwego serwera DNS i adres administratora (@ zamienione na kropkę), potem jest wersja pliku i dane określające, że serwery podrzędne mają uaktualniać swoje dane co 10 godzin pobierając informacje z serwera nadrzędnego, gdyby serwer był niedostępny operację synchronizacji trzeba ponawiać co godzinę, a po trzech tygodniach bezowocnych prób dane z serwera podrzędnego mają być usunięte, po 12 godzinach mają być usunięte odpowiedzi negatywne;
dwie ostatnie linie zawierają definicje serwera nazw dla naszej domeny oraz, że host 1 (czyli 1.0.0.127.in-addr.arpa) ma nazwę localhost;
kropki na końcach nazw oznaczają, że to FQDN a 1 jest częścią domeny 0.0.127.in-addr.arpa.

W katalogu /var/named/ trzeba utworzyć plik named.domena.com.pl, zawierający informację o strefie (zone file). 

Przykładowy plik:

```
; strefa przyklad.pl
$TTL 5D ; piec dni
@ IN SOA ns.przyklad.pl. admin.przyklad.pl. (1 10H 1H 3W 12H)
NS ns ; domyslnie przyklad.pl
NS ns.dodatkowy.pl. ; podrzedny serwer DNS

MX 1 poczta ; domyslnie poczta.przyklad.pl
MX 2 poczta.dodatkowy.pl. ; serwer zapasowy
ns A a.b.c.d ; definicja adresu hosta ns.przyklad.pl. zamiast a.b.c.d IP
poczta A a.b.c.d ; definicja adresu hosta poczta.przyklad.pl. zamiast a.b.c.d IP
MX 1 poczta ; rekord MX dla komputera poczta
MX 2 poczta.dodatkowy.pl.

www A a.b.c.d
MX 1 poczta
MX 2 poczta.dodatkowy.pl.

ftp A a.b.c.10 ; oczywiscie tutaj i ponizej zamiast a.b.c.d IP
user1 A a.b.c.11
user2 A a.b.c.12
user3 A a.b.c.13

; delegacja poddomeny o nazwie poddomena1
; bedzie obslugiwana przez hosta ns.poddomena1.przyklad.pl
poddomena1 NS ns.poddomena1
poddomena1 NS ns.dodatkowy.pl.
ns.poddomena1 A a.b.c.d ; zamiast a.b.c.d IP
```

A w pliku 127.0.0:

```
10 PTR ftp.przyklad.pl.
11 PTR user1.przyklad.pl.
12 PTR user2.przyklad.pl.
13 PTR user3.przyklad.pl.
```

Po każdorazowej zmianie w zbiorze named.conf oraz w plikach strefowych należy przeładować demona named, np. poleceniem:

```
/ścieżka/bind restart
```

Lub wysyłając sygnał HUP poleceniem:

```
kill -HUP 'cat /var/run/named.pid'
```

Uruchamiany jest poleceniem:

```
/ścieżka/bind start
```

Logi sa w np. /var/log/syslog. 
Diagnostyka: uruchomienie z opcją -d numer gdzie numer to liczba od 1 do 11, im większy tym większa szczegółowość diagnozy

```
kill -9 'cat /var/run/named.pid' /usr/sbin/named -d &lt;numer&gt; &
```

Testowanie serwera przy pomocy programu nslookup - przez wysyłanie zapytań do serwera tak jak to czyni resolver.

W celu zrzucenia bufora demona named do pliku named_dump.db należy skorzystać z polecenia:

```
kill -INT 'cat /var/run/named.pid'
```

To spowoduje powstanie pliku named_dump.db zawierającego pełną informację o danych znajdujących się w buforze. 

#### Administracja domen

Właścicielem domeny jest organizacja zarządzajaca jej dzierżawą (np. do pewnego czasu monopol na gTLD miał InterNIC - Internet Network Information Center), w każdym kraju istnieją jednostki zajmujące się rejestracją adresów w tzw. domenach narodowych, w Polsce jest to NASK (Naukowa i Akademicka Sieć Komputerowa). 
Domeny nie można kupić, można ją tylko wydzierżawić. 

Za każdą domenę odpowiada jakiś konkretny registrar, który ma obowiązek udostępnić usługę WHOIS. Rejestrując domenę trzeba wskazać IP maszyny

Prawni użytkownicy domen:
Rejestrator (_registrant_):
Nikt naprawdę nie posiada nazwy domenowej oprócz NIC (Network Information Centre) lub _domain name registry_. 
Większość NIC na świecie otrzymuje roczną opłatę od prawnego użytkownika za korzystanie z nazwy domenowej (jest to rodzaj umowy leasingowej), zależnie od konwencji nazewniczej registracji prawni użytkownicy są znani jako rejestratorzy lub jako właściciele domen (_registrants_ lub _domain holders_). 
ICANN utrzymuje kompletną listę rejestratorów domen (_domain registries_) na świecie. Można znaleźć użytkownika nazwy domenowej przeszukując bazę danych WHOIS utrzymywaną przez głównych rejestratorów. 
Dla większości z ponad 240 krajów rejestratorzy kodów krajów TLD (ccTLD) mają własne autorytatywne WHOIS (registrant, serwer nazw, data ekspiracji), dla przykładu: DENIC, niemieckie NIC ma autorytatywne WHOIS dla domeny .de. 
Jednakże niektórzy (np. VeriSign) używają modelu registry-registrar. Dla nazw domenowych .com i .net ma tylko podstawowy WHOIS (registrar i serwery nazw) a szczegółowy WHOIS można znaleźć u rejestratora. 
Od około 2001 większość gTLD registracji przyjęło tzw. gruby model rejestracji (_"thick" registry approach_) np. udostępniając autorytatywne WHOIS stref domenowych a nie rejestratorów. 

- Kontakt administracyjny
Rejestrator zwykle wyznacza kontakt administracyjny do zarządzania nazwą domenową, jego funkcje to (na przykład):
  - obowiązek dostosowania się do wymagań registracji domeny w celu zachowania prawa do użycia nazwy domenowej
  - aktualizacja fizycznego adresu, emaila i numeru telefonu w bazie WHOIS
- Kontakt techniczny
Zarządza serwerami nazw dla nzwy domenowej, jego funkcje to:
  - upewnienie się, że konfiguracja nazwy domenowej zgadza się z wymaganiami domain registry
  - auktualnienie strefy domenowej
  - zapewnienie funkcjonalności 24x7 serwerów nazw (od czego zależy dostępność nazwy domenowej)
- Kontakt bilingowy


Administracja DNS
DNS, jako system organizacyjny, składa się z dwóch instytucji - IANA i ICANN. Nadzorują one ogólne zasady przyznawania nazw domen i adresów IP. Jednak te dwie instytucje, nie są w stanie zajmować się całym światem i dlatego przekazują swoje uprawnienia na szereg lokalnych instytucji i firm. W wielu krajach domena internetowa przyznana przez system DNS staje się własnością, tego kto pierwszy ją kupi. W Polsce jest ona tylko wynajmowana na określony czas. Jeżeli ktoś zrezygnuje ze swojej popularnej domeny i zwróci ją administratorowi DNS, to może się spodziewać, że trafi ona w niepowołane ręce. 

Instytucje administrujące DNS na świecie:

- ICANN-IANA - nadzór ogólny nad nazewnictwem i strukturą domen "topowych" (.pl, .gov itp.)
- VeriSign Global Registry Services - rejestracja i nadzór nad domenami: .net, .org, .com
- Rząd USA - rejestracja i nadzór nad domenami - .mil i .gov
- NeuLevel - rejestracja i nadzór nad domeną - .biz
- SITA - rejestracja i nadzór nad domeną - .aero
- Afilias Limited - rejestracja i nadzór nad domeną - .info
- Global Name Registry - rejestracja i nadzór nad domeną - .name
- rządy poszczególnych krajów: rejestracja i nadzór nad domenami "krajowymi", np. *.pl. (zwykle rządy poszczególnych krajów przekazują ten nadzór wyspecjalizowanym instytucjom)

Instytucje administrujące DNS w Polsce
W Polsce dostęp do systemu DNS jest bardzo ograniczony. W większość krajów rejestracja domeny internetowej wiąże się z symbolicznymi opłatami. W Polsce koszty są bardzo wysokie, nawet na domenach niekomercyjnych. W efekcie Polska jest jednym z krajów rozwiniętych, który ma najmniej zarejestrowanych adresów DNS. Dodatkowo administrator DNS może odmówić rejestracji domeny, pod błahym pretekstem. 

Instytucje administrujące DNS:

- NASK - nadzór nad domeną .pl jako całością, oraz obsługa rejestrowania domen: .com.pl, .biz.pl, .org.pl, .net.pl oraz kilkudziesięciu innych domen "funkcjonalnych" kontrolowanych przez NASK (łącznie z np. sex.pl) oraz części domen lokalnych, np. .waw.pl
- IPPT PAN - rejestracja domeny .gov.pl
- ICM - .art.pl, .mbone.pl
- Fundacja Batorego - .ngo.pl
- TASK - .med.pl
- SGH - .irc.pl
- Politechnika Wrocławska - usenet.pl

Oprócz tego kilkaset domen typu nazwa-firmy.pl wykupiły od NASK-u rozmaite firmy i mają one prawo zarządzać tymi domenami we własnym zakresie. 
Dokładne informacje o rejestracji domen .pl znajdują się na stronie: [http://www.dns.org.pl/rejestracja-domen/](http://www.dns.org.pl/rejestracja-domen/)

### Adresowanie IP

Adresowanie IP

Adresy IP to unikalny w ramach danej sieci ciąg 32 bitów. Dla wygody podzielony jest na 4 bajty (lub używając pierwotnej, starszej terminologii: oktety; pojęcie bajtu pojawiło się później niż adresy IP). Wygląda to tak:

```
10101100 00011101 00100000 01000010
```

Zwykle zapisywany jest w dużo wygodniejszej formie dziesiętnej (tzw. format kropkowo-dziesiętny):

```
172.29.32.66
```

Czasem jest jeszcze używany zapis szesnastkowy (heksadecymalny):

```
Oxacld2042
```

Adres IP składa się z dwóch części:

- adres sieci - wskazuje na sieć, do której jest przypięty komputer, zawiera starsze bity, pierwsze z nich określają klasę sieci, w pierwotnej wersji był to pierwszy oktet, ale ponieważ szybko się okazało, że ARPANET połączy więcej niż 256 sieci wydzielono trzy klasy 32-bitowych adresów
  - Klasa A - pierwszy bit adresu jest równy 0, kolejne 7 określa sieć (identyfikator sieci), a pozostałe 24 adres komputera w tej sieci (deskryptor hosta); 0.b.c.d i 127.b.c.d są zastrzeżone: 0.0.0.0 oznacza tzw, drogę domyślną (default route) w konfiguracjach ruterów a każdy adres z 127. jest traktowany jako adres zwrotny (loopback address), pod tym adresem każdy komputer widzi samego siebie niezależnie od własnego adresu sieciowego (mechanizm loopback jest potrzebny do prawidłowej pracy oprogramowania sieciowego)
  - Klasa B - pierwsze bity to 10 (dwubitowy prefiks 10), kolejne 14 określa sieć (14-bitowy adres sieci), pozostałe 16 hosta (16-bitowy identyfikator hosta)
  - Klasa C - trzy pierwsze bity to 110 (trzybitowy prefiks 110), dalsze 21 to adres sieci, pozostałe 8 to komputer
- adres hosta - jest adresem komputera w obrębie powyższej sieci

adresy prywatne:
10.0.0.0 10.255.255.255
172.16.0.0 172.31.255.255
192.168.0.0 192.168.255.255
169.254.0.0 169.254.255.255
a 0.0.0.0 127.255.255.255
b 128.0.0.0 191.255.255.255
c 192.0.0.0 223.255.255.255

HMPTODO

| Klasa adresu | Początkowe bity | Zakres; przybliżony i dokładny | Część sieciowa / hostowa | Maksymalna liczba sieci / hostów w sieci | Adresy przeznaczone do użytku w sieciach prywatnych(mogą być używane bez zgody InterNIC)adresy prywatne - nierutowalne |
| --- | --- | --- | --- | --- | --- |
| Klasa A | 0... | 1 - 1261.0.0.0 - 126.0.0.0 | a / b.c.d | 126 / 16 777 214 | 10.0.0.0 - 10.255.255.255maska: 255.0.0.0 |
| Klasa B | 10... | 128 - 191128.0.0.0 - 191.255.255.255 | a.b / c.d | 16 384 / 65 534 | 172.16.0.0 - 172.31.255.255(14 bitów na adres sieci, 16 bitów na adres hosta)maska: 255.240.0.0 |
| Klasa C | 110.. | 192 - 223192.0.0.0 - 223.255.255.254 | a.b.c / d | 2 097 152 / 254 | 192.168.0.0 - 192.168.255.255maska: 255.255.0.0 |
| Klasa D | 1110... | 224 - 239224.0.0.0 - 239.255.255.255 | Adresy grupowe | | |
| Klasa E | 1111... | 240 - 254 | Zarezerwowane do badań, eksperymentów | | |

Adres hosta nie może składać sie z samych zer (0) i samych jedynek (255).

Zakresy adresów

- Klasa A: a.0.0.1 - a.255.255.255
- Klasa B: a.b.0.1 - a.b.255.254
- Klasa C: a.b.c.1 - a.b.c.254

Adresy grupowe (ang. _multicast addresses_) są częścią zarezerwowanego zakresu adresów (a=224-254). Służą do adresowania całej grupy hostów, tak jakby stanowiły jednostkę. Wykorzystuje się je do aplikacji (np. wideokonferencje) i przydziela tymczasowo. W przeciwieństwie do nich zwykłe adresy IP są czasami określane jako adresy indywidualne (ang. _unicast addresses_). 
Domyślna maska podsieci: 240.0.0.0; nie wprowadza się podziału na część sieciową i hostową.

Niektóre wartości bajtów adresu sieciowego mają specjalne znaczenie:

- Adres, którego część hostowa jest równa 0 (0 oznacza "ta sieć"), odwołuje się do samej sieci. Sieć 0.0.0.0 jest czasem wykorzystywana do odwoływania się do sieci lokalnej
- Adres 127.0.0.1 jest zawsze przypisywany interfejsowi pętli zwrotnej (ang. loopback). Reszta sieci 127.0 jest zarezerwowana.
- Adres, w którym wszystkie bity części hostowej są jedynkami (255), definiuje adres rozgłoszeniowy (ang. broadcast address) dla sieci: adres docelowy, którego komputer używa, gdy chce wysłać żądanie do każdego hosta w sieci lokalnej. burze broadcastowe sa zatrzymywane segmentacją sieci przez rutery, które uniemożliwiają ich przesyłanie
- 127 - końcówka zarezerwowana dla pętli, kiedy host odwołuje się do tego adresu dostaje odpowiedź od samego siebie

Maska podsieci jest 32-bitowym adresem, którego zadaniem jest oddzielić identyfikator sieci od identyfikatora hosta, ma umożliwić weryfikację czy docelowy adres znajduje się w tej samej sieci. 

Domyślne maski podsieci wyglądają tak: HMPTODO

| Klasa | Maska w postaci binarnej | Maska w postaci dziesiętnej |
| --- | --- | --- |
| Klasa A | 11111111 00000000 00000000 00000000 | 255.0.0.0 |
| Klasa B | 11111111 11111111 00000000 00000000 | 255.255.0.0 |
| Klasa C | 11111111 11111111 11111111 00000000 | 255.255.255.0 |

Przykładowo dla klasy A wygląda to tak:

```
bajt a.b.c. d
adres 121. 168. 100. 20
maska 255.0.0. 0
adres sieci 121.b.c. d
adres hosta a. 168. 100. 20
```

Jest to IP hosta o adresie 168.100.20 wpiętego do sieci o adresie 121. 
Tak duża sieć może zostać podzielona poprzez zmianę domyślnej maski 255.0.0.0 na np. 255.255.0.0. 

```
bajt a.b.c. d
adres 121. 168. 100. 20
maska podsieci255. 255.0. 0
adres sieci 121.b.c. d
adres podsiecia. 168.c. d
adres hosta a.b. 100. 20
```

W tym przypadku jest to host o adresie 100.20 wpięty do sieci o adresie 168 należącej do sieci 121

Istnieje możliwość podzielenia dostępnej dla danej sieci puli adresowej na podsieci przy użyciu tzw. maski podsieci. Jest zbudowana tak jak adres IP tylko, że składa się z samych jedynek i zer (wyrażając to w bajtach: 255 i 0) - jedynki wskazują na adres podsieci, zera na adres hosta w tej podsieci. 

```
128.17.75.20 - adres
255.255.255.0 - maska podsieci
128.17.75.0 - adres sieci
20 - adres hosta w tej sieci
```

Czyli zamiast hosta przyłączonego do sieci 187.17, który ma w niej adres 75.20 mamy host o adresie 20 w podsieci 75 w sieci 187.17.

Maska podsieci służy także do sprawdzania czy dany adres należy do tej samej podsieci. 
Sprawdzane jest to za pomocą operacji nazwanej ANDowaniem (od operatora logicznego AND; iloczyn logiczny). 
Przeprowadzane jest to w następujący sposób na posatci binarnej adresu. 

```
adres źródłowy 11000000 10101000 01100100 01000110
maska podsieci 11111111 11111111 11111111 00000000
wynik 11000000 10101000 01100100 00000000
```

Taka sama operacja dokonywana jest na adresie docelowym, jeśli ich wynik jest identyczny oznacza to, że oba adresy należą do tej samej sieci, jeśli się różnią pakiet wysyłany jest na domyślny adres rutera. 

Granice maski podsieci nie muszą przebiegać na końcach bajtów.

| Liczba zajętych bitów | Maska podsieci | Ilość sieci / hostów w podsieci |
| --- | --- | --- |
| Klasa A | | |
| 2 | 255.192.0.0 | 2 / 4 194 302 |
| 3 | 255.224.0.0 | 6 / 2 097 150 |
| 4 | 255.240.0.0 | 14 / 1 048 574 |
| 5 | 255.248.0.0 | 30 / 524 286 |
| 6 | 255.252.0.0 | 62 / 262 142 |
| 7 | 255.254.0.0 | 126 / 131 070 |
| 8 | 255.255.0.0 | 254 / 65 534 |
| Klasa B | | |
| 2 | 255.255.192.0 | 2 / 16 382 |
| 3 | 255.255.224.0 | 6 / 8 190 |
| 4 | 255.255.240.0 | 14 / 4 094 |
| 5 | 255.255.248.0 | 30 / 2 046 |
| 6 | 255.255.252.0 | 62 / 1 022 |
| 7 | 255.255.254.0 | 126 / 510 |
| 8 | 255.255.255.0 | 254 / 254 |
| Klasa C | | |
| 2 | 255.255.255.192 | 1-2 / 62 |
| 3 | 255.255.255.224 | 3-6 / 30 |
| 4 | 255.255.255.240 | 7-14 / 14 |
| 5 | 255.255.255.248 | 15-30 / 6 |
| 6 | 255.255.255.252 | 31-62 / 2 |

#### CIDR (Classless InterDomain Routing), supernetting

##### Wprowadzenie CIDR

Adres IP jest podzielony na dwie części: adres sieci (który identyfikuje sieć i podsieć) i adres hosta (który identyfikuje połączenie lub interfejs seciowy konkretnej maszyny w tej sieci), ten podział jest używany do kontrolowania jak ruch jest rutowany w i przez sieci IP. 
Historycznie adres IP był podzielony na trzy główne klasy sieci, gdzie każda klasa miała określoną wielkość sieci, klasa a więc długość maski podsieci i liczba hostów w sieci była określona przez najbardziej znaczące bity w adresie IP. Bez żadnego innego sposobu określnia długości podmaski protokoły rutingu musiały używać klasy adresu IP określonego w ogłoszeniach rutingu (route advertisements) by wyznaczyć wielkość rutującego prefixu do ustawienia w tablicach rutingu. 

Wprowadzony w 1993 CIDR jest usprawnieniem sposobu interpretacji adresu IP, zamienił poprzednią generację składni adresów IP: sieci klasowych (classful networks). Pozwoliło to zwiększyć elastyczność dzielenia zakresów adresów IP pomiędzy oddzielne sieci; zalety:

- Wydajniejsze wykorzystanie adresów IPv4
- Grupowanie prefiksów - co obniża przeciążenie rutingu

Ponieważ duża część adresów klasy A i B nie zostaje wykorzystana, niewiele organizacji, którym przydzielono te klasy potrzebuje milionów adresów. Zasada działania techniki CIDR polega na tym, że zamiast pełnej klasy A czy B przyznaje się ciągły blok adresów klasy C o wspólnych najbardziej znaczących bitach określających podsieć, przy czym najmniej znaczące bity adresu sieci przydzielane są na potrzeby identyfikacji hosta. 
I tak przykładowo wykorzystując trzy kolejne klasy C od 192.199.199.5 do 192.199.199.7 otrzymujemy podsieć o pojemności 768 adresów określaną maską 255.255.252.0 - wspólne 22 najstarsze bity adresu. 
Jednak technikę tę można zastosować tylko dla co najwyżej kilku tysięcy adresów (trudno znaleźć większy blok wolnych adresów) a wszystkie urządzenia w tej sieci muszą obsługiwać tą technikę. 

Umożliwia jednostkom które wystąpiły o adres klasy B przydzielenie ciągu klasy C. 

##### CIDR i maski

Maska podsieci jest maską bitową która pokazuje gdzie się kończy adres sieci a gdzie zaczyna adres hosta. CIDR używa zmiennej długości maski podsieci (VLSM - variable length subnet masks), żeby alokować adres IP do podsieci zgodnie z potrzebami raczej niż z jakąś ogólną dla całej sieci zasadą, tak więc podział na część sieciową i hostową może wypaść na każdej granicy bitów w adresie, proces może być rekursywny, z częścią przestrzeni adresowej będącą dalej dzieloną na mniejsze części, poprzez użycie masek zakrywających więcej bitów. 
Ponieważ podział na normalne klasy jest pomijany, ten system nazywany jest bezklasowym i dlatego poprzedni system został nazwany, przez analogię rutowaniem klasowym (_classful routing_). 
Adresy sieci CIDR/VLSM są teraz używane zarówno w publicznym internecie jak i w dużych sieciach prywatnych, ale w przeciętnej wielkości sieci LAN raczej używa się specjalnych prywatnych adresów określonych przez RFC 1918. 

Inną zaletą CIDR jest możliwość agregacji prefiksów (_prefix aggregation_), np. 16 ciągłych /24 sieci może być połączonych razem i ogłoszonych zewnętrznemu światu jako pojedyncza /20 droga (route) (jeśli pierwszych 20 bitów ich sieci pasuje), dwie ciągłe /20 mogą być połączone w jedną /19 itd. To pozwala na znaczącą redukcję w liczbie rutowań, które muszą być ogłoszone w sieci, zabezpieczając przed "eksplozją tablicy rutowań" co przeciażyłoby rutery i zatrzymało rozwój internetu. 
Obecnie większość publicznego internetu nie rutuje niczego dłuższego niż prefix /19, efektywnie zabezpieczając małe sieci od wychodzenia poza agregator rutingu taki jak ISP. 

##### Zapis CIDR

Standardowy zapis zasięgu adresów CIDR zaczyna się od adresu sieci dopełnionego w prawo właściwą liczbą bitów zero - do 4 oktetów dla IPv4 i do 18 heksadecymalnych pól dla IPv6) potem jest znak slasza "/" i długość prefiksu w bitach, definująca długość maski podsieci, określającej rozmiar sieci. 
Na przykład:

- 192.168.0.0 /24 reprezentuje 256 adresów IPv4 od 192.168.0.0 do 192.168.0.255 włącznie, z 192.168.0.255 jako adresem rozgłoszeniowym (broadcast) dla sieci.
- 192.168.0.0 /22 reprezentuje 1024 adresów IPv4 od 192.168.0.0 do 192.168.3.255 włącznie, z 192.168.3.255 jako adresem rozgłoszeniowym (broadcast) dla sieci.
- 2002:C0A8::/48 reprezentuje adresy IPv6 od 2002:C0A8:0:0:0:0:0:0 do 2002:C0A8:0:FFFF:FFFF:FFFF:FFFF:FFFF, włącznie.

Dla IPv4 alternatywna reprezentacja używa adresów sieci po których jest maska podsieci zapisana w kropowo-dziesiętnym formacie:

- 192.168.0.0 /24 może być zapisane jako 192.168.0.0 255.255.255.0
- 192.168.0.0 /22 może być zapisane jako 192.168.0.0 255.255.252.0

Zakresy adresów w podsieci są najcześciej określane za pomocą notacji CIDR:

192.168.249.42/23 oznacza, że adresy IP w tej podsieci muszą mieć pierwsze 23 bity takie same jak w adresie 192.168.249.42 - który ma reprezentację dwójkową:

```
11000000 101010000 11111001 00101010
```

zatem każdy host z pierwszymi 23 bitami jak w powyższej masce należy do sieci, czyli zakres obejmuje od

```
11000000 101010000 11111000 00000000 - 192.168.248.0
```

do

```
11000000 101010000 11111001 11111111 - 192.168.249.255
```

podobnie podsieć 192.168.249.42/29 obejmuje adresy od 192.168.249.40 do 192.168.249.47

#### NAT (Network Address Translation), network masquerading, IP-masquerading

Technika translacji adresów sieciowych. 
Wraz ze wzrostem ilości komputerów w Internecie, zaczęła zbliżać się groźba wyczerpania puli dostępnych adresów internetowych IPv4. 
Aby temu zaradzić, lokalne sieci komputerowe, korzystające z tzw. adresów prywatnych (specjalna pula adresów tylko dla sieci lokalnych), mogą zostać podłączone do internetu przez jeden komputer (lub router), posiadający mniej adresów internetowych niż komputerów w tej sieci. 
Router ten, gdy komputery z sieci lokalnej komunikują się ze światem, dynamicznie tłumaczy adresy prywatne na adresy zewnętrzne, umożliwiając użytkowanie Internetu przez większą liczbę komputerów niż posiadana liczba adresów zewnętrznych. 

NAT stał się popularny jako sposób radzenia sobie z brakiem adresów IPv4 i żeby uniknąc trudności związanych z rezerwowaniem adresów IP. Użycie NAT stało się szczególnie popularne w krajach innych niż USA, gdzie z historycznych powodów zostało już niewiele bloków adresowych per capita. Jest właściwie standardową właściwością w ruterach domowych i dla małych biur. 

Adresy IP źródłowy i/lub przeznaczenia pakietów są przepisywane kiedy przechodzą przez ruter lub firewall, najczęściej w celu umożliwienia wielu hostom z prywatnej sieci dostępu do internetu przy użyciu pojedynczego publicznego adresu IP. Zgodnie ze specyfikacją rutery nie powinny postępować w ten sposób, ale jest to powszechnie stosowana i popularna technika. Niestety NAT wprowadza komplikacje w komunikację pomiedzy hostami. 

Polega na zastosowaniu w sieci wewnętrznej odmiennej puli adresów niż te które są wykorzystywane do komunikacji z resztą internetu. W tym celu niezbędny jest serwer, który dokona konwersji adresów internetowych na właściwe adresy używane do komunikacji zewnętrznej. 

Mechanizm NAT tłumaczy (multipleksuje czyli przełącza) adresy prywatne na publiczne wykorzystując mechanizm portów, komputer pełniący rolę bramy udostępnia na żądanie maszyny z sieci lokalnej własne porty TCP/IP modyfikując odpowiednio nagłowki wysyłanych przez nie pakietów, zmieniany jest adres (a czasem i port) źródłowy. Od strony internetu widziany jest tylko ruter, jest to nazywane overloadingiem (najpopularniejszy sposób implementacji NAT) bo adres publiczny jest przeciążany. 
Aby przesłać pakiety dalej ruter dokonujący translacji korzysta ze specjalnej tabeli kojarzącej adresy portów TCP/IP rutera na adresy prywatne komputerów w sieci lokalnej. Tabela ta może być statyczna (ustalona przez administratora) lub dynamiczna (tworzona przez ruter w trakcie pracy), na jej podstawie przeprowadzana jest operacja odwrotna adresy docelowe są zmieniane tak, żeby dane docierały do maszyn lokalnych

W typowej konfiguracjil lokalna sieć używa jednego z zarezerwowanych prywatnych podsieci (takich jak 192.168.x.x lub 10.x.x.x) i ruter tej sieci ma prywatny adres (taki jak 192.168.0.1) w tej przestrzeni adresowej. Jest również połączony z internetem pojedynczym adresem IP przydzielonym przez ISP. Kiedy ruch idzie z prywatnej sieci do internetu, źródłowe adresy pakietu są tłumaczone w locie z prywatnych adresów na publiczne, ruter śledzi podstawowe dane o każdym aktywnym połączeniu (szczególnie o adresie i porcie przeznaczenia). Kiedy odpowiedź wraca do rutera, te dane o połączeniu przechowane podczas wysyłania (outbound phase) służą do określenia, w które miejsce w wewnętrznej sieci przekazać odpowiedź. Dla systemu w internecie ruter pojawia się jako źródło/przeznaczenie tego ruchu. 

Nawet pełna klasa adresów C przydzielona komputerom w sieci wewnętrznej może być widziana od strony internetu jako jeden adres IP. Same adresy wewnętrzne nie muszą spełniać wymogu niepowtarzalności w skali całego internetu, gdyż pakiety z sieci wewnęrznej nigdy nie są przez mechanizm NAT wysyłane bezpośrednio do adresata. Dodatkowo można wykorzystać specjalne klasy zalecanych adresów intranetowych - pochodzące z tych adresów pakiety są blokowane przez rutery obsługujące ruch w internecie, co zabezpiecza przed kolizjami pomiędzy sieciami intranetowymi wykorzystującymi te same klasy adresowe. 

NAT jest też wykorzystywany do prostej i skutecznej dystrybucji ruchu TCP/IP w sieci lokalnej, jeśli kilka maszyn ma być widzianych pod jednym adresem (dla rozłożenia obciążenia), stosuje się wtedy mechanizm odwrotny tzw. DNAT (Destination NAT) w pakiecie incjującym połączenie zmienia się adres docelowy a nie źródłowy

Zalety:
Brak bezpośredniego połączenia może być czasem korzyścią, a nie wadą.
NAT jest często stosowany w sieciach korporacyjnych (w połączeniu z proxy) oraz sieciach osiedlowych. 
Zaletą takiego systemu jest większe bezpieczeństwo komputerów znajdujących się za NAT-em. 
Powodem zastosowania NAT jest bezpieczeństwo, ponieważ wszystkie interfejsy sieciowe są widoczne na zewnątrz jak jeden adres o wiele trudniej przeprowadzić skanowanie i atak, trudne jest ustalenie topologii sieci i zaatakowanie konkretnej maszyny. To utrudnienie wrogiej aktywności zabezpiecza prywatność i często stosowane jest jako metoda ochronna. 

Z korzystaniem z Internetu poprzez NAT wiążą się wady:

- Hosty za używającym NAT-u ruterem nie mają prawdziwej łączności end-to-end i nie mogą brać udziału w niektórych protokołach internetowych. Usługi wymagające inicjacji połączenia z zewnętrznej sieci lub bezstanowe protokoły takie jak te, które używają UDP mogą być przerywane. O ile ruter NAT nie zostanie specjalnie skonfigurowany, żeby wspierać takie protokoły przychodzące pakiety nie będą mogły dotrzeć od celu, niektóre protokoły są w stanie przystosować jedną instancję NAT-u pomiędzy hostami (np. tryb pasywny w FTP), czasem z pomocą Application Layer Gateway, ale zawodzą kiedy oba komputery są za NAT-em. Także komplikuje protokoły bezpieczeństwa takie jak IPSec (fragmenty pakietów zamieniane przez NAT są zaszyfrowane więc translacja adresów jest niemożliwa) i utrudnia korzystanie z P2P i bezpośredniego wysyłania plików. 
Translacja powoduje, że niektóre aplikacje nie będą prawidłowo działać, gdyż serwer danej usługi wstawia adres odbiorcy do danych pakietu (a więc w tym przypadku adres serwera NAT a nie rzeczywistego odbiorcy pakietu) a tego serwer NAT nie jest w stanie zmienić.
- Połączenia end-to-end były podstawową zasadą internetu, wspieraną dla przykładu przez IAB i dlatego niektórzy uważają NAT za uszczerbek dla internetu. Niektórzy ISP przydzielają klientom tylko lokalny IP i łączą ich z internetem przez NAT, powstaje wtedy pytanie czy rzeczywiście można to nazwać usługą internetową.
- Niestety sposób działania niektórych protokołów uniemożliwia prostą translację adresów, np. aktywne FTP jest niemożliwe bo wtedy klient nawiązuje połączenie i wskazuje prywatny adres i port, który jest niezgodny z NATem, jedynym wyjściem jest skorzystanie z trybu pasywnego gdzie to serwer nakazuje klientowi połączenie z odpowiednim adresem/portem i pobieranie danych
- Trudności sprawiają również PING, IRC i ICQ.
- Utrudnione jest również udostępnienie jakiejkolwiek usługi (np. serwera) na maszynie za NATem, bo bedzie widoczna tylko w sieci lokalnej, rozwiązaniem tego problemu jest mechanizm przekazywania adresów IP (IP forwarding), który polega na statycznym ustawieniu translacji określonego portu rutera na adres /port komputera w sieci lokalnej.
- Obniża wydajność sieci, gdyż każdy przesyłany pakiet danych musi zostać przeanalizowany a następnie przekierowany do właściwego odbiorcy.

Czasem w celu rozwiązania problemu można nagiąć reguły translacji adresów używając IPautofw, ale ostrożnie bo może to narazić politykę bezpieczeństwa. 

Inne przykłady użycia

- Zarządzanie ruchem (Load Balancing): docelowy NAT może przekierować połączenia wskazujące na określony serwer na przypadkowo wybrane serwery.
- Serwis rezerwowy (Fail over): docelowy NAT może być użyty do ustawienia usługi wymagającej wysokiej dostępności, jeśli system zawiera krytyczny serwer dostępny przez ruter, który wykryje, że ten serwer przestał działać, może użyć przeznaczenia NAT do przekierowania ruchu na zastępczy serwer (_backup server_).
- Przezroczyste proxy (Transparent proxying): NAT może przekierować połączenia HTTP skierowane w internet na specjalne HTTP proxy które może buforować zawartość i filtrować zapytania, niektórzy ISP używają tej techniki do zmiejszenia ruchu bez wymagania od swoich użytkowników by skonfigurowali swoje przeglądarki do użycia proxy.

Można wyróżnić 2 podstawowe typy NAT:

- SNAT (Source Network Address Translation) to technika polegająca na zmianie adresu źródłowego pakietu IP na jakiś inny. Stosowana często w przypadku podłączenia sieci dysponującej adresami prywatnymi do sieci Internet. Wtedy router, przez którego podłączono sieć, podmienia adres źródłowy prywatny na adres publiczny (najczęściej swój własny). 
Szczególnym przypadkiem SNAT jest maskarada mająca miejsce, gdy router ma zmienny adres IP (np. otrzymuje go w przypadku połączenia modemowego wdzwanianego). Wtedy router zmienia adres źródłowy na taki, jak adres interfejsu, przez który pakiet opuszcza router. 
- DNAT (Destination Network Address Translation) to technika polegająca na zmianie adresu docelowego pakietu IP na jakiś inny. Stosowana często w przypadku, gdy serwer mający być dostępny z Internetu ma tylko adres prywatny. W tym przypadku router dokonuje translacji adresu docelowego pakietów IP z Internetu na adres tego serwera.

Funkcje NAT definiowane są za pomocą programów iptables lub ipchains. 

Basic NAT vs port number translation
Istnieją dwa rodzaje translacji adresów, typ często nazywany NAT (czasem także NAPT "Network Address Port Translation") odnosi się do sieci, które używają mapowania numerów portów co pozwala wielu maszynom mieć ten sam IP. 
Inne - technicznie prostsze - zwane NAT lub "basic NAT" albo "static NAT" używają tylko translacji adresów a nie portów, wymaga to zewnętrznego adresu IP dla każdego równoczesnego połączenia. 
Szerokopasmowe rutery używają często tego trybu pracy, czasem określanej "DMZ host", aby pozwolić wyznaczonemu komputerowi na akceptowanie wszystkich zewnętrznych połączeń również jeśli sam ruter używa jedynego dostępnego zewnętrznego adresu IP. 
NAT z translacją portów ma dwa podtypy: translacja źródłowego adresu (źródłowy NAT) który przepisuje adres IP komputera inicjującego połączenie i przeciwieństwo: translacja adresu docelowego (docelowy NAT). W praktyce oba są używane równolegle w komunikacji dwukierunkowej. 

Bramki warstwy aplikacji (application layer gateways). 
Niektóre protokoły wysokiego poziomu (jak FTP, Quake i SIP) wysyłają informacje 3 warstwy wewnątrz danych (payloads) datagramu IP. FTP w trybie aktywnym używa innych portów dla kontroli ruchu (polecenia) a ruchu danych (transfer plików), kiedy żąda tansferu plików host określa także port na który chciałby otrzymać dane, jednakże jeśli jest za NAT-em mapowanie portów powoduje wysłanie nieprawdziwej informacji. 
Rozwiązaniem tego problemu jest ALG (Application Layer Gateway), moduł softwarowy działajacy na firewallu NAT. Uaktualnia informacje z zawartości pakietów (payload), i zamienia nieprawidłowe usuwajac skutki translacji adresów, oczywiście musi rozumieć protokoły wyższego rzędu, które naprawia i każdy protokół sprawiający te problemy potrzebuje oddzielnego ALG. 
Większość protokołów wyższego rzędu nie wysyła informacji kontaktowych w trzeciej warstwie i nie potrzebuje ALG. 

Różne typy NAT

- Full cone NAT
- Restricted cone NAT
- Port restricted cone NAT
- Symmetric NAT (aka Bi-directional NAT)

#### DHCP (Dynamic Host Configuration Protocol)

Protokół komunikacyjny sieci klient-serwer, umożliwiający komputerom uzyskanie od serwera danych konfiguracyjnych, np. adresu IP hosta, adresu IP bramy sieciowej, adresu serwera DNS, maski sieci. 
Protokół DHCP jest zdefiniowany w RFC 2131 i jest następcą BOOTP. DHCP został opublikowany jako standard w październiku 1993 - ostatnią definicją jest RFC 2131 z marca 1997. 
W kolejnej generacji protokołu IP czyli IPv6 jako integralną część dodano nową wersję DHCP czyli DHCPv6. Jego specyfikacja została opisana w opublikowanym w lipcu 2003 RFC 3315. 

Przydzielanie adresów IP
Protokół DHCP opisuje trzy techniki przydzielania adresów IP:

- Przydzielanie ręczne oparte na tablicy adresów MAC oraz odpowiednich dla nich adresów IP. Jest ona tworzona przez administratora serwera DHCP. W takiej sytuacji prawo do pracy w sieci mają tylko komputery zarejestrowane wcześniej przez obsługę systemu. Tylko zapytanie klienta z adresem MAC umieszczonym na liście da adres IP zgodny z tablicą.
- Przydzielanie automatyczne, gdzie wolne adresy IP z zakresu ustalonego przez administratora są na stałe przydzielane kolejnym zgłaszającym się po nie klientom.
- Przydzielanie dynamiczne, pozwalające na ponowne użycie adresów IP. Administrator sieci nadaje zakres adresów IP do rozdzielenia. Wszyscy klienci mają tak skonfigurowane systemy, że po starcie interfejsów sieciowych automatycznie pobierają swoje adresy. Każdy adres przydzielany jest na pewien okres czasu (dzierżawa z kontrolowanym czasem przydzielenia). Taka konfiguracja powoduje, że zwykły użytkownik ma ułatwioną pracę z siecią.

Niektóre serwery DHCP dodatkowo przydzielają każdemu klientowi własny adres DNS, przekazywany na serwer nazw protokołem zgodnym ze specyfikacją RFC 2136. 

Parametry konfiguracji przekazywane do klienta
Serwer DHCP może dostarczać swoim klientom dodatkowe dane pozwalające na konfigurację sieci. Zostały one opisane w specyfikacji RFC 2132. 
Lista konfigurowalnych opcji:

- adresy IP serwerów DNS
- nazwa DNS
- adres IP bramy sieciowej (gateway)
- adres rozgłoszeniowy (broadcast)
- maska podsieci
- maksymalny czas oczekiwania na odpowiedź (timeout) bufora ARP
- MTU interfejsu (maksymalny rozmiar pakietu)
- NIS lub NIS+ serwerów
- NIS lub NIS+ domeny
- adres serwera NTP
- adres serwera SMTP
- adres serwera TFTP
- adres serwera nazw WINS
- adres serwera nazw Netbios

Najpopularniejsze serwery DHCP Fundacja Internet Software Consortium opracowała serwer DHCP w wersji 1.0.0. dla systemów Unix. ISC DHCP został wydany 6 grudnia 1997 roku, a w 1999 pojawiła się wersja 2.0 bardziej zgodna ze specyfikacją. Serwer ten jest dostępny na stronie: [www.isc.org/sw/dhcp/](http://www.isc.org/sw/dhcp/)

DHCP oraz PPP
Połączenie pomiędzy dostawcą Internetu (ISP) oraz klientem jest najczęściej realizowane poprzez protokół PPP. Jego częścią jest protokół IPCP, który pozwala na ustalenie adresów IP przydzielonych dla lokalnego komputera widocznego w sieci światowej oraz obsługującego go rutera dostawcy. Informacje te nie wystarczą do pełnej konfiguracji klienta. Aby automatycznie pobrać adresy serwerów DNS oraz inne dodatkowe dane konieczne jest wykorzystanie protokołu DHPC. Protokół PPP tworzy wirtualną podsieć, w której można przesyłać komunikaty DHCP. W ten sposób klient uzyskuje dodatkowe informacje niezbędne do automatycznej konfiguracji. 

Niektóre implementacje serwerów DHCP mogą uaktualniać nazwy DNS hostów klienckich, by odzwierciedlić nowy adres IP w sposób określony przez protokół uaktualniania DNS który został określony w RFC 2136. 

Parametry konfiguracji klienta
Serwer DHCP może zapewnić opcjonalną konfigurację dla klienta - jest to określone w RFC 2132

Implementacje
Internet Software Consortium opublikowało oprogramowanie DHCP dla systemów uniksowych wersją 1.0.0 ISC DHCP Server (6 grudnia 1997) i bardziej zgodną z RFC wersję 2.0 (22 czerwca, 1999). [http://www.isc.org/sw/dhcp/](http://www.isc.org/sw/dhcp/)

Anatomia protokołu
DHCP używa tych samych dwóch przydzielonych przez IANA portów dla BOOTP: 67/UDP dla serwera i 68/UDP dla klienta. 

##### Poszukiwanie serwera DHCP (DHCP Discover)

Klient chcący się połączyć z serwerem wysyła do sieci lokalnej pakiety zaadresowane do wszystkich odbiorników. Rozgłasza na lokalnej fizycznej podsieci, zeby znależć jakiś dostępny serwer. Lokalny ruter może być skonfigurowany by przekazać pakiet DHCP do serwera DHCP w innej podsieci. Ta implementacja klienta tworzy pakiet UDP z rozgłoszeniowym celem 255.255.255.255 i zawierają prośbę o ostatnio używany adres IP (np. 192.168.1.100). Może ona zostać zignorowana przez serwer. 

##### Oferta DHCP (DHCP Offer)

Jest składana przez serwer, który określa konfigurację klienta na podstawie sprzętowego adresu urządzenia sieciowego określonego w polu CHADDR (w sieci lokalnej to adres MAC). W polu YIADDR serwer przekazuje klientowi jego adres IP. 

##### Żądanie DHCP (DHCP Request)

Jest wysyłane przez klienta, który już rozpoznał serwer DHCP, ale chce uzyskać inne parametry konfiguracji. Dla przykładu może ponownie zażądać adresu IP 192.168.1.100. 

##### Potwierdzenie DHCP (DHCP Acknowledge)

Jest wysyłane, jako potwierdzająca odpowiedź na żądanie i rozgłaszane w lokalnej sieci. Zakłada się, że reakcją klienta na potwierdzenie będzie odpowiednie skonfigurowanie interfejsu sieciowego zgodnie z przydzielonymi opcjami. 

Ponieważ część komputerów w sieci jest odłączona, bądź nie korzysta z protokołu TCP/IP serwer DHCP przydziela hostowi adres IP dopiero na żądanie. Jeśli komputer któremu przydzielono adres przez dłuższy czas nie korzysta z protokołu TCP/IP adres jest zwalniany i ponownie przekazywany do wykorzystania przez inne komputery.

#### Ruting

Internet nie ma struktury hierarchicznej, jest to kłębowisko kabli a adres IP nie ma nic wspólnego z położeniem komputera w tej sieci. 
Hosty łączące podsieci to gateway, ruter - jest to albo wyspecjalizowana maszyna albo oddzielny komputer z demonem rutingu (BIND). 

Ruting (trasowanie, routing) to wyznaczanie trasy dla pakietu danych w sieci komputerowej, a następnie wysłanie go tą trasą, czyli przekazywanie pakietów między sieciami. Odbywa się za pośrednictwem bramek (ang. gateway) łączących te sieci. Wyspecjalizowane urządzenia służące do tego celu to rutery (ang. router). 

Routing ma na celu możliwie najlepiej (optymalnie) dostarczyć pakiet do celu. Pierwotnie jedynym kryterium wyboru było podanie jak najkrótszej trasy do celu, ale obecnie protokoły routingu mogą uwzględniać podczas wyboru trasy również takie parametry jak priorytet pakietu (standardy ToS/DSCP), natężenie ruchu w poszczególnych segmentach sieci itp. W przypadku routingu brzegowego (wykorzystującego BGP) w Internecie wybór trasy jest silnie związany z polityką poszczególnych dostawców (i zawartymi między nimi umowami o wymianie ruchu) i bywa daleki od optymalnego.

Pakiety przesyłane przez sieć opatrzone są adresem nadawcy i odbiorcy. Zadaniem routerów, jako węzłów pośrednich między nadawcą a odbiorcą, jest przesłanie pakietów do celu po jak najlepszej ścieżce. Typowy router bierze pod uwagę tylko informacje z nagłówka IP, czyli sprawdza tylko informacje z warstwy sieci (trzeciej) modelu OSI. Obowiązkiem routera IP przy przekazywaniu pakietu dalej do celu jest obniżenie o jeden wartości TTL (Time To Live, czas życia). Datagram IP, który trafia do routera z wartością 1 w polu TTL zostanie utracony, a do źródła router odsyła datagram ICMP z kodem TTL Exceeded.

Bezpośrednia komunikacja pomiędzy komputerami możliwa jest tylko w obrębie tej samej podsieci. Jeśli pierwsza część docelowego adresu różni się od źródłowego trzeba skorzystać z rutera. 
Sprawdza się to przez nałożenie maski podsieci na adres docelowy i źródłowy i jeśli efekt nie jest ten sam - należą do różnych sieci. 

Każdy pakiet niepasujący do wysyłany jest do rutera, który kieruje go na domyślny adres w tablicy rutingu. Czyli jeśli w konfiguracji IP wpisze się źle ruter komunikacja będzie możliwa tylko w obrębie danej podsieci. 
Ruter po odebraniu przesyłki sprawdza do jakiej sieci jest ona przeznaczona, a następnie jeśli do takiej jest podłączony przesyła ją tam, jeśli nie wysyła ją do następnego rutera. 
Używając własnych protokołów rutery budują tablice routingu, będące czymś w rodzaju mapy sieciowej. Pozwala to skierować pakiety we właściwym kierunku. Rutery nie mają informacji o samym adresie docelowym a jedynie o innych ruterach, które być może będą wiedziały coś więcej. 
Za pomocą protokołów rutery wywołują się wzajemnie, sprawdzając czy sąsiednie rutery działają. W ten sposób internet samoczynnie się konfiguruje. Nie można przewidzieć, którą drogą pakiet dotrze do adresata, może się również zdarzyć, że pakiety należące do tej samej wiadomości zostaną dostarczone różnymi trasami i dotrą tam w innej kolejności niż zostały nadane. 
Przyczyną zatorów nie zawsze jest awaria łącza lub rutera. Może się zdarzyć, że następny komputer nie jest w stanie odebrać pełnego strumienia informacji, wtedy komputer węzłowy może zadecydować o przesłaniu jedynie części pakietu, po prostu dzieli pakiet na mniejsze, łatwiejsze do transmisji częsci, które jak normalne pakiety są wysyłane dalej. 
W nagłówku pakietu IP jest pole TTL (Time To Live) określające ilość skoków (hops) jakie może wykonać pakiet. Parametr ten pełni rolę licznika, któremu nadawca przypisuje pewną określoną wartość początkową, a każdy ruter przed wysłaniem pakietu dalej zmniejsza jego stan o jeden. Ruter, który sprowadzi licznik do zera unieważnia pakiet i wysyła informację zwrotną do nadawcy. Zostało to wykorzystane w programie traceroute, który wysyła serię pakietów z TTL ustawionym kolejno na 1, 2, 3, .... 

Routery utrzymują tablice routingu, na podstawie których kierują pakiety od określonych nadawców do odbiorców, bądź kolejnych routerów. Tablica może być budowana statycznie (routing statyczny) lub dynamicznie (protokoły routingu dynamicznego, takie jak RIP, IGRP, EIGRP, OSPF, BGP, IS-IS).

Popularnym algorytmem służącym do wyznaczania tras w sieciach wewnętrznych jest algorytm Dijkstry wyznaczania najkrótszej ścieżki w grafie (np. OSPF). HMPTODO

- ruting statyczny - przez zdefiniowanie tablic rutingu; niezbyt skomplikowana (dla prostych sieci) ale żmudna praca, którą trzeba ponawiać po każdej zmianie w sieci i jeśli sieć urośnie ciężko ustrzec się od błędów
- ruting dynamiczny - ponieważ sam algorytm wyznaczania rutingu nie jest zbyt skomplikowany, rutery same mogą się orientować w topologii sieci i ustalać między sobą zasady optymalnych połączeń; powinny też zauważać zmiany w topologii sieci (np. awarie) i automatycznie się do nich dostosowywać; to nie tylko odciąża pracę administratora, ale umożliwia również autokonfiguracjię w razie awarii; pewną wadą jest dodatkowy ruch ale są pod tym względem optymalizowane i w większych sieciach ich używanie jest uzasadnione
protokoły rutingu dynamicznego:
  - wewnętrzne _Interior Gateway Protocols_ - służą do wyznaczania dróg pakietów w ramach systemu autonomicznego (grupy sieci znajdujących się pod wspólną administracją)
  - zewnętrzne _Exterior Gateway Protocols_ - do rutingu pomiędzy systemami autonomicznymi; np. BGP (_Border Gateway Protocol_) lub EGP (_Exterior Gateway Protocol_)
ze względu na sposób działania dzielą się na:
  - protokoły stanu łącz (_link state protocol_) - rutery stale tesują stan przyłączonych sieci, a listę wszystkich swoich sprawnych łącz (LSA - _Link State Adverisement_) wysyłają do swoich sąsiadów, którzy przesyłają je dalej, w ten sposób w całej sieci rozchodzi się informacja o łączach w otoczeniu każdego rutera, na podstawie otrzymanych LSA każdy ruter buduje tablicę stanu łącz (_Link State Database_), która zawiera obraz całej sieci, według niego ruter buduje drzewo najkrótszych połączeń między sieciami i te połączenia są następnie umieszczane w tablicy rutingu; przykładem protokołu stanu łącz jest OSPF (_Open Shortest Path First_ - nazwa pochodzi od algorytmu Dijkstry zastosownego do wyznaczania optymalnego drzewa połączeń)
    1. wysłanie komunikatu "hello" do wszystkich bezpośrednich sąsiadów
    2. rozsyłanie pakietów LSA na wszystkich interfejsach
    3. wyznaczanie drzewa połączeń przy użyciu algorytmu Dijkstrynowo włączony ruter na pakiet "hello" otrzymuje w odpowiedzi aktualną tablicę stanu łącz swojego sąsiada, dzięki temu może szybko zbudować poprawną tablicę rutingu
  - protokoły z wektorem odległości (_distance vector protocols_) - wymiana informacji nie tylko o bezpośrednio dostępnych łączach rutera ale też o wszystkich znanych mu sieciach, ale informacje te przesyłane są nie do wszystkich hostów w danej sieci a tylko do sąsiadów; na tej podstawie uaktualniają oni swoje tablice rutingu (umieszczają w nich sieci o których istnieniu dotąd nie wiedzieli) i swoją tablicę rutingu przesyłają swoim bezpośrednim sąsiadom, w ten sposób buduje się obraz sieci; w porównaniu do protokołów stanu łącz pakiety wymieniane między ruterami są większe, ale krąży ich mniej; w tablicach rutingu każdej sieci przypisana jest, oprócz sposobu dotarcia do niej - jej metryka to znaczy miara odległości do tej sieci, miara kosztu i czasu dostarczenia do niej pakietu, metryka ta jest wykorzystywana przy wybieraniu najkorzystniejszej trasy pakietu, ruter, który otrzyma dwie tablice z rozmaitymi metrykami danej sieci za bardziej wiarygodne uzna informacje o mniejszej metryce czyli od rutera, który ma do danej sieci bliżej;
przykładowe protokoły z wektorem odległości:
    - RIP (_Routing Information Protocol_) - stary i dość prymitywny; ruter rozgłasza tablice co 30 s, jeśli przerwa wynosi 180 s sąsiednie rutery oznaczają ścieżki przez niego przysłane jako nieużyteczne a po 120 sekundach usuwają te ścieżki z tablic; jako metryka używana jest liczba przeskoków między sieciami (hop counting), dla bezpośrednio przyłączonych sieci wynosi 0, maksymalna wartość to 15, 16 oznacza sieci niedostępne
    - IGRP (_Interior Gateway Routing Protocol_) - dużo bardziej zaawansowany protokół, rutery rozgłaszają swoje tablice co 90 s, jeśli milczą przez 3 okresy jego ścieżki uznawane są za nieużyteczne a po 7 okresach milczenia są usuwane; dużo doskonalsze wyznaczanie metryki sieci, jest ona 24-bitową liczbą określającą nie tylko odległość, ale także przepustowość łącz, opóźnień na trasie a nawet pewności i obciążenia łącz

Tablica routingu.

```
$ netstat -rn
Kernel IP routing table
Destination Gateway Genmask Flags MSS Windowirtt Iface
127.0.0.0 0.0.0.0 255.0.0.0 U 0 00 lo
```

- Destination: sieci przeznaczenia zawarte w tablicy routingu
- Gateway: hosty w tablicy
- Genmask:
- Flags: adres docelowy dla danego wpisu; U: ruting działa
- MSS: ile bajtów naraz jest przesyłane przez odpowiednie połączenie
- Window: ile ramek może być przesłane zanim musi nadejść potwierdzenie
- irtt: statystyki dotyczące używania tego rutingu
- Iface: urządzenie sieciowe używane do tego rutingu

Przed klasami
Początkowo 32-bitowy adres IPv4 zawierał tylko 8 bitowe pole numeru sieci (które określało konkretną sieć do której był przyłączony host) i pole reszty, które dawało adres tego hosta w tej sieci (ten format był używany przed nadejściem LAN-ów, kiedy było tylko kilka dużych sieci takich jak ARPANET). 
Rezultatem tego była bardzo mała (256) liczba dostępnych sieci i bardzo wcześnie kiedy tylko pojawiły się LAN-y stało się oczywiste, że to nie wystarczy. 

Klasy
Definicja znaczenia adresów IP zmieniła się pozwalając na istnienie trzech różnych rozmiarów pół wielkości sieci (i powiązanych pól reszt) jak to jest określone poniżej (w bitach):

```
Class Leading bitsNetwork number Rest
Class A 0 724
Class B 1014 16
Class C 110 21 8
Class D (multicast) 1110
Class E (reserved)1111
```

- Sieci klasy A używają domyślnej maski podsieci 255.0.0.0, a ich pierwszy oktet należy do przedziału 0-127. Adres 10.52.36.11 to adres klasy A. Jego pierwszy oktet jest równy 10, czyli mieści się w przedziale od 1 do 127 włącznie.
- Sieci klasy B używają domyślnej maski podsieci 255.255.0.0, a ich pierwszy oktet należy do przedziału 128-191. Adres 172.16.52.63 to adres klasy B. Jego pierwszy oktet jest równy 172, czyli mieści się w przedziale od 128 do 191 włącznie.
- Sieci klasy C używają domyślnej maski podsieci 255.255.255.0, a ich pierwszy oktet należy do przedziału 192-223. Adres 192.168.123.132 to adres klasy C. Jego pierwszy oktet jest równy 192, czyli mieści się w przedziale od 192 do 223 włącznie.

co pozwoliło na następujące populacji wielkości sieci (rzeczywista ilość jest mniejsza bo niektóre wartości są zabronione):

```
Class Leading bits Total # of network numbers # of addresses per network
Class A 0 128 16,777,214
Class B 1016,38465,534
Class C 110 2,097,152 256
```

Większe pola numeru sieci pozwoliły na większą ilość sieci, tymczasowo pozwalajac na wzrost internetu. 
Maska sieci adresu IP która jest dzisiaj powszechnie wiązana z adresem IP nie była wymagana, ponieważ długość maski była wprost funkcją samego adresu. Każda urządzenie sieciowe mogło sprawdzić kilka pierwszych bitów z 32-bitowego adresu by zobaczyć do której klasy należał. 
Metoda określenia czy dany adres należy do tej samej fizycznej sieci co inny adres IP polegała na porównaniu częsci adresu zawierającej numer sieci a ponieważ część należąca do sieci byłą określona reszta byłą ignorowana - jeśli numery sieci pasowały dwa adresy były w tej samej sieci. 

Zamiast klas
Pierwsze zmiany nastąpiły, ale było to zbyt mało na dłuższa metę, adresów IP zaczęło brakować. Problemem było to, że większość jednostek była zbyt duża na klasę C i zamiast tego dostawały klasę B, w wyniku czego - ponieważ internet rozwijał się bardzo szybko - zaczęło ich brakować. Sieci klasowe zostały zamienione przez bezklasowe rutowanie międzydomenowe (CIDR) około 1993 by rozwiązać ten (i parę innych) problem. 
Wczesne alokacje adresów IP dokonane przez IANA były w niektórych wypadkach niezbyt wydajne, co przyczyniło się do problemu. Jednakże jednakże powszechna opinia, że niektóre organizacje niesprawiedliwie lub niepotrzebnie dostały klasę A jest bzdurą ponieważ większość tych alokacji jest datowanych na okres przed wprowadzeniem klas adresowych, kiedy dostępne były tylko sieci znane potem jako klasa A. 

Koncepcja podsieci (subnetwork)
Adresy IPv4 są podzielone na trzy części: sieci, podsieci (teraz często uważanej za część sieciową, ale oryginalnie była to część części hostowej) i hosta. Są trzy klasy adresów IP określające jak wiele która zajmuje. 

Subnetting jest procesem alokowania bitów z części hostowej do cześci sieciowej. Np. dając adresowi klasy A maskę podsieci 255.255.0.0 dzieli się ją na 255 podsieci. Wskazuje, że drugi oktet adresu IP pokazuje numer sieci a ostatnie dwa pokazują część hostową. 
Maska podzieci nie jest ograniczona do całych oktetów, np. 255.128.0.0 (lub /9) jest również prawidłową maską. 

Podsieć zero
Technicznie nielegalna, ale nadal użyteczna jest pierwsza podsieć, np. podsieć 1.0.0.0 z maską podsieci 255.155.0.0 - problem z tą podsiecią jest to, że adres unicastowy jest ten sam co dla całej sieci klasy A. 

Użyteczne tabele
Zasięgi adresów używane dla każdej klasy są podane w tej tabeli w standardowej notacji kropkowo dziesiętnej. 

```
Class Start End Leading (first) bits Start End Mask in dotted decimal
A 1.0.0.0 126.0.0.0 00.0.0.0 127.255.255.255 255.0.0.0
B 128.0.0.0 191.255.0.0 10 128.0.0.0 191.255.255.255 255.255.0.0
C 192.0.0.0 223.255.255.0 110192.0.0.0 223.255.255.255 255.255.255.0
D (multicast) 1110 224.0.0.0 239.255.255.255
E (reserved)1111 240.0.0.0 255.255.255.255
```

Niektóre adresy dla specjalnych zastosowań (RFC 3330). 

```
Addresses CIDR Equivalent Purpose RFC ClassTotal # of addresses
0.0.0.0 - 0.255.255.255 0.0.0.0/8 Zero AddressesRFC 1700A16,777,216
10.0.0.0- 10.255.255.25510.0.0.0/8Private IP addressesRFC 1918A16,777,216
127.0.0.0 - 127.255.255.255 127.0.0.0/8 Localhost Loopback AddressRFC 1700A16,777,216
169.254.0.0 - 169.254.255.255 169.254.0.0/16Microsoft APIPA RFC 3330B65,536
172.16.0.0- 172.31.255.255172.16.0.0/12 Private IP addressesRFC 1918B1,048,576
192.0.2.0 - 192.0.2.255 192.0.2.0/24Documentation and ExamplesRFC 3330C256
192.88.99.0 - 192.88.99.255 192.88.99.0/24IPv6 to IPv4 relay AnycastRFC 3068C256
192.168.0.0 - 192.168.255.255 192.168.0.0/16Private IP addressesRFC 1918C65,536
198.18.0.0- 198.19.255.255198.18.0.0/15 Network Device BenchmarkRFC 2544C131,072
224.0.0.0 - 239.255.255.255 224.0.0.0/4 Multicast RFC 3171D268,435,456
240.0.0.0 - 255.255.255.255 240.0.0.0/4 ReservedRFC 1700E268,435,456
```

Słowo podsieć ma dwa względne znaczenia, w starszym i bardziej ogólnym jest to fizyczna sieć należąca do internetu, w znaczeniu IP podsieć (subnetwork, subnet) jest podziałem sieci komputerowej, i o tym znaczeniu jest mowa poniżej. 

Podział sieci pozwala na utworzenie małych sieci z jednej dużej. Wprowadzony został, żeby pozwolić na podział jednej sieci na większą liczbę lokalnych sieci. Nawet po wprowadzeniu sieci klasowych, było to nadal pożyteczne, bo zmniejszało liczbę zapisów w tablicach rutingu o zasięgu internetu. Jako uboczna korzyść zmniejsza również przeciążenie sieci poprzez rozdzielenie stref rozgłoszeniowych (broadcast) IP. 
Każda maszyna musi mieć przydzieloną maskę podsieci, która definiuje jaka część adresu IP jest alokowana do ID podsieci a jaka część dla ID hosta w tej sieci. Fakt, że wszystkie hosty już używały masek pozwolił na łatwe wprowadzenie CIDR. 

Maska sieci znana także jako maska podsieci (network mask, subnet mask, netmask lub address mask) jest maską bitową używaną by wskazać jaka cześć adresu należy do podsieci, do której należy host, a jaka identyfikuje hosta. 
Maski podsieci są zwykle wyrażane w taki sam sposób jak adresy. W IPv4 w notacji dziesiętno kropkowej lub rzadziej jako ośmiocyfrowa liczba heksadecymalna. 
Krótsza forma, która jest znana jako notacja CIDR, daje numer sieci, za nim slasz i liczbę bitów jeden w binarnym zapisie maski (np. liczba znaczacych bitów w numerze sieci). Używając tej notacji w IPv4 podsieć może być wyrażona wprost jako 130.94.122.199/28. 

### Firewall

Zapora sieciowa - jeden ze sposobów zabezpieczania sieci/komputera/serwera przed intruzami. Sprzęt komputerowy wraz ze specjalnym oprogramowaniem bądź samo oprogramowanie blokujące niepowołany dostęp do sieci komputerowej, komputera, serwera itp. Jego funkcja w sieci polega na zapobieganiu komunikacji zakazanej przez politykę bezpieczeństwa. 
Podstawowym zadaniem jest kontrola ruchu pomiędzy różnymi strefami zaufania, typowe strefy to internet (brak zaufania) i wewnętrzna sieć (duże zaufanie). Ostatecznym celem jest zapewnienie kontrolowanego połączenia pomiędzy strefami różnego zaufania poprzez wymuszenie polityki bezpieczeństwa i modelu połaczenia opartego na zasadzie najmniejszego przywileju (_connectivity model based on the least privilege principle_).

Nazwa się wzięła od od terminu okreslającego w budownictwie grubą, ognioodporną zaporę, zabezpieczającą część budynku przed rozprzestrzenianiem się ognia w przypadku pożaru (zapora przeciwogniowa). Według innej teorii nazwa pochodzi od instalacji zakładanej w samochodach, która w trakcie wypadku zabezpiecza pasażerów przed zgnieceniem przez silnik i/lub pożarem. 

Zapory sieciowe są zwykle stawiane na styku dwóch sieci komputerowych, np. internetu i sieci lokalnej (LAN) (wtedy zapora pracuje często dodatkowo jako router), oraz na ważnych serwerach (ich ochrona). Na zaporze można zdefiniować specjalna strefę DMZ, która izoluje od wewnętrznej sieci serwery udostępniające usługi na zewnątrz. 

Właściwa konfiguracja firewalla nie jest łatwa. Wymaga rozważnego rozumienia protokołów sieciowych i bezpieczeństwa, drobna pomyłka może sprawić, że firewall będzie bezwartościowy.

Podział:

filtrujące:

Monitorują pakiety sieciowe i przepuszczają tylko zgodne z regułami ustawionymi na danej zaporze (zapora pracująca dodatkowo jako router). Zwykle w niewielkich sieciach jest zapora sprzętowa, bądź dedykowany komputer z systemem operacyjnym Linux. Obecnie najczęściej wykorzystywana metoda filtrowania w Linuksie to reguły oparte na iptables. Dostępne są także zamknięte komercyjne rozwiązania programowe, z których wiele posiada bardzo zaawansowane własności i rozbudowany system konfiguracji oraz wachlarz możliwych do zintegrowania rozwiązań, pozwalających nie tylko na analizę i filtrowanie pakietów IP, ale także na sprawdzanie poprawności pakietów z punktu widzenia wyższych warstw modelu ISO/OSI a nawet na prowadzenia ochrony antywirusowej.

oprogramowanie komputerów stacjonarnych:

Udostępnia wybrane porty do połączeń z zewnątrz monitorując ruch, udostępnia także połączenia na zewnątrz komputera wybranym usługom/programom. Często zintegrowane z ochroną antywirusową (na przykład Norton Internet Security)

zapory pośredniczące (proxy):

Wykonujące połączenie w imieniu użytkownika (przykład: zamiast uruchomienia sesji FTP do systemu zdalnego uruchamiamy sesję FTP na zaporze i dopiero stamtąd uruchamiany połączenie z systemem zdalnym). Zabezpieczające działanie proxy polega w tym wypadku na blokowaniu wszelkich pakietów niepoprawnych z punktu widzenia danego protokołu, które przy bezpośrednim połaczeniu mogłyby być może być obsłużone przez lokalny system, oraz na udostępnieniu możliwości zarządzania i kontroli kto i kiedy oraz w jaki sposób korzysta z danej usługi).

Współcześnie często pracująca zapora sieciowa jest hybrydowym rozwiązaniem analizującym pakiety w każdej warstwie od poziomu protokołu IP, aż do poziomu aplikacji, oraz umożliwiającym realizację złożonych polityk bezpieczeństwa oraz integrację z systemami IDS.

Podział według miejsca działania:

- osobisty firewall (a personal firewall) oprogramowanie kontrolujące ruch na pojedynczym komputerze użytkownika
- tradycyjny firewall (a traditional firewall) działający jako dedykowane urządzenie sieciowe lub komputer umiejscowiony na granicy dwóch lub więcej sieci lub DMZ-tów, filtruje cały ruch wychodzący i przychodzący.

Są w nim dwa rodzaje:

firewall poziomu sieci (Network layer firewalls)

Operuje na (relatywnie niskim) poziomie stosu protokołów TCP/IP jako filtr pakietów IP, nie pozwalając pakietom przejść przez firewall jeśli nie pasują do reguł, zdefiniowanych przez administratora lub domyślnych, wbudowanych (w niektórych nieelastycznych sieciach); bardziej pozwalający firewall będzie przepuszczał wszystkie pakiety o ile nie będą pasowały do którejś z negatywnych reguł ("negative-rules", "deny rules"). 
Proces filtrowania może też być oparty na źródle lub przeznaczeniu i porcie, oraz do którego z wyższego poziomu protokołu pakiet należy. 
Pracują bardzo szybko i przezroczyście dla użytkowników. 
Dzielą się generalnie na dwa rodzaje:

- bezstanowe: wyłącznie filtr pakietów, nie mogą podejmować bardziej złożonych decyzji wynikających ze stanu komunikacji pomiędzy hostami i dlatego są mniej bezpieczne; przypominają trochę ruter w jego możliwości filtrowania pakietów
- stanowe: przechowują pewne informacje o stanie połaczenia (np. ustanowione lub nie, inicjacja, handshaking, dane lub koniec połączenia) jako część swoich reguł (np. tylko host w firewallu może ustanowić pewne połączenie).

Każdy komputer z systemem operacyjnym, który wspiera filtrowanie pakietów i rutowanie (Linux, BSD, Solaris) może funkcjonować jako firewall warstwy sieci. 

firewall warstwy aplikacji (Application-layer firewalls)

Działają na poziomie stosu TCP/IP (np. ruch przeglądarki, telnetu lub ftp) i mogą przechwytywać wszystkie pakiety skierowane od i do aplikacji. Blokują inne pakiety (zwykle porzucając je bez informowania - _acknowledge_ - wysyłającego). Powinny móc zapobiec każdemu niepożądanemu ruchowi z zewnątrz do chronionych maszyn. Przez nadzorowanie wszystkich pakietów z niewłaściwą zawartością, firewalle mogą zapobiec rozprzestrzenianiu się wirusów. W praktyce jednakże staje się to tak trudne i skomplikowane (z powodu zróżnicowania aplikacji i różnorodnej zawartości pakietów), że raczej się tego nie stosuje. 
Ponieważ działa na poziomie warstwy aplikacji może przeglądać zawartość ruchu blokując to co widzi jako niewłaściwą zawartość, jak np. niektóre strony WWW, wirusy, próby wyzyskania znanych błędów oprogramowania itd. 
Nie rutuje ruchu na poziomie sieci, cały ruch zatrzymuje się na firewallu. 

Te dwa rodzaje nie są rozdzielne, niektóre systemy mają zaimplementowane jednocześnie oba. 

Podział według sposobu działania:

bezstanowe (stateless firewall)

Traktuje każdą ramkę (lub pakiet) w izolacji, nie ma żadnego sposobu sprawdzenia czy dany pakiet jest częścią istniejącego połączenia. 
Zanim nie pojawiły się stanowe firewalle było to normalne zachowanie. Współczesne firewalle używają informacji o połączeniu pozwalając administratorom sieci na bardziej precyzyjną kontrolę ruchu. 
Klasycznym przykładem sprawiającego problemy protokołu jest FTP ponieważ jest tak zaprojektowany, że otwiera nowe połączenia na przypadkowych portach. Np. pakiet TCP skierowany z jakiegoś hosta przeznaczony do maszyny w wewnętrznej sieci TCP numer portu 4970, ponieważ ten port nie jest żadnym z dobrze znanych usług, które bezpieczna sieć ma udostępniać (WWW. FTP, SSH) więc zostaje odrzucony - w ten sposób przerwano poprawne połączenie FTP. Jest to jeden z wielu protokołów potrzebujących do prawidłowego funkcjonowania możliwości otwarcia połączenia na dowolnym wysokim porcie. Ponieważ firewall nie ma żadnego sposobu by się sprawdzić, czy dany pakiet jest częścią poprawnej sesji FTP odrzuci pakiet. Problem ten rozwiązują dopiero firewalle stanowe przez utrzymywanie tablicy otwartych połączeń i powiązanie nowych żądań połączeń z istniejącymi poprawnymi połączeniami. 

stanowe (stateful firewall)

Przechowuje ścieżkę stanu połączenia sieciowego (jak strumień TCP). Wie jakie pakiety są uprawnione i tylko pakiety, które pasują do znanego połączenia przejdą przez firewall, inne zostaną odrzucone. 
Wczesne firewalle operowały na poziomie aplikacji (w modelu OSI), ale wymagało to zbyt wiele prędkości CPU. Filtr pakietów operuje na poziomie warstwy sieci i działają bardziej wydajnie, bo sprawdzają tylko nagłówki pakietów. Jednakże czysty filtr pakietów nie zna koncepcji stanu połączenia. 
Bardziej zaawansowany stanowy firewall ma możliwość przechowywania w pamięci znaczących atrybutów każdego połączenia przez cały czas jego trwania. Te atrybuty które razem są znane jako stan połączenia mogą zawierać takie szczegóły jak adres IP i porty używane do połączenia, oraz sekwencja numerów pakietów. Najbardziej intensywne dla CPU sprawdzanie jest przeprowadzane w czasie ustanowienia połączenia. Później wszystkie pakiety (dla danej sesji) są przetwarzane szybko ponieważ w prosty i dokładny sposób można określić czy należą to do istniejącego połączenia. Kiedy sesja jest skończona jej pozycja w tabeli stanów (state-table) jest usuwana. 
Zależą od potrójnego uścisku dłoni protokołu TCP. Kiedy klient inicjuje nowe połączenie wysyła pakiet z bitem SYN w nagłówku pakietu, wszystkie pakiety z ustawionym bitem SYN są uważane przez firewall za nowe połączenia. Jeśli usługa której klient żąda jest dostępna na serwerze, to usługa odpowie pakietem z bitami SYN i ACK. Klient wtedy odpowie wyłącznie bitem ACK i połączenie wejdzie w ustanowioną fazę. 
W celu zapobieżenia przepełnienia tablicy stanu, sesje będą się kończyć jeśli nie nastąpi żaden ruch przez określony czas, te zużyte połączenia zostaną usunięte z tablicy stanów. Wiele aplikacji wysyła wiadomości _keepalive_ okresowo w celu powstrzymania firewalla przed porzucania połączenia podczas braku aktywności użytkownika. Warto zauważyć, że większość ataków DoS to SYN flood, czyli wysyłanie dużej ilości pakietów SYN do serwera w celu przepełnienia tablicy stanu. Blokuje to serwer przed akceptowaniem następnych połączeń. 
Filtry poziomu aplikacji
Obecnie firewalle używają filtrów poziomu aplikacji zwanych proxy - ponieważ maszyny mają większą moc CPU i mogą przeprowadzić głęboką inspekcję w uzasadnionym czasie. Te proxy mogą czytać część danych każdego pakietu, żeby dokonać właściwej decyzji o połączeniu. Np. HTTP może zostać użyta jako tunel IRC lub P2P, tradycyjne stanowe firewalle nie mogą wykryć tego podczas kiedy firewall warstwy aplikacji może to wykryć i selektywnie zablokować połączenie HTTP kierując się informacją o zawartości. 
Firewalle sprawdzają każdy pakiet i decydują czy powinien trafić celu przeznaczenia, czy ma być odrzucony. Zazwyczaj pakiety są filtrowane według adresów lub portów źródła/przeznaczenia. 
Ale w większości przypadków są to informacje niewystarczające, administrator może chcieć kierować ruchem pakietów zgodnie z kontekstem połączenia, a nie tylko z charakterystyką indywidualnego pakietu. Zatem pakiet należący do istniejącego połączenia skierowany na port 22 (SSH) przejdzie, ale pakiet, który nie należy do żadnego istniejącego połączenia musi zostać porzucony. 
Dla tradycyjnych bezstanowych firewalli był to problem ponieważ firewall nie mógł dowiedzieć się, które pakiety należały do istniejącego połaczenia, a które nie. Stanowe firewalle rozwiązują ten problem przez monitorowanie połaczenia sieciowego i dopasowywanie pakietów do istniejących lub nowych połaczeń. 
Squid jest przykładem buforującego proxy, nie ma na celu zapewnienia bezpieczeństwa, jego głównym celem lokalne przechowywanie kopii często odwiedzanych stron WWW w celu zmniejszenia obciążenia. 

Firewalle często mają funkcję NAT, a hosty chronione za firewallem powszechnie używają tzw. "prywatnej przestrzeni adresowej" zdefiniowanej w RFC 1918. Administratorzy często używają tego w celu zamaskowania wewnętrznych adresów lub sieci.

#### Proxy

Serwer proxy
Usługa sieciowa, która pozwala klientom na niebezpośrednie połączenie z innymi usługami sieciowymi, klient łączy się z serwerem proxy, wtedy żąda połączenia, pliku lub innego zasobu dostępnego na innym serwerze. Proxy zapewnia dostęp do zasobów łacząc się z określonym serwerem, albo z buforem. W niektórych sytuacjach proxy może zmienić żądanie klienta lub odpowiedź serwera z różnych powodów. 

Urządzenia proxy (działające albo na dedykowanym urządzeniu lub na oprogramowaniu maszyny ogólnego przeznaczenia) moga działać jako firewall odpowiadając na wejściowe pakiety (np. żądania połączenia) w taki sposób jak aplikacja i blokując inne pakiety.

Proxies sprawiają, że podrabianie wewnętrznego systemu z zewnętrznej sieci jest trudniejsze, a nadużycie jednego wewnętrznego systemu nie powoduje wykorzystywalnego wyłomu bezpieczeństwa z zewnątrz firewalla (tak długo jak długo aplikacja proxy pozostaje nietknięta i poprawnie skonfigurowana). Istnieje również możliwość, że napastnik przechwyci publicznie dostępny system i użyje go jako proxy dla swoich własnych celów, proxy jest wtedy maskaradą dla innych wewnętrznych systemów. 
Podczas kiedy użycie wewnętrznej przestrzeni adresowej zwiększa bezpieczeństwo, napastnicy mogą użyć tej metody jako IP spoofing do próby przepuszczenia pakietów do docelowej sieci. 

Web proxy

Powszechnie używaną aplikacją jest buforujące web proxy. Zapewnia bliski bufor stron www i plików dostępnych na odległych serwerach, pozwalając sieciowym klientom na dostęp szybciej lub bardziej wiarygodnie. 
Kiedy przychodzi żądanie zasobu WWW (określonego przez URL), buforujące proxy szuka go w swoim lokalnym buforze i jeśli go znajduje natychmiast go zwraca. W przeciwnym wypadku pobiera go ze zdalnego serwera zwraca żądającemu i zapisuje kopie w buforze. Bufor zwykle używa algorytmu expiracji, żeby usuwać dokumenty z bufora i zgodnie z ich wiekiem, rozmiarem i historią dostępu. Dwa proste algorytmy bufora:

- Least recently used (LRU): usuwa najdłużej nieużywany dokument
- Least Frequently Used (LFU): usuwa najrzadziej używany dokument

Mogą być używane także jako filtry zawartości WWW, niektóre aplikacje _censorware_, które służą do blokowania niestosownej zawartości są zaimplementowane jako web proxy. Inne modyfikują strony WWW dla swoich celów, np. Skweezer przystosowuje je dla telefonów komórkowych i PDA. Operatorzy sieciowi mogą także zastosować web proxy do wyszukiwania wirusów komputerowych i innej wrogiej zawartości ze zdalnych stron WWW. 

NAT proxy

Opisane wyżej.

Transparent proxy

Wiele organizacji - korporacje, szkoły i rodziny - używają proxy serwerów do wymuszenia polityki sieciowej (jak censorware) lub zapewnienia bezpieczeństwa i usług buforujących. Zwykle web lub NAT proxy nie jest transparentny dla klienckiej aplikacji, musi zostać skonfigurowany do używania proxy: ręcznie lub skryptem konfiguracyjnym. Tak więc użytkownik może ominąć proxy po prostu zmieniając konfigurację klienta. Transparent proxy (transproxy) łączy proxy serwer z NAT w taki sposób, że połączenie jest rutowane przez proxy bez konfiguracji po stronie klienta. 
Zarówno NAT jak i transproxy są trochę kontrowersyjne ponieważ łamią podstawową zasadę TCP/IP - "_end-to-end pryncypium_". 

Otwarte proxy, nadużycie i wykrywanie
Zarówno web jak i inne sieciowe proxy są nadużywane przez spamerów i innych ludzi nadużywjących sieci. Otwarte proxy jest to proxy które akceptuje połączenie klienta z dowolnego adresu IP i łączy sie z dowolnym zasobem internetowym. 
Nadużycie otwartych proxy jest obecnie powszechne, np. spamerzy często instalują open proxy na komputerach nieświadomych użytkowników MS Windows używając do tego specjalnie zaprojektowanych wirusów. 
Ponieważ są często nadużywane, powstały metody, żeby odmawiać usług dla otwartych proxy. Operatorzy maila i IRC używaja DNSBL publikując listy adresów IP znanych otwartych proxy. 

Odwrotne proxy
Jest to serwer, który jest zainstalowany w sąsiedztwie jednej lub większej ilości sieci, cały ruch idący z internetu do jednego z serwerów idzie przez proxy serwer. Jest kilka powodów do zainstalowania odwrotnego proxy:

- Bezpieczeństwo: serwer proxy jest dodatkową warstwą obrony
- Szyfrowanie / przyspiesznie SSL: kiedy tworzone są bezpieczne strony www, często szyfrowanie SSL jest robione nie przez sam serwer ale odwrotne proxy wyposażone w sprzętowe przyspieczenie SSL
- Kierowanie obciążeniem (Load distribution): odwrotne proxy mogą dystrybuować kilka webserwerów, a każdy serwujący swoje własne usługi. W takim przypadku odwrotne proxy potrzebują przepisać URL każdej strony (translacja z zewnętrznych znanych URL-i na wewnętrzne położenia)
- Bufor (Serve/cache static content): może rozładować webserwery przez buforowanie statycznej zawartości jak np. obrazy i inna graficzna zawartość.

Popularne serwery proxy

- Squid cache - popularny serwer proxy HTTP dla uniksów
- Apache HTTP Server - może zostać skonfigurowany jako proxy serwer

Termin proxy jest także używane w innym znaczeniu w SIP (Session Initiation Protocol) używanym w wielu wspólczensych systemach VoIP. SIP Proxy nie pracuje z zawartością danych klienta

### URI, URL, FQDN

#### URI (Uniform Resource Identifier)

URI (Uniform Resource Identifier) jest standardem internetowym określonym w RFC 3986 umożliwiającym łatwą identyfikację zasobów w sieci. 

Element protokołu internetowego zawierający krótki ciąg znaków zgodnych z pewną składnią. Wyznacza nazwę lub adres, który może zostać użyty jako odniesienie do pewnego abstrakcyjnego lub fizycznego zasobu. 
Kodyfikacja IETF oparta jest na wcześniejszych propozycjach Tima Berners-Lee. Po rewizji w RFC 2732 a potem RFC 2396bis, najnowsza została opublikowana w styczniu 2005 jako RFC 3986. 

URI jest, zazwyczaj krótkim łańcuchem znaków, zapisanym zgodnie z określoną w standardzie składnią. Łańcuch ten określa nazwę lub adres zasobu. 

Składnia URI:

- określenie protokołu: np. "http", "ftp", "urn"
- dwukropek
- część specyficzna dla danego schematu, jej semantyka jest określona przez specyfikacje które zarządzają schematem - składnia URI wprowadza tu pewne restrykcje dotyczące znaków, zarezerwowanych do specjalnych celów oraz hierarchicznej struktury

URI może być rozumiany jako lokalizator, nazwa lub w obu tych znaczeniach. 
Szczególnym przypadkiem URI jest URL, który oprócz identyfikacji wskazuje również sposób dostępu do zasobu. URI jest nadzestawem bardziej znanego URL używanego do adresowania WWW. 

##### URI reference

URI reference jest innym rodzajem ciągu reprezentującego URI i zasobu odentyfikowanego przez URI. Nie jest to zwykle rozróżniane, ale specyfikacja protokołu nie pozwala na taką dwuznaczność. 
Mogą mieć postać pełnego URI lub po prostu zależnej od schematu części jednego, lub nawet pojedynczego elementu - może to być nawet pusty ciąg. 
Opcjonalny identyfikator fragmentu, poprzedzony "#" może być obecny na końcu URI reference. Część reference przed "#" niebezpośrednio wskazuje na zasób a fragment identyfikujący wskazuje na jakąś część zasobu. 
W celu oddzielenia URI od URI reference, ten drugi jest konwertowany na "absolutną" postać przez łączenie z absolutną "bazą" URI zgodnie z wyznaczonym algorytmem. O ile nie jest to już absolutny URI, URI reference jest traktowany jako relatywny względem bazowego URI. Bazowy URI jest to zwykle URI, który identyfikuje dokument zawierający URI reference, chociaż może być wskazany przez deklaracje w dokumencie lub być częścią zewnętrznych danych protokołu transmisji. 
Jeśli identyfikator fragmentu jest obecny w bazowym URI jest ignorowany w czasie procesu łączenia, a jeśli jest obecny w URI reference jest zachowywany. 
W języku znaczników WWW, URI reference jest często używany w miejscach gdzie jest potrzeba wskazania do innego zasobu, takiego jak zewnętrzny dokument lub pewna część tego samego logicznego dokumentu. 

Przykłady URI reference w językach znacznikowych

- w HTML: wartość atrybutu src elementu img i wartość atrybutu href elementu a
- w XML, identyfikator systemowy pojawiający się po słowie kluczowym SYSTEM w DTD jest bezfragmentowym URI reference
- w XSLT, wartość atrybutu href elementu/instrukcji xsl:import, jak w pierwszym argumencie funkcji document().

Przykłady absolutnego URI

- http://somehost/absolute/URI/with/absolute/path/to/resource.txt
- ftp://somehost/resource.txt
- urn:issn:1535-3613

przykłady URI references

- http://example/resource.txt#frag01
- http://somehost/absolute/URI/with/absolute/path/to/resource.txt
- /relative/URI/with/absolute/path/to/resource.txt
- relative/path/to/resource.txt
- ../../../resource.txt
- resource.txt
- /resource.txt#frag01
- #frag01
- [empty string]

##### Rozwiązanie URI (URI resolution)

"Rozwiązać URI" znaczy albo skonwertować relatywne URI reference na formę absolutną albo próbę otrzymania reprezentacji zasobu, który identyfikuje. Element rozwiązujący w oprogramowaniu przetwarzającym dokument zapewnia obie usługi. 
Zgodnie z RFC 2396 jeśli URI reference jest pustym ciągiem lub zawiera tylko znak "#" a po nim opcjonalny fragment wtedy reference jest uważany za reference tego samego dokumentu. 

URI składa się z URL i URN. 

##### URL i URN

URN (Uniform Resource Name) oznacza zunifikowany format nazw zasobów (głównie książek). URN składa się z identyfikatora przestrzeni nazw (NID - ang. Namespace Identifier) i przestrzeni nazw specyficznego łańcucha (NSS - ang. Namespace Specific String). URN jest cześcią URI. 
Może byc używany do określenia zasobu bez wskazania jego lokalizacji albo rozwiązania go. Np. urn:ISBN:0-395-36341-1 jest to URN, który jak numer ISBN książki, pozwala mówic o książce, ale nie mówi ani gdzie ani jak otrzymać jej egzemplarz. 
Obecnie uważa się, że terminy URL i URN są zależnymi od kontekstu aspektami URI i rzadko muszą być rozróżniane, ponadto termin URL szybko staje się przestarzały (obsolete) i rozróżnianie pomiędzy URL i URI jest rzadko potrzebne. 
RFC 2141 mówi: URN ma służyć jako trwały, niezależny od lokalizacji identyfikator zasobu i jest zaprojektowany tak, żeby było łatwo mapować inne przestrzenie nazw (które współdzielą właściwości URN) w przestrzeń URN. Dlatego składnia zapewnia środki kodowania znaków danych w postać, która może być umieszczona w istniejących protokołach. 

Np. masz egzeplarz Cryptonomicon. 

- Jeśli mówi się komuś "moja książka jest na półce w sypialni" to jest URL - bo mowi się gdzie jest.
- Jeśli mówi się komuś "czytałem fajną książkę, ma tytuł "Cryptonomicon"" to jest URN bo mówis się nazwę czegoś.
- Osoba, która wie gdzie jest kopia może ją dostać lub powiedzieć gdzie jest (URL).
- Osoba, która zna jej nazwę, może się zastanowić, powiedzieć czy ją widziała i może opowiedzieć treść.

Niektóre wartości URN:

- "urn:isbn:0451450523" - URN dla "The Last Unicorn", identyfikowane przez numer książki.
- "urn:ietf:rfc:3187" - URN dla IETF RFC 3187.
- "urn:oid:2.16.840" - URN odpowiadające OID dla USA.
- "urn:sha1:YNCKHTQCWBTRNJIV4WNAE52SJUQCZO5C" - URN representujące konkretny plik MP3 dla przemówienia Martina Luthera Kinga.
- "urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66" - URN używające 1 UUID.

Można powiedzieć "Możesz znaleźć urn:ietf:rfc:3187 (URN) w http://www.faqs.org/rfcs/rfc3187.html (URL)."

Rejestracja schematów nazw URI
Najwyższym poziomem struktury nazw URI jest definicja schematów (URI schemes). RFC 2717 opisuje procedury rejestracji nowych schematów URI. 

#### URL (_Uniform Resource Locator_)

URL (ang. Uniform Resource Locator) oznacza zunifikowany format odnośników do zasobów (głównie internetu). 
Jest to standaryzowany adres zasobu (dokument lub obraz) w internecie lub gdziekolwiek indziej. Stworzony przez Tima Berners-Lee dla użycia w WWW; obecna forma określona jest w standardzie RFC 1738. 
URL to jeden z podstawowych mechanizmów w internecie, składnia jest zaprojektowana w ogólnej postaci, jest roszerzalna i może wyrazić adresy w każdym zestawie znaków używającym ograniczonego podzestawu znaków ASCII (np. spacja nie jest nigdy używana w URL). 

Większości użytkowników sieci URL kojarzy się wyłącznie z adresami stron WWW, format ten jednak daje też możliwość odsyłania do wszelkich innych usług dostępnych w Internecie. Wpisując poprawny odnośnik do okna przeglądarki stron WWW możemy szybko wywołać określoną informacje w dostępnej sieci. 

URL są zdefiniowane przez RFC 1738 w następujący sposób:
URL składa się z rodzaju zasobu (ang. scheme) dwukropka i części zależnej od rodzaju zasobu (ang. scheme-specific part). Nazwy rodzaju zasobu mogą składać się z małych liter, plusa, myślnika oraz kropki. Duże litery mogą być akceptowane, przy czym muszą być zamieniane na małe przez oprogramowanie. 

Część zależna od rodzaju usługi zwykle przybiera jedną z postaci:

- W przypadku zasobów będących plikami:
  - //adres_serwera/sciezka_dostępu
  - //nazwa_uzytkownika@adres_serwera/sciezka_dostępu
  - //nazwa_uzytkownika:hasło@adres_serwera/sciezka_dostępu
- W przypadku zasobów nie będących plikami (konta shellowe, adresy e-mail itd.)
  - nazwa_uzytkownika@adres_serwera

Często oprogramowanie pozwala na różne niewłaściwe formy "urli", np. pomijanie //, lub formy typu adres_serwera/sciezka_dostepu

niektóre przykłady schematów/systemów URL:

- http - zasoby HTTP
- https - HTTP przez SSL
- ftp - File Transfer Protocol
- mailto - E-mail adres
- ldap - Lightweight Directory Access Protocol lookups
- file - zasoby dostępne na lokalnym komputerze lub przez lokalną sieć współdzielenia plików
- news - newsgrupy Usenet
- gopher - protokół Gophera
- telnet - protokół telnetu
- nntp - NNTP

Przykładowy URL: http://www.wikipedia.com/wiki/URL gdzie:

- http: to protokół
- //www.wikipedia.com to adres serwera
- /wiki/URL to ścieżka dostępu

URI a URL
Każdy URL jest rodzajem URI (lub ściślej podzestawem URI). URI identyfikuje poszczególny zasób podczas kiedy URL zarówno identyfikuje zasób jak i wskazuje jego lokalizację. 
Np. URI urn:ietf:rfc:1738 identyfikuje IETF RFC 1738 nie określając gdzie znaleźć tekst tego RFC. 
A teraz trzy URL dla trzech oddzielnych dokumentów zawierających tekst tego RFC:

- http://www.ietf.org/rfc/rfc1738.txt
- http://www.w3.org/Addressing/rfc1738.txt
- http://rfc.sunsite.dk/rfc/rfc1738.html

Każdy URL unikalnie identyfikuje każdy dokument tak samo jak URI, ale składnia URL jest taka, że identyfikacja pozwala zlokalizować każdy z tych dokumentów. 
Historycznie, termin miał prawie to samo znaczenie bo prawie wszystkie URI były URL. 

Schemat URL URL zaczyna się od nazwy schematu po którym jest dwukropek a potem specyficzna dla danego schematu część.

zobacz również http://www.iana.org/assignments/uri-schemes

Ogólna składnia URI
Składnia części specyficznej dla danego schematu zależy od wymagań schematu, schematy używające typowych połączeniowych protokołów używają wspólnej "ogólnej składni URI", zdefiniowanej poniżej:

```
scheme://authority/path?query
```

- źródło (authority) zawiera nazwę hosta lub adres IP serwera, opcjonalnie po niej dwukropek i numer portu, może także zawierać informacje o użytkowniku i hasło dla uwierzytelnienia dla serwera.
- ścieżka która określa jakąć lokalizację hierarchicznej struktury przy użyciu slasza "/" jako delimitera pomiędzy składnikami.
- ścieżka pytania (query part) jest zwykle określeniem parametrów dynamicznego pytania do wskazanych zasobów

Kompletna autorytatywna składnia parametrów URI:

```
scheme://username@password:subdomain.domain.tld:port/directory/file.ext?parameter=value#anchor
```

Wielkość liter
URL-e generalnie są wrażliwe na wielkość liter; jednakże ostatecznie zależy to od administratora serwera. Dla wygody niektóre serwery nie rozróżniają wielkości liter. 

URLe w codziennym użytku
URL HTTP łączy w jeden prosty adres cztery podstawowe jednostki dla informacji potrzebnej do otrzymania zasobu z internetu:

- protokół użyty w komunikacji
- host (serwer) z którym nastąpi komunikacja
- port sieciowy w serwerze na którym będzie połączenie
- ścieżka do zasobu na serwerze (np. nazwa pliku).

Typowy URL może wyglądać tak:

```
http://en.wikipedia.org:80/wiki/Special:Search?search=train&go=Go
```

gdzie

- http jest protokołem
- en.wikipedia.org jest hostem
- 80 jest numerem sieciowego portu na serwerze (80 jest domyślną wartością dla protokołu HTTP, ta częśc może zostać ominięta),
- /wiki/Special:Search jest ścieżką zasobu,
- ?search=train&go=Go jest query string; ta częśc jest opcjonalna.

Większość przegladarek nie wymaga od użytkownika wprowadzenia "http://" do adresu, ponieważ HTTP jest najczęstszym protokołem używanym przez przeglądarki. Podobnie jak 80 jest domyślnym portem dla http, więc zwykle nie jest wyszczególniony, można po prostu wprowadzić część URL taką jak www.wikipedia.org/wiki/Train, a żeby trafić na stronę główną wystarczy wpisać www.wikipedia.org. 
Ponieważ protokół HTTP pozwala serwerowi odpowiedzieć na żądanie przekierowaniem do innego URL wiele serwerów dodatkowo pozwala użytkownikom na opuszczenie części URL takiej jak www. lub końcowy slasz jeśli zasób jest katalogiem. 

Np. en.wikipedia.org/wiki/Train zawiera hierarchiczny porządek składników gdzie:

- org (gTLD)
- wikipedia (second-level domain)
- en (subdomain)
- wiki Train np. przed pierwszym slaszem od prawej do lewej potem reszta z lewej do prawej.

Termin URL jest również używany poza kontekstem WWW. Serwery baz danych określają URL-e jako parametry połączeniowe. Podobnie każda aplikacja klient-serwer zgodnie z poszczególnym protokołem może określić format URL jako część swojego procesu komunikacji. 
Przykład URL-u bazy danych:

```
jdbc:datadirect:oracle://myserver:1521;sid=testdb
```

#### FQDN (Fully Qualified Domain Name)

Jest to nazwa czytelna dla człowieka, która odpowiadaja adresowi TCP/IP interfejsu sieciowego. Zawiera nazwę hosta i nazwę domeny. 
Np. dla danej nazwy hosta "myhost" i nazwy domenowej "bar.com", FQDN to myhost.bar.com. Może być wiele hostów na świecie nazwanych "myhost" ale może być tylko jeden "myhost.bar.com". 

Wszędzie jest kropka na końcu nazwy domenowej, np. kończy się "com." a nie ".com" - oznacza to, że ta nazwa jest FQDN, np. "myhost.bar.com" mogłoby być niejednoznaczne ponieważ mógłby to być sufix dłuższej nazwy domenowej takiej jak "myhost.bar.com.gov" podczas kiedy "myhost.bar.com." jest FQDN. 
Technicznie kropka jest korzeniem hierarchii DNS i dlatego FQDN jest czasem nazywany zakorzenioną nazwą domenową (rooted domain name). W praktyce kropka jest najczęściej pomijana i wtedy nazwa domenowa - przynajmniej w teorii - jest niejednoznaczna. 

Najdłuższa dozwolona FQDN ma 255 bajtów, z dodatkowym ograniczeniem 63 bajtów na każdy poziom nazwy domenowej, składnia nazw domenowych jest omawiana w różnych RFC (RFC 1035, RFC 1123 i RFC 2181). Poziomy w FQDN są ograniczone do bardzo ograniczonego zestawu znaków, zawierającego litery ASCII od a do z i "-" i nie rozróżniają wielkości liter. 
_Internationalized domain names_ rozszerzają repertuar znaków nazw domenowych do zawierajacych znaki nie-ASCII przez kodowanie znaków unikodowych w strumień bajtów z normalnym zestawem znaków FQDN. W wyniku tego ograniczenie długości znaków nazw domenowych jest zależne od kontekstu. 

FQDN to nie to samo co URL ponieważ brakuje nazwy protokołu TCP/IP użytego do komunikacji z hostem. 
URL zwykle zaczyna się od "protocol://" i określa protokół komunikacyjny (jak "http://" lub "ftp://") i może też zdefiniować ścieżkę katalogową i numer portu. 
Ale czasem zamiast pełnych URL stosuje się tylko FQDN, w tym wypadku domyślnym protokołem jest HTTP a portem TCP 80. 

- RFC 1035: Domain names: implementation and specification
- RFC 1123: Requirements for Internet Hosts - application and support
- RFC 2181: Clarifications to the DNS specification

### Urządzenia

- Urządzenia warstwy fizycznej modelu OSI - wzmacniak, hub
- Urządzenia warstwy łącza danych modelu OSI - switch, bridge
- Urządzenia warstwy sieciowej modelu OSI - ruter

Oba urządzenia działajace w warstwie fizycznej (pierwszej warstwy OSI) nie ingerują w żadne dane (oprócz wzmocnienia i połączenia), nie podejmują żadnych decyzji. Wzmacniak wzmacnia sygnał, a koncentrator kopiuje go z jednego komputera do wszystkich pozostałych przyłączonych do niego. 

Urządzenia warstwy drugiej modelu OSI to bridge i switch. Posiadają już pewną inteligencję - potrafią rozpoznawać skąd i dokąd mają przesłać ramki. Używają do tego adresów MAC urządzeń sieciowych.

Urządzenia sieciowe warstwy trzeciej modelu OSI zajmują się: adresowaniem sieciowym (np. adresowanie IP) i rutingiem. 
Takim urządzeniem jest ruter. 

#### Wzmacniak (ang. _repeater_)

Urządzenie które działa w warstwie fizycznej i zajmuje się regeneracja sygnałów płynących w medium transmisyjnym (kablu) aby umożliwić sygnałowi przebycie dłuższego dystansu. Kiedy sygnał przebiega w medium transmisyjnym zatraca się wraz z długością drogi jaką pokonał (z różnych przyczyn, np. opór własny). Wzmacniaki umożliwiają sygnałowi przebycie dłuższej drogi poprzez wzmocnienie sygnału. 

#### Koncentrator (ang. _hub_)

Pozwala na utworzenie połączeń pomiędzy urządzeniami podłączonymi do niego (zazwyczaj są to komputery). Hub działa jak tzw. multiport repeater, to znaczy regeneruje przesyłany przez niego sygnał jednocześnie łącząc kilka urządzeń ze sobą. Kiedy jedno z urządzeń podłączonych do hub-a wyśle informacje, to otrzymują ją wszystkie pozostałe urządzenia. 

Najczęściej łączy wiele komputerów w sieci o topologii gwiazdy. Koncentrator podłączany jest do komputera głównego (serwera, często podłączonego do Internetu), zaś do koncentratora podłączane są komputery będące stacjami roboczymi. Do połączenia najczęściej wykorzystuje się kabel UTP skrętka kategorii 5. 

Łączy wiele segmentów Ethernetu zamieniając je w jeden, każde dołączone urządzenie dzieli tą samą przestrzeń rozgłoszeniową (_broadcast domain_) i tą samą dziedzinę kolizji (_collision domain_). Zatem tylko jeden komputer połączony do huba może nadawać w tym samym czasie, zależnie od topologii sieci, hub zapewnia podstawowe połączenie poziomu 1 modelu OSI pomiędzy obiektami sieciowymi (stacje robocze, serwery itp.). Zapewnia przepustowość dzieloną z innymi obiektami, porównywalną do przełączników. 

#### Most (ang. _bridge_)

Zadaniem mostu jest segmentacja - dzielenie sieci na różne domeny kolizyjne. Są to starsze urządzeniami i teraz rzadko są używane, zostały wyparte przez switch-e. Bridge miały przeważnie 2 porty, które dzieliły sieć na 2 różne domeny kolizyjne. Z tego powodu zostały wyparte przez switch-e (switch ma 4, 8, 12, 24, 48 portów).

#### Przełącznik (ang. _switch_)

Switch w odróżnieniu od huba rozpoznaje skąd została przysłana ramka (np. od jakiegoś hosta w sieci) i potrafi zdecydować gdzie ją dalej przesłać za pomocą swojej tzw. tablicy adresów MAC. Kiedy adres docelowy nie jest adresem broadcast (lub multicast), ramka zostanie przekazana tylko to portu o adresie docelowym a nigdy do pozostałych. 

Przełącznik tworzy segmentację sieci, czyli dzieli sieć na mniejsze domeny kolizyjne (grupy komputerów pomiędzy którymi zachodzą kolizje) na poziomie portów. Ale kiedy urządzenia wysyłają broadcast lub multicast to i tak zostają one wysłane do wszystkich portów tych urządzeń, ponieważ systemy (np. hosty) posiadają nadal tą samą domenę rozgłoszeniową.

Technicznie jest to wieloportowy most (ang. _bridge_). Urządzenie łączące różne segmenty sieci, używa logiki mostu sieciowego, ale pozwala na fizyczną i logiczną topologię sieci. Często jest używany zamiast koncetratorów (hub), czasem jest też określany jako inteligentny hub. 
Może połączyć Ethernet, Token Ring lub segmenty innych typów sieci przełączanych w formę heterogenicznej sieci działającej na warstwie 2 modelu OSI. 

Przełączniki to urządzenia pracujące w warstwie drugiej modelu OSI, ich zadaniem jest przekazywanie ramek. W celu ustalenia fizycznego adresata używają docelowego adresu MAC zawartego w nagłówku ramki Ethernet. 
Kiedy ramka przychodzi do przełącznika ten zachowuje jej oryginalny adres MAC i oryginalny port w tablicy adresów MAC przełącznika. Przełącznik wybiórczo wysyła ramki z określonych portów na podstawie adresu przeznaczenia MAC i wcześniejszych wpisów w tablicy adresów MAC. Jeśli adres MAC jest nieznany, lub jest to adres rozgłoszeniowy, albo multicast, wtedy przełącznik po prostu wyśle (_flood_) do wszystkich przyłączonych interfejsów oprócz przychodzącego portu. 
Jeśli adres przeznaczenia MAC jest znany, ramka jest wysyłana tylko do odpowiedniego portowi w tablicy adresów MAC. Jeśli port przeznaczenia jest ten sam co port pochodzenia ramka jest filtrowana i nie jest przesyłana. 

Przełączniki utrzymują tablicę mapowań adres MAC&lt;-&gt;port fizyczny, której pojemność jest zwykle określona na 4096, 8192 lub 16384 wpisów. Po przepełnieniu tej tablicy, nowe wpisy nie są dodawane (chyba, że któryś z istniejących wygaśnie), a ramki rozgłaszane są do wszystkich portów (za wyjątkiem portu, którym ramka dotarła do przełącznika). 
Przełączniki ograniczają domenę kolizyjną do pojedynczego portu, dzięki czemu są w stanie zapewnić każdemu hostowi podłączonemu do portu osobny kanał transmisyjno-nadawczy, a nie współdzielony, tak jak koncentratory. 

Inaczej niż huby używają mikrosegmentacji do dzielenia dziedzin kolizji, jedną na podłączony segment. W ten sposób tylko NIC-e, które są podłączone bezpośrednio przez łącze point-to-point lub bezpośrednio połączone koncentratory rywalizują o medium. 
Dzięki wyeliminowaniu są możliwe możliwości kolizji, full-duplex połączenia point-to-point do przełącznika. 
Wirtualne LAN-y mogą być używane w przełącznikach do redukcji rozmiaru dziedzin rozgłoszeniowych (_broadcast domains_) i w ten sposób zwiększają bezpieczeństwo. 

Na przełącznikach zarządzalnych można również wydzielać VLAN-y, czyli wirtualne podsieci LAN. Porty należące do różnych VLANów nie 'widzą' swoich transmisji - do wymiany informacji pomiędzy różnymi VLANami używa się routerów. Porty do VLANów przypisywane są statycznie lub na podstawie adresu MAC podłączonej stacji (opisuje to protokół GVRP, Generic VLAN Registration Protocol, dostępny na większych przełącznikach). VLANy pomiędzy dwoma podłączonymi do siebie przełącznikami przenosi specjalny rodzaj połączenia - _trunk_. W standardzie IEEE 802.1Q każda ramka wysyłana przez _trunk_ opatrzona zostaje 4-bajtowym polem, w ramach którego przenoszony jest również identyfikator VLAN-u (tak, by odbierający ramki przełącznik był w stanie wysłać ramkę do odpowiedniego VLANu). W związku z tym ramki oznaczane (czasem określa się to tagowaniem), moga mieć maksymalnie długość do 1522 bajtów. 
Obecnie na rynku obecne są również przełączniki routujące (tzw. przełączniki 3 warstwy modelu OSI). 

Są cztery metody przekazywania (_forwarding methods_) jakich może użyć przełącznik:

- przecięcie (_Cut through_)
- gromadź i prześlij (_Store and forward_) - inaczej niż w poprzedniej buforuje i najczęściej sprawdza sumy kontrolne na każdej ramce przed przesłaniem.
- (_Fragment free_)
- (_Adaptive switching_)

Wady
Przełączniki stwarzają problemy w monitorowaniu ruchu ponieważ każdy port jest izolowany aż do chwili przesyłania danych, i nawet wtedy tylko wysyłający i odbierający port są połączone. 
Dwie popularne metody specjalnie zaprojektowne do monitorowania ruchu w takich sytuacjach to:

- _Port mirroring_ - przełącznik wysyła kopie pakietów sieciowych do monitorującego połączenia sieciowego.
- _SMON_ - "Switch Monitoring" opisany przez RFC 2613 i jest protokołem przeznaczonym do kontroli takich właściwości takich jak port mirroring.

Inne metody (ataki) zostały opracowane, żeby umożliwić _snooping_ w innym komputerze w sieci bez współdziałania z przełącznikiem:

- _ARP spoofing_ - ogłupienie docelowego komputera przez użycie swojego własnego adresu MAC na bramce sieci lub użycie go jako adresu rozgłoszeniowego MAC.
- _MAC flooding_ - przeładowanie przełącznika dużą liczbą numerów adresów MAC, w wyniku czego przełącza się w "_failopen mode_".

#### Ruter (ang. _router_)

Domeny rozgłoszeniowe to systemy w których rozchodzą się wspólne ramki broadcastu, domyślnie nie przechodzą przez routery, które działają jako tzw. punkt demarkacyjny (demarcation point). Żeby przeprowadzić komunikację pomiędzy domenami rozgłoszeniowymi potrzebna jest warstwa trzecia i urządzenia, które w niej działają - rutery. 
W sieci opartej o protokół IP komputery wykorzystują do tego tzw. domyślną bramę (default getway) - zazwyczaj jest nią lokalny adres routera. Kiedy host z jednej sieci (domeny rozgłoszeniowej) chce się skomunikować z hostem w innej sieci, przekazuje pakiet do routera (domyślnej bramy), który to decyduje gdzie dalej go przesłać (odbywa się to przy pomocy jego tzw. tablicy routing-u). Router-y mają zawsze co najmniej 2 interfejsy, którymi mogą odbierać i wysyłać dane. 
Dla przykładu ruter ma połączyć dwie sieci Ethernet LAN lub jedna Ethernet LAN z Token Ring LAN. W tej sytuacji ruter pełni rolę połączenia sieci o różnych technologiach.

Urządzenie sieciowe, które określa następny punkt sieciowy, do którego należy skierować pakiet danych (np. datagram IP). Ten proces nazywa się routingiem (rutingiem) bądź trasowaniem. Routing IP odbywa się w warstwie trzeciej modelu OSI. 
Przesyłanie pakietów danych do ich przeznaczenia związane jest najczęściej z protokołem IP, ale są również używane inne mniej popularne protokoły (np. IPX sieci Novell). 
Aby mógł zajść routing, router musi być podłączony przynajmniej do dwóch podsieci (które można okreslić w ramach jednej sieci komputerowej). 
Ruter może być używany albo do połączenia przynajmniej dwóch sieci albo do stworzenia mobilnej sieci ad-hoc. Używany jest przede wszystkim do łaczenia ze sobą sieci WAN, MAN i LAN. 
Ruter, który łączy klienty z internetem jest nazywany ruterem krawędziowym (_edge router_). 
Ruter który służy do transmisji danych pomiędzy innymi ruterami to ruter rdzenny (_core router_). 

Router tworzy i utrzymuje tablicę routingu (_routing table_), która przechowuje najlepsze ścieżki do konkretnych obszarów sieci i metryki rutingu (_routing metrics_) związane z tymi ścieżkami. 

Pierwotne routery z lat sześćdziesiątych były komputerami ogólnego przeznaczenia. Chociaż w roli routerów można używać zwykłych komputerów, nowoczesne, szybkie routery to wysoce wyspecjalizowane urządzenia. Zazwyczaj mają wbudowane dodatkowe elementy sprzętowe w celu przyspieszenia typowych czynności, takich jak przekazywanie pakietów lub bardziej wyspecjalizowanych zadań jak np. szyfrowanie IPSec. 
Wprowadzono również inne zmiany w celu zwiększenia pewności działania, takie jak zasilanie awaryjne z baterii oraz pamięć trwała zamiast magnetycznej. Nowoczesne routery zaczynają przypominać centrale telefoniczne, a obie te technologie coraz bardziej się upodabniają i prawdopodobnie wkrótce się połączą. 
Obecnie wiele funkcji rutowania zostało dodanych do przełączników LAN, tworząc przełączniki warstwy 2/3 (_Layer 2/3 Switches_), które rutują ruch blisko prędkości kabla. 
Małe rutery są natomiast coraz bardziej popularnym sprzętem gospodarstwa domowego. 
Pierwszymi, nowoczesnymi (dedykowanymi, _standalone_) ruterami były rutery Fuzzball. 

Szczególnym przypadkiem routera jest urządzenie z jednym interfejsem sieciowym, które rutuje pomiędzy dwoma lub większą ilością sieci wydzielonych logicznie na tym pojedynczym interfejsie. Dla sieci Ethernet są to VLAN-y (wirtualne sieci lokalne), dla sieci ATM czy Frame Relay kanały PVC/SVC (Permanent Virtual Circuit/Switched Virtual Circuit, stałe bądź komutowane kanały wirtualne). 

Rutery są także implementowane jako bramki internetowe (_internet gateways_), głównie dla małych sieci jak te używane w domach i małych biurach; najczęściej tam gdzie połączenie internetowe szerokopasmowe jest stale aktywne jak np. modemy kablowe lub DSL. 

W przypadku ruterów dostępowych nie konfiguruje się klasycznej tablicy routingu. Dla tej grupy urządzeń tablica routingu powiazana jest ściśle z funkcją NAT tłumaczacą adresy IP z wewnętrznej puli adresowej na jeden numer widoczny na zewnątrz, w praktyce więc można jedynie definiować reguły dotyczące zarządzania pakietami, które trafiają do sieci lokalnej: np. filtrować je (firewall) zarezerwować adresy i porty sieciowe dla wydzielonych usług takich jak FTP lub WWW (tzw. Virtual Server Mapping lub forwarding portów), można też skonfigurować opcje pozwalające użytkownikom z zewnątrz zalogowanie się do sieci lokalnej. 

<!-- http://www.ouah.org/ http://linux4biz.net/writing.html http://www.freeos.com/ http://linux.cudeso.be/linuxdoc.php http://www.linux-sxs.org/ http://linux.maruhn.com/cat/Tool/Network.html http://www.iss.net/security_center/advice/default.htm http://www.nettwerked.net/ http://www.tscm.com/ http://www.ciphertrust.com/resources/statistics/zombie.php CipherTrust's ZombieMeterSM http://security-networks-today2.blogspot.com/ security-networks-today2 http://www.volubis.com/blog/ http://www.rootsecure.net/ http://www.network-monitoring-net.com/ http://altaglobalnet.blogspot.com/ http://raytownblog.blogspot.com/ http://myspywareblogging.blogspot.com/ http://www.cr0.net:8040/code/network/ http://www.lagado.com/proxy-test http://www.informatik.uni-freiburg.de/~alsbiha/code.htm http://www.wired.com/news/privacy/0,1848,67223,00.html?tw=rss.TEKU.S. Military's Elite Hacker Crew http://www.theregister.co.uk/2005/04/19/teenagers_want_computer_security_lessons/ Teenagers want computer security lessons http://news.zdnet.co.uk/0,39020330,39193999,00.htmRussian hackers 'the best in the world' http://www.internetnews.com/security/article.php/3493206 Alliance Formed to Finger Hackers -->

- [Scanrand Dissected: A New Breed of Network Scanner](http://www.lurhq.com/scanrand.html)
- [Zabezpiecz swoją sieć w stylu NSA](http://hacking.pl/5301)
- [Remove the limit on TCP connection attempts](http://www.speedguide.net/read_articles.php?id=1497)
- [Hacking Google for fun and profit](http://www.channelregister.co.uk/2005/04/04/google_hacking/)
- [Ten Things I Didn't Know About Google](http://blogs.pcworld.com/techlog/archives/000681.html)
- [Advanced Search with Google](http://binaryrealm.ath.cx/index.php?option=com_content&task=view&id=16&Itemid=9)
- [How To Find MP3's with Google](http://www.i-hacked.com/content/view/128/42)
- [How to Google hack Windows servers](http://searchwindowssecurity.techtarget.com/tip/0,289483,sid45_gci1089383,00.html)
- [Possible Domain Poisoning Underway](http://www.techweb.com/wire/security/60405913)
- [Hackers poison DNS](http://www.theinquirer.net/?article=21621)
- [Defeating Honeypots: System Issues, Part 1](http://www.securityfocus.com/infocus/1826)
- [DNS system in need of upgrade](http://www.vnunet.com/news/1162310)
- [Spam, Directory Harvest Attacks (DHA), email Denial of Service (DoS) attacks](http://www.technologynewsdaily.com/node/364)
- [Trio of security holes kick sysadmins in teeth](http://www.techworld.com/security/news/index.cfm?NewsID=3631)
- [Thwarting Hacker Techniques: Signs of a compromised system](http://searchsecurity.techtarget.com/tip/1,289483,sid14_gci1069097,00.html)
- [Software Firewalls versus Wormhole Tunnels](http://www.securityfocus.com/infocus/1831)
- [Intro to Telnet And Hacking](http://www.techenclave.com/forums/showthread.php?t=3252)
- [Anti-Forensic Tools](http://www.networkintrusion.co.uk/foranti.htm)
- [Cracking Unix password files for beginners](http://www.governmentsecurity.org/articles/CrackingUnixpasswordfilesforbeginners.php)
- [Hacking Beginning](http://www.port7alliance.com/txt/hackbg.html)
- [Best Hacking Tools and Tutorials](http://thetechdomain.com/?p=27)
- [IP Spoofing: Understanding the basics](http://www.linuxexposed.com/Articles/Hacking/IP-Spoofing-Understanding-the-basics.html)
- [Hacker Mags you might not know about](http://www.i-hacked.com/content/view/144/48)
- [Geekfathers: CyberCrime Mobs Revealed](http://www.baselinemag.com/article2/0,1397,1775903,00.asp)
- [Gotcha!: Hack Attacks](http://www.baselinemag.com/article2/0,1397,1774475,00.asp)
- [Denial-of-service glitch could threaten Windows](http://news.com.com/Denial-of-service+glitch+could+threaten+Windows/2100-1002_3-5604579.html?tag=nl)
- [The Guest Account Is The Hacker's Holy Grail](http://channels.lockergnome.com/windows/archives/20050114_the_guest_account_is_the_hackers_holy_grail.phtml)
- [Coke Machine Hacks](http://www.boingboing.net/2004/12/20/coke_machine_hacks.html)
- l0t3k: [distro forensic](http://www.l0t3k.org/linux/distro/forensic/)
- [Penguin Sleuth Kit Bootable CD](http://www.linux-forensics.com/downloads.html)
- [FrozenTech's LiveCD List](http://www.frozentech.com/content/livecd.php?sort=&showonly=forensics)
- [Top 100 Network Security Tools](http://sectools.org/)

### Dodatek

Materiały

#### Słownik pojęć

ARP (Address Resolution Protocol - protokół rozróżniania adresów)

Protokół określający jak wyznaczyć adres MAC odpowiadający adresowi IP. Działa w warstwie dostępu do sieci. Mimo, że jest potrzebny w sieciach TCP/IP obecnie nie należy do zestawu protokołów TCP/IP. 
Zapewnia odwzorowanie adresów hostów na postać fizycznych adresów sieciowych.

ATM (Asynchronous Transfer Mode)

Technika transmisji, w której dane dzieli się na małe pakiety o stałej wielkości (tzw. komórki, cells). Pozwala ona na jednoczesne przesyłanie danych komputerowych, głosu i wideo w tej samej sieci. Prędkość transmisji może być od 25 do 622 Mbps. W ATM (w odróżnieniu od protokołu TCP/IP, gdzie każdy pakiet może podróżować inną drogą) w trakcie ustanawiania połączenia negocjuje się stałą trasę (kanał) między dwoma punktami. Pozwala to m.in. na wybór drogi w zależności od potrzebnej przepustowości. ATM pozwala zdecydować, czy dane mogą być przesyłane zawsze ze stałą lub ze zmienną prędkością (Constant lub Variable Bit Rate). Możliwe jest także korzystanie z całej dostępnej w danym momencie przepustowości z zachowaniem minimalnego poziomu (Available Bit Rate) lub bez niego (Unspecified Bit Rate). 
Frame Relay (FR) protokół wykorzystywanym do łączenia urządzeń w sieciach WAN. W USA stosuje się prędkości T-1 (1,544 Mbps) i T-3 (45 Mbps), w Europie natomiast od 64 Kbps do 2 Mbps. FR jest powoli wypierany przez ATM.

Bastion Host

Jednostka sieciowa zapewniająca pojedynczy punkt wejścia/wyjścia do internetu używany w celu ochrony sieci wewnętrznej - jest barierą pomiędzy obszarem publicznym a prywatnym. 
Zwykle zawiera firewall i zapewnia usługi takie jak WWW, DNS i mail. 

bramka (ang. gateway)

Element łączący dwie sieci.

CHAP (Challenge Handshake Authentication Protocol)

Protokół używany w PPP

DNS (Domain Name Service/Server)

Usługa/serwer nazw tłumacząca nazwy domenowe na adresy IP i odwrotnie

DHCP (Dynamic Host Configuration Protocol)

Mechanizm ułatwiający konfgurację sieci komputerowej, automatycznie przydziela adresy IP wszystkim komputerom w sieci. 
Ważne jest aby określona przez użytkownika pula rozdzielanych przez serwer DHCP adresów I była z tego samego zakresu co adres IP należący do rutera. 

delegacja

Wpis w serwerze DNS zawierajacy informację o maszynie obsługującej daną subdomenę.

demon (ang. daemon)

Program obsługujący daną usługę i odpowiadający na zapytania klientów.

DMZ (DeMilitarized Zone)

Wyłączajaca ograniczenia sieci wewnętrznej strefa zdemilitaryzowana. 
Podsieć jest najczęściej używana dla łączenia serwerów, które mają być dostępne z zewnętrznego świata takie jak serwery mail, WWW i DNS. DMZ jest tworzona przez konfigurację firewalla. 
Nazwa pochodzi z militarnej nomenklatury i oznacza obszar pomiędzy dwoma nieprzyjacielami

domena (ang. domain)

Część hierarchii w którą są zgrupowane adresy internetowe.

domena odwrotna (ang. domain)

Domena zaczynająca się odwróconym adresem IP a kończąca się .in-addr.arpa; jest wykorzystywana w procesie zamiany adresów IP na nazwy

dyrektywa

Komenda konfiguracyjna Apache, definiująca dane niezbędne do poprawnej pracy oraz wskazująca sposób zachowania się podczas wystąpienia określonych zdarzeń.

Ethernet

Standard przemysłowy osprzętu szybkiej sieci lokalnej, wprowadzony w 1975 przez Xerox Company, a następnie rozwinięty w 1980 przez DEC i Intela.

gniazdo (ang. socket)

Informacje identyfikujące połączenie

FDDI (Fiber Distributed Data Interface - łącze danych w sieci światłowodowej)

Światłowód

firewall (zapora ogniowa)

Zbiór metod ochrony plików i programów znajdujących się w jednej sieci chroniący przed nieuprawnionym dostępem użytkowników z innej sieci. Głównym zadaniem firewalla jest blokowanie lub filtrowanie wskazanych portów (np. w celu ograniczenia warunków korzystania z właczonych na chronionej maszynie usług) lub dostępu do całych domen. 
Służy do ochrony lokalnych sieci komputerowych jego zadaniem jest m.in. fitrowanie pakietów, potwierdzanie tożsamości i kontrola uprawnień użytkowników, wyszukiwanie wirusów, kontrolowanie sprowadzanych plików, równoważenie obciążenia serwerów sieciowych, translacja adresów internetowych, ochrona przesyłanych informacji oraz monitorowanie działalności użytkowników i administratorów a także rejestrowanie ważnych zdarzeń

FTP

Protokół komunikacyjny zdalnego kopiowania plików.

FQDN (ang. Fully Qualified Domain Name)

Pełna nazwa domenowa, tworzy ją nazwa hosta oraz domeny.

host

Węzeł sieci, czyli komputer przyłączony do sieci

- Komputer włączony do Sieci połączeniem stałym, posiadający stały adres, udostępniający swoje usługi użytkownikom łączącym się ze swoich komputerów. Powszechną praktyką jest współistnienie na jednym hoście wielu usług, np. WWW, FTP i SSH. Komputer lokalny użytkownika nazywany jest wtedy zdalnym terminalem (ang. remote terminal).
- Każdy komputer podłączony do Internetu lub innej sieci używającej protokołu TCP/IP i posiadający unikalny adres IP. Jeżeli użytkownik łączy się z Internetem dzwoniąc do swojego dostawcy usług internetowych, jego komputer otrzymuje dynamiczny adres IP i na czas trwania połączenia staje się hostem. W tym znaczeniu "host" jest po prostu dowolną maszyną uczestniczącą w wymianie danych przez sieć.
- W publikacjach angielskojęzycznych jako czasownik _to host_ - dostarczać infrastrukturę dla usług komputerowych. Przykładowo wyrażenia _to host Web server_ lub _hosted by_ mogą odnosić się do firmy zapewniającej sprzęt, oprogramowanie oraz połączenie dla czyjejś witryny WWW.

httpd (ang. HyperText Transfer Protocol Daemon)

Demon usługi HTTP

koncentrator (_hub_)

Urządzenie zapewniające dołączenie dodatkowych stacji roboczych i umożliwiające zarządzanie i monitorowanie siecią

ICMP (Internet Control Message Protocol - protokół międzysieciowych komunikatów sterujących)

Obsługuje zawiadomienia o błędach oraz informacje sterujące, które przepływają między bramami a maszynami użytkownika, które są generowane najczęściej przez procesy systemowe. 
Niewielkie komunikaty umożliwiające zarządzanie siecią, wiele z nich pozwala rozeznać sytuację problemu i jego przyczyny. 
Najbardziej znanym zastosowaniem jest polecenie ping wysyłające pakiety ICMP typu 8 (Echo request), po których oczekuje się typu 0 (Echo replay)

interfejs sieciowy (ang. adapter)

Interfejs sieciowy

IP (Internet Protocol - bezpołączeniowy protokół komunikacyjny internetu)

Zarządza transmisją, rutowaniem, oraz fragmentacją i składaniem danych niskiego poziomu. Bezpołączeniowy protokół komunikacyjny, transmisja datagramów między systemami w sieci.

IPX (Internetwork Packet Exchange)

Miedzysieciowa wymiana pakietów, bezpołączeniowy protokół komunikacyjny działający w warstwie sieciowej OSI, w którym pakiet jest wysyłany do miejsca przeznaczenia bez nawiązania połączenia i kontroli transmisji. 
Używany w sieciach Nowell Netware razem z NetWare SPX (Sequenced Packet Exchange)

ISO (International Organization for Standardization)

Międzynarodowa organizacja normalizacyjna

ISDN (Integrated Services Digital Network)

Sieć cyfrowa z integracją usług.

klient

Komputer korzystający z usług serwera. 
System który używa zdalnego dostępu do usługi na innym komputerze przez sieć. Termin ten początkowo był zastosowany do urządzeń które nie były w stanie używać własnych programów ale mogły być zdalnym interfejsem dla innych komputerów. Takie terminale były klientami komputera mainframe (time-sharing mainframe computer). 
Model klient-serwer nadal jest używany w internecie, tam gdzie użytkownik może połączyć się do usługi działającej na zdalnym serwerze przez zestaw protokołów inernetowych. 
Przeglądarki internetowe są klientami, które mogą się połączyć z webserwerami i pobierać strony do wyświetlenia. Większość ludzi używa klientów e-mail do pobierania swoich emaili z serwerów swoich ISP. 
Coraz więcej aplikacji klienckich jest przełączanych na WWW (np. webmail), dzięki czemu przeglądarki staja się uniwersalnym klientem.

koncentrator (ang. hub)

Urządzenie sieciowe

LAN (Local Area Network)

Lokalna sieć komputerowa

MAC (Media Access Control - sterowanie dostępem do nośnika)

Numer sprzętowy interfejsu sieciowego

MAN (Metropolitan Area Network)

Sieć miejska

masquerade

NAT

model OSI

Model usług sieciowych

modem (**mo**dulator-**dem**odulator)

Urządzenie sieciowe

most (ang. bridge)

Urządzenie sieciowe

NAT (Network Address Translation)

Mechanizm pozwalający na zamianę jednych adresów IP na inne, dzięki któremu maszyny należące do jednej sieci lokalnej mogą połączyć się z internetem wykorzystując jeden widoczny z zewnątrz numer IP

NCSA (National Center for Supercomputing Applications)

Zajmuje się rozwijaniem nowych technologii informatycznych

NetBEUI (NetBIOS Extended User Interface)

Rozszerzony interfejs użytkownika - protokół komunikacji sieciowej działający w warstwie sieciowej i transportowej modelu OSI swiadczący usługi na rzecz protokołów pracujących w warstwie sesji (np. NetBIOS, TCP, SPX)

NetBIOS (Network Basic Input/Output System)

Podstawowy sieciowy system wejścia/wyjścia - moduł zawierający podstawowe procedury obsługi zasobów sieciowych, wprowadzony przez IBM i używany w sieciach PC Network, przesyłanie pakietów i zapewnienie interakcji klient-serwer

NFS (Network File System)

Sieciowy system plików

OSI (Open System Inteconnection)

Połączenie systemów otwartych - standard ISO komunikacji sieciowej i międzysieciowej, standard warstwowego systemu sieciowego ISO

PAT (Port Address Translation)

Właściwość NAT, która tłumaczy połączenia TCP lub UDP do hosta i portu w zewnętrznej sieci na host i port w wewnętrznej sieci, pozwala używać jednego adresu IP. Jeden zewnętrzny adres może liczyć ponad 64K wewnętrznych hostów. 
W typowej konfiguracji firewalla zewnętrzna sieć jest internetem a wewnętrzna LAN. 
W typowej konfiguracji DMZ zewnętrzna sieć jest internetem a wewnętrzna DMZ. 

PAP (Password Authentication Protocol)

Protokół używany w PPP.

PHP

Język skryptowy ogólnego przeznaczenia dostosowany do potrzeb WWW, ma wiele rozszerzeń, między innymi umożliwia łaczenie z bazami danych i obługę bibliotek graficznych

poddomena, subdomena (ang. subdomain)

Część domeny, każda oprócz najwyższej (.) jest poddomeną innej domeny.

port

Umożliwia skierowanie danych do odpowiedniego procesu (bo np. PID procesu jest za każdym razem inny). Proces oczekujący na określonym porcie informuje system iż oczekuje od niego przesłania do siebie danych. Żaden inny proces nie może korzystać z tego portu. 
Jest ich 65 536 (2 16), poniżej 1024 są zarezerwowane dla roota. 
Adres portu to 16-bitowa liczba określająca konkretną usługę lub aplikację na maszynie docelowej, która powinna odebrać dane. 
Umożliwia określenie i lokalizację usługi. Komputer pragnący zrealizować jakąś usługę na innej maszynie może albo od razu próbować skomunikować się z określonym portem albo poprosić o informację, której udziela portmap (port 111) pod jakimi numerami są dostępne poszczególne usługi (portmap może odmówić informacji, które nie są dostępne dla wszystkich)
Ponieważ komunikacja w rzeczywistości odbywa się pomiędzy procesami a nie między komputerami, port jest adresem procesu; ten sam port może być wykorzystywany jednocześnie przez procesy TCP (numer/tcp) i UDP (numer/udp) bo tak się różnią między sobą. 
Jeśli np. 25/TCP zostanie zarezerwowane dla jakiejś usługi - ponieważ uniksy traktują wszystkie obiekty jako pliki - w celu przypisania sobie portu proces prosi system ustanowienie tzw. gniazda, które jest po prostu jedną ze stron komunikacji; system zwraca deskryptor pliku gniazda, który może być użyty przez proces jak zwykły plik tyle, że ma więcej opcji konfiguracyjnych a potem wywołuje funkcję systemową zwiazaną z tym gniazdem. 
gdy system nasłuchuje na określonym porcie - port jest otwarty

netstat -apn

adres 0.0.0.0 oznacza przyjmowanie wszystkich połączeń

lsof -i tcp

_well known port numbers_:

PPP (Point-to-Point Protocol)

Protokół - umożliwia transmisję danych za pomoca dowolnych łączy Point-to-Point, używany do przesyłania danych przez łącze szeregowe.

protokół sieciowy

Zbiór reguł, które kierują ruchem w sieci, porządkujący komunikację. Każdy system musi się do nich dostosować, żeby być przyłączony do danej sieci. Dzięki temu można podłączyć do sieci komputery pracujące pod kontrolą różnych systemów operacyjnych. 

przełącznik (ang. switch)

Urządzenie

RARP (Reverse Address Resolution Protocol)

Umożliwia ustalenie adresu IP dla danego fizycznego adresu sieciowego

resolver (ang. resolver)

Częśc systemu DNS odpowiedzialna za bezpośredni kontakt z aplikacjami użytkowymi, zwykle ma formę usługi systemowej.

RIP (Routing Information Protocol)

Protokół dzięki któremu rutery wymieniają między sobą dane o aktualnej konfiguracji urządzeń sieciowych, w przypadku zmian w sieci zostanie rozesłana odpowiednia informacja.

ruter (ang. router)

Urządzenie sieciowe, które wytycza drogę pakietów między sieciami zapewniając możliwość połączenia ze sobą dowolnych komputerów niezależnie od ich fizycznej lokalizacji. 
Posiada przynajmniej dwa przyłącza sieciowe każde o innym adresie IP jego zadaniem jest skierowanie danych we właściwą stronę na podstawie adresu docelowego. Przekazywane są do niego pakiety o adresach spoza sieci lokalnej. Rutery potrafią same zmieniać trasę przesyłania pakietów i tworzyć tzw. drogi obejściowe w razie np. awarii.

serwer

Element sieci komputerowej udostępniający usługi innym komputerom (klientom), udostępnia swoje zasoby innym maszynom, przyjmuje od nich polecenia i je wykonuje (ang. serve - służyć komuś, pełnić oobowiązki). 
Nazwa serwer internetowy obejmuje dwa pojęcia:

- host - (zazwyczaj) komputer podłączony do sieci, realizujący określone usługi;
- specjalizowane oprogramowanie uruchomione na tym sprzęcie, np. serwer HTTP, SMTP, DNS, FTP itp.

Czasem chodzi o oba te znaczenia na raz. Należy podkreślić, że niekoniecznie musi być to komputer - serwerem DHCP może być np. router. 
Serwery są często realizowane w postaci demonów

serwer wirtualny (Virtual Server)

Ogólna nazwa stosowanych w bramach rezydentnych technologii umożliwiających dzięki remapowaniu portów uruchomienie w sieci lokalnej serwerów dostępnych dla użytkowników internetu mimo używania jednego (lub kilku) adresów IP i mechanizmu NAT

SLIP (Serial Line Interface Protocol)

Zapewnia transmisję danych za pomocą łączy szeregowych (modem)

SMTP (Simple Mail Transfer Protocol)

Prosty protokół przesyłania poczty elektronicznej

SNMP (Simple Network Management Protocol)

Prosty protokół zarządzania siecią, zajmuje się zarządzaniem i monitorowaniem urządzeń sieciowych i ich funkcji

strefa

Domena lub grupa poddomen zarządzana w jednym miejscu, strefy proste zawierają zwyczajne domeny, a strefy odwrotne domeny typu .in-addr.arpa

TCP (Transmission Control Protocol - protokół sterowania transmisją)

Odpowiada za stabilność sesji komunikacji sieciowej między aplikacjami, w tym za sterowanie przepływem oraz wykrycie i naprawienie błędów. Działa w warstwie transportowej. 
Jego zadaniem jest zapewnienie niezawodnej, zorientowanej połączeniowo, komunikacji pomiędzy dwoma procesami, które mogą działać na różnych maszynach w sieci.

TCP/IP (Transmission Control Protocol/Internet Protcol)

Zestaw protokołów definiujących jak maszyny powinny komunikować się między sobą przez sieć oraz wewnętrznie z innymi warstwami zestawu protokołów. Powstał na potrzeby ARPAnetu. 
TCP i UDP wysyłają i odbierają dane w jednostkach zwanych pakietami, każdy pakiet zawiera porcję informacji do wysłania oraz nagłówek określający adres portu docelowego i portu źródła. 
IP w hierachii protokołów leży niżej, jest odpowiedzialny za przesyłanie i kierowanie pakietów TCP i UDP w sieci. Pakuje każdy pakiet TCP lub UDP w inny pakiet zwany datagramem IP, który zawiera nagłówek z informacją o trasie i miejscu przeznaczenia (są tam adresy IP maszyny źródłowej i docelowej). 

TLD (Top Level Domain)

Domena najwyższego poziomu

TTL (Time To Live)

Czas ważności informacji, parametr ten określa jak długo dane będą przechowywane w pamięci podręcznej serwerów

UDP (User Datagram Protocol - protokół datagramów użytkownika)

Zapewnia komunikację bezpołączeniową między aplikacjami. W protokole UDP, w przeciwieństwie do TCP, nie ma weryfikacji, czy przekazywane dane zostały dostarczone. Jeśli oczekiwane dane nie nadejdą, to aplikacja zażąda ich jeszcze raz. Działa w warstwie transportowej. 
Procesy wykorzystujące UDP w razie potrzeby muszą same implementować mechanizmy potwierdzenia i synchronizacji. Nadawca nie ma możliwości ustalenia czy pakiet został pomyślnie dostarczony. 

URI

Adres

URL (Uniform Resource Locator)

Adres

usługa

Określony protokołami transmisji typ wymiany danych pomiędzy aplikacjami.

skaner

Program

snifer (ang. sniffer)

Program służący do analizy ruchu sieciowego, przez przechwytywanie, rejestrowanie i analizowanie pakietów przepływających w sieci. Narzędzie diagnostyczne używane przez administratorów sieci jak i również przez włamywaczy; może służyć również zwykłym użytkownikom do sprawdzenia czy i w jaki sposób działa szyfrowany kanał komunikacji. Nazwa po polsku oznacza węszyciel i prawdopodobnie pochodzi od komercyjnego programu Sniffer (produkcji Network Associates, Inc.). 
[Packet_sniffer (eng.)](http://en.wikipedia.org/wiki/Packet_sniffer) [Sniffer (pl.)](http://pl.wikipedia.org/wiki/Sniffer)
[.:[ packet storm ]:.](http://packetstormsecurity.com/), [insecure.org: Top 75 Security Tools](http://www.insecure.org/tools.html)
Przykładowe sniffery (uwaga: nieostrożne użycie może spowodować problemy prawne):

- dsniff: [www.monkey.org/~dugsong/dsniff/](http://www.monkey.org/~dugsong/dsniff/)
- EtherApe [etherape.sourceforge.net](http://etherape.sourceforge.net/)
- Ethereal [www.ethereal.com](http://www.ethereal.com/)
- ettercap [ettercap.sourceforge.net](http://ettercap.sourceforge.net/)
- Sniffit [reptile.rug.ac.be/~coder/sniffit/sniffit.html](http://reptile.rug.ac.be/~coder/sniffit/sniffit.html)
- Snort [www.snort.org](http://www.snort.org/)
- tcdump [www.tcpdump.org](http://www.tcpdump.org/)

WAN (Wide Area Network)

Sieć obejmująca swoim zasięgiem duży obszar, składajaca się z wielu podsieci połączonych ruterami.

WWW (World Wide Web)

Usługa sieciowa

wzmacniak (ang. repeater)

Urządzenie sieciowe

VPN (Virtual Private Network - Wirtualna Sieć Prywatna)

Mechanizm umożliwiający wykorzystanie sieci publicznej (internetu) do dwukierunkowej bezpiecznej komunikacji pomiędzy odległymi komputerami. Na czas połączenia tworzony jest wirtualny wydzielony tunel, przez który transmituje się zaszyfrowane informacje. Dzięki temu nawet po przechwyceniu pakietów danych przez osoby niepowołane przesyłane informacje są bezpieczne gdyż do odczytania ich potrzebny jest klucz znany tylko komputerom nawiązującym połączenie. 
Używane głównie do zapewnienia dostępu do firmowych intranetów dla podrózujących pracowników

#### Protokoły

**ARP (Address Resolution Protocol)**

Ramka zbudowana jest tak (w nawiasach kwadratowych ilość bajtów):

- [7] Preambuła (takt)
- [1] Znacznik początku
- [2 lub 6] Adres odbiorcy
- [2 lub 6] Adres nadawcy
- [2]
- [0 do 1500] Dane
- [0 do 46] PAD
- [4] kontrola parzystości

**DNS (Domain Name System)**

Każda strefa zawiera bazę danych zdefiniowaną w oddzielnym pliku, składa się ona w większości z pozycji RR Informacja o nazwach domen przechowywana jest w strukturach zwanych RR (Resource Records) składających się z sześciu pól:

1. nazwa - pole o zmiennej długości, identyfikuje nazwę hosta, koniec nazwy zaznaczany bajtem zerowym
2. typ - typ danego rekordu (może on być używany nie tylko do przekształcania nazw); możliwe wartości (wartość - typ - znaczenie):
  - 1 - A - nazwa hosta; najczęściej występujący rekord, który odwzorowuje nazwę hosta na jego numer IP
```
test IN A 192.168.0.2
```
  - 2 NS - nadrzędny serwer nazw; definiują oficjalne serwery nazw dla domeny, np:
```
@ IN NS localhost.
```
spowoduje, że serwerem nazw dla bieżącej domeny będzie komputer localhost
  - 3 - MD - adres przeznaczenia dla poczty
  - 4 - MF - forward poczty
  - 5 - CNAME - alias nazwy; umożliwia tworzenie aliasów do nazw kanonicznych (takich jak np. www.google.com), można np. stworzyć alias testowy dla komputera test.domena.com wpisując komendę
```
testowy IN CNAME test.domena.com.pl
```
jeśli nazwa maszyny jest częścią bieżącej domeny wystarczy podać tylko ją (nie całą domenę) gdy nazwą kanoniczną jest identyfikator komputera z innej domeny to należy podać pełną nazwę zakończoną kropką
nazwa kanoniczna, rodzaj aliasu używanego w strefach prostych
  - 6 - SOA (Start Of Authority) - początek definicji strefy; w żadnym pliku nie może być więcej niż jeden wpis SOA, przykładowy rekord:
```
@ IN SOA localhost. root.localhost.
(2000050601; Serial
604800; Refresh
86400; Retry
24192; Expire
604800); Default TTL
```
W powyższym przykładzie:
- localhost. - nazwa serwera dla danej strefy; musi być zakończony kropką
- root.localhost. - adres pocztowy osoby odpowiedzialnej za domenę, @ w adresie mailowym jest zamienione przez "." (prawdziwy adres to root@localhost); musi być zakończony kropką
- @ - odnosi się do aktualnego pochodzenia, które oznacza nazwę strefy w pliku named.conf
- IN - internet
- Serial - pole zawierające numer wersji pliku strefy, po wprowadzeniu zmian do pliku strefy należy koniecznie ten numer zwiększyć aby serwery pomocnicze były poinformowane o konieczności dokonania zmian w swoich plikach, zazwyczaj używa się numeru typu RRRRMMDDNN (rok, miesiąc, dzień, wersja z danego dnia)
- Refresh - określa jak często serwer pomocniczy ma sprawdzać serwer podstawowy, czy nie zachodzi potrzeba uaktualnienia
- Retry - definiuje po jakim czasie serwer pomocniczy ponowi nieudaną próbę odświeżenia danych
- Expire - maksymalny limit czasu, przez jaki serwer pomocniczy może utrzymywać dane w pamięci bez ich uaktualniania
- Default TTL - określa domyślny czas TTL dla tych rekordów, które nie mają wpisanych wartości TTL

  - 7 - MB - nazwa domeny skrzynki pocztowej
  - 8 - MG - grupa pocztowa
  - 9 - MR - nazwa domeny pocztowej
  - 10 - NULL - wartość NULL
  - 11 - WKS - opis "dobrze znanych usług"
  - 12 - PTR - wskaźnik nazwy domenowej, również alias, ale używany w strefach odwrotnych
  - 13 - HINFO - nformacja o hoście; pozwala na wpisanie informacji o danym komputerze (np. typ procesora i system operacyjny)
```
test.domena.com.pl IN HINFO "PC C333" "Linux Debian"
```
  - 14 - MINFO - informacje o skrzynce badź liście pocztowej
  - 15 - MX - wymiana poczty; pole to określa jaki serwer bdzie pełnił funkcję bramki pocztowej (będzie przyjmował pocztę adresowaną dla danej domeny); w rekordzie MX należy podać numer oznaczający priorytet serwera, ponieważ można wprowadzić kilka rekordów MX poczta kierowana będzie do serwera o najmniejszym numerze, a jeżeli ten nie będzie mógł przyjąc poczty zostanie skierowana do następnego w kolejności, po wpisaniu polecenia
```
domena.com.pl. IN MX 10 poczta.domena.com.pl.
```
  - 16 - TXT - łańcuchy tekstowe
Wartości MD i MF zostały zastąpione przez MX, wartości MB, MG, MR i NULL są eksperymentalne
3. klasa - klasa rekordu, możliwe wartości to IN, CS, CH I HS (w przypadku internetu używany jest tylko IN)
4. TTL - 32-bitowa liczba określająca wyrażony w sekundach czas jaki rekord może być przechowywany w buforze, zanim dane będą mogły zostać ponownie sprawdzone; wartość zero oznacza, że nie może być przechowywany w buforze i może być użyty tylko w tej transakcji w ten sposób określa się czas jaki dane mają być przechowywane w bazie danych serwera pomocniczego lub serwera buforującego
5. długość - 16-bitowa liczba określająca rozmiar danych w bajtach
6. dane - składa się z jednej informacji, MX i HINFO: dwie informacje, SOA: wiele informacji

Komunikacja między procesami w modelu DNS odbywa się poprzez przesyłanie tzw. wiadomości (ang. message) czasem nazywanych komunikatami, które składają się z pięciu pól.

1. Nagłówek
2. Zapytanie
3. Odpowiedź
4. Źródło nadrzędne
5. Informacje dodatkowe

Nagłówek zawsze musi być obecny, składa się z sześciu słów.

1. - ID - 16-bitowa wartość przypisywana przez program, który generuje zapytanie, identyfikator ten z kolei jest przypisywany komunikatowi z odpowiedzią tak by host wysyłający mógł powiązać ze sobą pytania i odpowiedzi na nie
2. - QR - jednobitowe pole wskazujące czy dana wiadomość jest pytaniem (0) czy odpowiedzią (1)
- opcode - kod operacji; czterobitowe pole wskazuje rodzaj zadawanego pytania, wartość ta jest ustalana przez wysyłającego zapytanie oraz kopiowana do odpowiedniego pola w odpowiedzi; dopuszczalne wartości:
  - 0 standardowe zapytanie (standard query)
  - 1 zapytanie odwrotne (inverse query)
  - 2 żądanie stanu serwera (serwer status request)
  - 3-15 zarezerwowane dla przyszłych zastosowań (reserved for future use))
- AA - bit wskazujący, że serwer jest serwerem nadrzędnym dla danej domeny
- TC - wskazuje, że część komunikatu została odrzucona ponieważ jego długość była większa niż dopuszczalna w danym kanale transmisyjnym
- RD - ustawienie tego bitu na jeden wskazuje, ze serwer powinien przetwarzać dane rekurencyjnie. Bit ten jest ustawionyw zapytaniu i kopiowany do odpowiedzi
- RA - wskazuje czy dany serwer obsługuje zapytania rekurencyjne, ustawiany w odpowiedziach
- Z - zarezerwowany dla przyszłych zastosowań, w pytaniach i odpowiedziach ma być 0
- RCODE - czterobitowe pole ustawiane w wiadomościach z odpowiedziami, wskazuje czy a jeśli tak to jaki rodzaj błędu nastąpił:
  - 0 - brak błędu
  - 1 - serwer nie jest w stanie zinterpretować zapytania
  - 2 - wewnętrzny błąd serwera
  - 3 - podana domena nie istnieje
  - 4 - serwer nie obsługuje zapytań podobnego typu
  - 5 - odrzucenie zapytania
  - 6-15 - zarezerwowane dla przyszłych zastosowań
3. - QDCOUNT - liczba zapytań w komunikacie
4. - ANCOUNT - liczba odpowiedzi w komunikacie
5. - NSCOUNT - liczba rekordów w sekcji serwerów nadrzędnych
6. - ARCOUNT - liczba rekordów w sekcji dodatkowej

Zwykle zapytania są wysyłane przy użyciu protokołu UDP z ustaloną wielkością datagramu na maksimum 512 bajtów. jeśli wielkośc ta zostanie przekroczona, wiadomość zostanie obcięta i ustawiony zostanie bit TC w nagłówku. Do wymiany informacji międzystrefowej używany jest natomiast TCP. W obu przypadkach używany jest port 53.

**ICMP (Internet Control Message Protocol)** HMPTODO

Wiadomości ICMP:

Nie można osiagnąć systemu docelowego (Destination Unreachable Message)

1. - [8] Typ wiadomości - równy 3
- [8] Kod
  - 0 - niedostępna sieć (net unreacheble)
  - 1 - niedostępny host (host unreachable)
  - 2 - niedostępny protokół (protocol unreachable)
  - 3 - niedostępny port (port unreachable)
  - 4 - konieczna fragmentacja (fragmentation need and DF set); gdy datagram trafi do sieci, która nie będzie w stanie przesłać go dalej w całości, tzn. konieczna jest fragmentacja a flaga DF w nagłowku jej zakazuje
  - 5 - błąd routingu (source route failed) pierwsze dwa kody wysyłane są gdy nie można się dostać do sieci docelowej (fizyczne połączenie zerwane, za duża odległość, niedostępny docelowy komputer); 2 i 3 jeśli datagram dotrze ale jego przeznaczeniem będzie nieistniejący port lub protokół;
  - [16] Suma kontrolna
2. - [32] Nie używane
3. - [32] Nagłówek i 64 bity oryginalnego datagramu

Przekroczony limit czasu (Time Exceeded Message)

Struktura wiadomości jest identyczna jak wyżej

1. - [8] Typ wiadomości - równy 11
  - [8] Kod
    - 0 - przekroczony limit czasu (time to live exceeded); pole TTL osiągnęło wartość 0 i datagram musi zostać zniszczony
    - 1 - przekroczono czas składania (fragment reassembly time exceeded); host nie jest w stanie złożyć w całość pofragmentowanego datagramu, najprawdopodobniej poszczególne części zostały zagubione w sieci
  - [16] Suma kontrolna
2. - [32] Nie używane
3. - [32] Nagłówek i 64 bity oryginalnego datagramu

Niewłaściwy parametr (Parameter Problem Message)

wiadomość wysyłana jest gdy w parametrach nagłówka pojawi się błąd, który spowoduje konieczność jego odrzucenia potencjalnym źródłem takiego problemu jest pole opcje

1. - [8] Typ wiadomości - równy 12
- [8] Kod
- 0 - pole wskaźnik wskazuje miejsce wystąpienia błędu
- 1 - błąd w polu typ usługi
- [16] Suma kontrolna
2. - [8] Wskażnik
- [24] Nie używane
3. - [32] Nagłówek i 64 bity oryginalnego datagramu

Stłumienie źródła (Source Quench Message)

wiadomość wysyłana jest gdy gateway nie ma wystarczającej wolnej przestrzeni w buforze do przetworzenia datagramu lub gdy system docelowy nie nadąża z odbieraniem przesyłek; jest to prośba o zwolnienie prędkości wysyłania danych lub ich chwilowe wstrzymanie; system wysyłający powiniena na to zareagować zwalniając aż pakiety Source Quench Message przestaną napływać, później może zwiększać tempo aż do ponownego otrzymania tej wiadomości zaleca się by gateway wysłał tą wiadomość kiedy zbliża się do granicy możliwości a nie po jej przekroczeniu - oznacza to, że datagram, który spowodował ten komunikat może zostać prawidłowo dostarczony

1. - [8] Typ wiadomości - równy 4
- [8] Kod
- 0
- [16] Suma kontrolna
2. - [32] Nie używane
3. - [32] Nagłówek i 64 bity oryginalnego datagramu

Przekierowanie datagramu (Redirect Message)

wysyłana gdy gateway znajdzie krótszą drogę (przez inny gateway)

1. - [8] Typ wiadomości - równy 5
- [8] Kod
- 0 - przekierowanie do sieci
- 1 - przekierowanie do hosta
- 2 - przekierowanie ze względu na typ usługi i sieć
- 3 - przekierowanie ze względu na typ usługi i host
- [16] Suma kontrolna
2. - [32] Adres gatewaya (do którego powinien zostać skierowany ruch do sieci podanej w polu przeznaczenia datagramu, który spowodował wysłanie wiadomości Redirect
3. - [32] Nagłówek i 64 bity oryginalnego datagramu

Echo i Odpowiedź echa (Echo or Echo Replay Message)

jeśli host otrzyma wiadomość typu Echo musi odesłać pakiet z wiadomością Odpowiedź echa

1. - [8] Typ wiadomości
- 8 dla wiadomości Echo
- 0 dla wiadomości Odpowiedź echa
- [8] Kod
- 0
- [16] Suma kontrolna
2. - [16] Identyfikator
- [16] Numer sekwencyjny
3. - [32] Dane

pola Identyfikator i Numer sekwencyjny zawierają zawierają wartości pomocne w porównywaniu Echa i Odpowiedzi echa, mogą one przyjmować wartość zero

Znacznik czasowy i echo znacznika czasowego (Timestamp or Timestamp Replay Message)

1. - [8] Typ wiadomości
- 13 dla znacznika czasowego
- 14 dla echa (odpowiedzi) znacznika czasowego
- [8] Kod
- 0
- [16] Suma kontrolna
2. - [16] Identyfikator
- [16] Numer sekwencyjny
3. - [32] Znacznik oryginalny - host wysyłający Timestamp wstawia w pole Znacznik oryginalny czas wysłania wiadomości
4. - [32] Znacznik odpowiedzi - host docelowy w pole Znacznik odpowiedzi wstawia czas kiedy odebrał wiadomość
5. - [32] Znacznik transmisji - host docelowy w pole Znacznik transmisji wstawia czas kiedy wysłał wiadomość i odsyła wiadomość o typie 14 (czyli echo znacznika czasowego)

pola Identyfikator i Numer sekwencyjny są używane do dopasowania do siebie wiadomości Timestamp i Timestamp Replay

Informacja i Żądanie informacji (Information Replay or Information Request)

1. - [8] Typ wiadomości
- 15 dla żądania informacji (Information Request)
- 16 dla informacji (Information Replay)
- [8] Kod
- 0
- [16] Suma kontrolna
2. - [16] Identyfikator
- [16] Numer sekwencyjny

pola Identyfikator i Numer sekwencyjny są używane do skojarzenia ze sobą żądania informacji i odpowiedzi, wiadomość ta może zostać użyta do stwierdzenia w jakiej sieci się host znajduje; w nagłówku IP w adresie źródłowym pola dotyczące sieci są wyzerowane, podobnie jak cały adres docelowy, odpowiedź musi natomiast mieć te pola prawidłowo wypełnione, w ten sposób host po otrzymaniu odpowiedzi będzie wiedział w jakiej jest sieci

**IP (Internet Protocol)** HMPTODO

- networksorcery.com: [IP, Internet Protocol](http://www.networksorcery.com/enp/protocol/ip.htm)
- cisco.com: [Internet Protocols](http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/ip.htm)

```
IPv4 header format
+ Bits 0 - 3 4 - 7 8 - 15 16 - 18 19 - 31
0 Version Header length Type of Service
(now DiffServ and ECN) Total Length
32 Identification Flags Fragment Offset
64 Time to Live Protocol Header Checksum
96 Source Address
128 Destination Address
160 Options
192
Data
```

Każdy pakiet (datagram IP) rozpoczyna się od nagłówka składającego się z sześciu 32-bitowych słów (w nawiasach kwadratowych długość pola nagłówka w bitach):

1. 
  - [4] numer wersji protokołu - obecnie 4
  - [4] IHL (Internet Header Length) - długość nagłówka wyrażona w ilości słów 32-bitowych (stała wielokrotność 4 bajtów, minimalna długość to 5x4=20 bajtów), pole to jest potrzebne ponieważ nagłówek może mieć różną długość (4 lub 5 słów) ponieważ nagłówek IPv4 może zawierać różną ilość opcji to pole zasadniczo określa offset to the data portion datagramu IPv4. Najmniejszy nagłowek IPv4 ma 20 bajtów długości więc minimalną wartością dziesiętnych jest 5 (5x4 = 20 bajtów). W ten sposób to reprezentuje całkowitą liczbę bajtów zajętych przez nagłowek jako wielokrotność 4 bajtów
  - [8] typ usługi - wpływa na sposób w jaki zostanie potraktowany pakiet, np. ważne pakiety można oznaczyć etykietą "wysoki priorytet"; W RFC 791, te 8 bitów jest alokowanych do pola Type of Service (ToS) field - obecnie DiffServ and ECN. Pierwotną intencją było, żeby wysyłajacy host mógł określić preferencje jak datagram ma być przetwarzany kiedy idzie przez podsieci, dla przykładu możnaby określić dla danego datagramu niskie opóźnienie dla innego wysoką wiarygodność, w praktyce nie zostało to szeroko zaimplementowane, jednakże wiele pożytku wynikło z eksperymentowania z tymi ośmioma bitami i te bity zostały zredefiniowane przez grupę roboczą DiffServ w IETF i Explicit Congestion Notification codepoints (see RFC 3168).
    - pierwsze 3 bity definiują priorytet (zazwyczaj ignorowane):
      - 0 - (routine) zwykłe dane
      - 1 - datagram priorytetowy
      - 2 - (immediate) natychmiastowy
      - 3 - błyskawiczny
      - 4 - błyskawiczny z pierwszeństwem (flash override)
      - 5 - CRITIC/ECP
      - 6 - kontrola międzysieciowa
      - 7 - informacje krytyczne (informacje kontroli sieci)
    - kolejne trzy bity to flagi oznaczające odpowiednio opóźnienie, przepustowość i niezawodność (zazwyczaj są ignorowane)
      - 0 - wartość normalna
      - 1 - małe opóźnienie, wysoka przepustowość, wysoka niezawodność
    - kolejne dwa bity zarezerwowane do przyszłych zastosowań, nieużywane
  - [16] wyrażony w bajtach rozmiar pakietu razem z nagłówkiem - ponieważ jest to 16-bitowe pole długość nie może przekraczać 65 536 bajtów (64 KB), minimalną wartością jest 20 bajtów, a minimalną wielkością z jaką musi sobie radzić host jest 576 bajtów. Definiuje rozmiar całego datagramu łącznie nagłówek i dane w bajtach, minimalna wielkość datagramu to 20 bajtów a maksymalna 65535
2. - [16] identyfikator - jednoznacznie rozróżnia wysyłane pakiety, są to kolejne liczby będące numerami pakietów, jeśli pkiet ulega fragmentacji każda część otrzymuje ten sam numer to pole jest unikalnym identyfikatorem datagramu IP, niektóre eksperymenty dotyczyły użycia tego pola do innych celów takich jak danie informacji śledzenia pakietu w celu wyśledzenia drogi datagramów ze sfałszowanymi adresami źródłowymi.
- [3] flagi używane do kontrolowania lub identyfikowania fragmentów
- [1] bit nieużywany, zarezerwowany, musi być zero
- [1] flaga DF (Dont Fragment) - jeśli jest ustawiona (1) pakiet nie może być dzielony na mniejsze, jeśli zostanie uznany za zbyt duży dla komputera docelowego zostanie skasowany
- [1] flaga MF (More Fragments) - jeśli jest ustawiona (1) oznacza to, że podczas transmisji pakiet został podzielony na mniejsze, a odebrana paczka jest tylko jego fragmentem; ustawiony na 0 oznacza ostatni (lub jedyny) fragment datagramu
- [13] początek fragmentu, przesunięcie pakietu - informuje o tym od którego bajtu pierwotnego pakietu zaczyna się dany fragment, dzięki temu możliwe jest odtworzenie pakietu z części, wszystkie fragmenty oprócz pierwszego będą miały niezerową wartość
pozwala odbierającemu określić miejsce konkretnego fragmentu w oryginalnym datagrami IP mierzone w 8 bajtowych blokach.
3. - [8] czas życia (TTL - Time To Live) - określa jak długo pakiet będzie przesyłany do kolejnych węzłów sieci, po przejściu przez każdy węzeł jego wartość zmniejsza się o 1 i kiedy osiągnie 0 jest kasowany, pierwotnie ta wielkość określała ilość sekund, obecnie określna ilość skoków (hops).
- [8] protokół transportowy - jaki sposób transmisji jest przewidziany dla danego pakietu (RFC 1700 wymienia 100 wartości, 0 i 255 są zarezerwowane, od 101 do 254 nie mają przypisań), najważniejsze protokoły to:
- 1 - ICMP
- 6 - TCP
- 17 - UDP
- [16] suma kontrolna nagłówka - można określić czy nagłówek został przesłany bezbłędnie
niektóre wartości w datagramie IPv4 zmieniają się z każdym hopem więc suma musi być zawsze przeliczana w czasie drogi.
4. - [32] adres nadawcy - adres IP komputera źródłowego
5. - [32] adres odbiorcy - adres IP komputera docelowego, jeśli znajduje się w sieci lokalnej jest od razu przesyłany, jeśli nie wysyłany jest do rutera
6. dodatkowe pola nagłówka (nazwane opcjami) nie są używane zbyt często, wartość IHL musi zawierać dość 32 bitowych słów by zmieścić wszystkie opcje (plus dopełnienie - padding - konieczne by zapewnić, że nagłówek będzie zajmował liczbę całkowitą 32-bitowych słów; lista opcji może być zakończona opcją EOL (End of Options List) ale jest to potrzebne tylko jeśli koniec opcji nie jest jednocześnie końcem nagłówka użycie LSSR i SSSR (Loose and Strict Source and Record Route) opcji jest odradzane ponieważ powodują problemy bezpieczeństwa, pakiety z nimi są zwykle blokowane przez rutery
- [32] opcje - informacje specjalne, używane np. do zarządzania siecią; pole to nie musi wystąpić, jeśli jest zawiera opcje formowane po 8 bitów
- pierwszy bit jest flagą kopiowania, oznacza, że dana opcja ma być skopiowana do każdej części części datagramu podczas ewentualnej fragmentacji (1 - tak; 0 - nie)
- kolejne dwa bity oznaczają klasę opcji
- 0 - informacje sterujące
- 1 - wartość zarezerwowana
- 2 - informacje testowe
- 3 - wartość zarezerwowana
- dalsze pięć bitów oznacza właściwy numer opcji
- 0 - (End of Option List) koniec listy opcji; zakończenie listy wszystkich opcji w nagłówku, używane jeśli pole opcje jest krótsze niż 32 bity
- 1 - (No Operation) brak operacji, może być użyty do oddzielenia dwóch podopcji
- 2 - (Security) opcje bezpieczeństwa; definiuje 16 poziomów bezpieczeństwa (8 zarezerwowanych do przyszłych zastosowań)
- 3 - (Loose Source Routing) możliwośc zmiany trasy datagramu
- 7 - (Record Route) zapisywanie trasy przesyłania datagramu
- 8 - (Stream Identifier) umożliwia przesyłanie 16-bitowego identyfikatora strumienia satnet
- 9 - (Strict Source Routing) zakaz zmiany trasy przesyłania datagramu
- wypełnienie - jeśli lista opcji nie zajmie całego przeznaczonego na nią miejsca, wolna przestrzeń zostanie wypełniona zerami do pełnych 32 bitów

**PPP (Point-to-Point Protocol)**

PPP (ang. Point to Point Protocol) jest protokołem używanym najczęściej przy połączeniach modemowych (dial-up), technologii HIS (SDI). PPP może być również skonfigurowany na interfejsie szeregowym asynchronicznym i synchronicznym. Służy również do prostego zestawiania tuneli. Z PPP jest stosowany w technologii WAN. Z protokołem tym wiąże się autoryzacja PAP lub CHAP. Preferowany jest CHAP, ponieważ w przeciwieństwie do PAP używa MD5. 
powszechnie używany do połączenia pomiędzy dwoma węzłami, pierwotnie używany głównie do połączeń przy użyciu lini telefonicznych ale także czasem używany przy połączeniach szerokopasmowych. Wielu ISP używa PPP kiedy zapewnia połączenia dial-up (w internecie zastąpił starszy protokół - SLIP). 
Jest powszechnie używany do działania jako protokół warstwy 2 (warstwa łącza danych modelu OSI) dla połączenia przez synchroniczną i asynchroniczną sieć. PPP został zaprojektowany do pracy z kilkoma protokołami warstwy sieciowej takimi jak IP, IPX i AppleTalk i jest zastępstwem niestandardowego protokołu warstwy drugiej SLIP. 
Został zaprojektowany dużo później niż oryginalna specyfikacja HDCL, w rezultacie twórcy PPP dodali dużo nowych właściwości, których wcześniej nie było w protokołach łącza danych WAN. 
PPP tworzy dwie podwarstwy w warstwie łącza danych w modelu OSI: Link Control Protocol i Network Control Protocol. Do pierwszej podwarstwy można zaliczyć np. autoryzację, a druga odpowiada za komunikację z warstwą sieciową. 
PPP jest opisany w RFC 1661. 
Cechy PPP

- przydział adresów IP
- kontrola konfiguracji łącza danych modelu OSI
- multipleksowanie protokołów sieciowych
- wykrywanie błędów
- testowanie jakości łącza

Rozszerzona detekcja błędów
PPP wykorzystuje pola FCS aby wykryć błędy powstałe w ramkach podczas transmisji. PPP monitoruje ilość błędów i może zostać skonfigurowany tak, że kiedy kiedy liczba nieprawidłowych przekazów zbyt wzrośnie, wtedy łącze ulega zerwaniu. 
Dodatkowe opcje PPP
Protokół kontroli połączenia (ang. link control protocol- LCP) jest integralną częścią PPP zdefiniowaną w RFC i zawiera wykrywanie zapętlonych połączeń. Opiera się to na wykorzystywaniu liczby magicznej (ang. magic number). Każdy z uczestników komunikacji wysyła komunikaty LCP zawierające liczby różniące się liczby. Jeżeli pojawi się połączenie zapętlone, to odbiornik dostanie wysłaną przez siebie wartość. W ten sposób może to wykryć. Częścią specyfikacji PPP jest również protokół IPCP, który pozwala na automatyczne określenie adresów IP lokalnego komputera oraz zdalnej maszyny. Dodatkowo często wykorzystuje się DHCP do przekazywania takich informacji jak adres IP serwera DNS. 
Other PPP features
Zapewnia haki (hooks) dla automatycznej konfiguracji interfejsu sieci na każdym końcu (wysyłając adres IP, domyślną bramkę itp) i dla uwierzytelnienia (porównaj z DHCP). 
Wykrycie zwrotnego łącza (Looped link detection)
LCP (Link Control Protocol, integralna część PPP i zdefiniowana w tym samym RFC) zauważa zwrotne łącza (looped links) używając właściwości magicznych numerów (magic numbers). Kiedy używamy PPP koniec (endpoint) wysyła wiadomości PPP LCP, zawierające magiczny numer, który jest odmnienny dla każdego końca i kiedy linia jest zapętlona dostaje wiadomość LCP ze swoim własnym numerem zamiast dostania wiadomości z czymś innym magicznym numerem. 
RFC
Protokół PPP został opisany przez IETF w specyfikacji RFC 1661. O tamtego czasu liczne RFC opisywały różne aspekty np. uwierzytelnianie, szyfrowanie i metody kompresji, użycie PPP z innymi protokołami
RFC 1994 opisuje protokół CHAP (ang. Challenge Handshake Authentication Protocol) wykorzystywany w połączeniach dial-up przez dostawców Internetu. 
RFC 2516 definiuje PPPoE, czyli wersję PPP, gdzie połączenie między modemem DSL lub ADSL i komputerem jest realizowane poprzez Ethernet. 
RFC 2364 opisuje PPPoA, metodę transmisji PPP przez ATM Adaptation Layer 5 (AAL5) znaną też jako PPPoATM (PPP over ATM). 
Implementacje PPP
W Linuksie i inny Uniksach obsługa protokołu PPP jest możliwa dzięki demonowi pppd. 
PPP frame

- Flaga [1] oznacza początek lub koniec ramki
- Adres [1] adres rozgłoszeniowy
- Kontrola [1] bajt kontrolny
- Protokół [2] określa protokół w polu danych
- Dane [zmienna (od 0)] zawiera datagram
- FCS [2 (rzadziej 4)] suma kontrolna, kontrola błędów

**TCP (Transfer Control Protocol)**

W celu ustanowienia sesji mus najpier nastąpić TCP handshake, który składa się z reguł przestrzeganych po obu stronach do ustanawiania i kończenia połączenia używa mechanizmu zwanego znacznikami (ang. flags), które są umieszczone w nagłówku. Wymieniając pakiety serwery muszą potwierdzić każdy znacznik co umożliwia rozpoznanie kiedy proces połączenia jest zakończony i utrudnia przejęcie sesji przez atakującego
w nagłówkach są tzw. bity znaczników (flag bits)

Nawiązanie połączenia (trzyetapowe uzgadnianie połączenia - three-way handshake, triple handshake

1. klient wysyła znacznik SYN i numer portu, którego cce używać podczas sesji, pakiet zawiera również ISN (Initial Sequence Number - numer początkowy sesji) klienta
2. odpowiada własnym SYN (oznacza, że jest gotowy do połączenia) oraz ISN do portu klienta, odpowiada również ACK dla potwierdzenia znacznika SYN wysłanego przez klienta
3. odpowiada używając znacznika w celu potwierdzenia w celu potwierdzenia SYN otrzymanego od serwera

```
SYN ----->
klient<----- SYN ACKserwer
ACK ----->
```

Protokoły warstwy aplikacji mogą teraz wysyłać dane używając tego połączenia TCP

Kończenie połączenia (może zostać zainicjowane przez klienta lub przez serwer)

1. kończący wysyła znacznik FIN, zazwyczaj wysyłany jest do klienta w odpowiedzi na wydanie polecenia close w aplikacji serwera, tzw. active close czyli czynne kończenie połączenia. 
ustawiony jest tam również ACK potwierdzający odebranie poprzedniego pakietu
2. odpowiada przy użyciu znacznika FIN w celu potwierdzenia, że połączenie będzie zakończone
3. kończący wysyła znacznik FIN, jest to często nazywane biernym zakończeniem połączenia (passive close)
4. odpowiada znacznikiem ACK w celu potwierdzenia, że połączenie TCP jest zakończone

```
FIN ------>
<-----ACK
FIN ------>
<-----ACK
```

Jeśli system A kończy połączenie a system B nadal ma dane do wysłania jest to połączenie półzamknięte i trwa do momentu, gdy B wyśle FIN ACK a A odpowie ACK

Nagłówek TCP (w nawiasach kwadratowych długość pola nagłówka w bitach):

1. - [16] port nadawcy
- [16] port odbiorcy
2. - [32] numer sekwencyjny, kolejny - spełnia taką samą rolę jak "identyfikator" w nagłówku IP: jest rodzajem licznika określającym bieżący stan transmisji danych
3. - [32] numer potwierdzenia - przesyłany do odbiorcy dla potwierdzenia otrzymania informacji, dzięki temu nadawanie i potwierdzanie odbioru są zsynchronizowane; jeśli ustawiony jest bit ACK pole to zawiera klejny numer sekwencyjny oczekiwany przez host odbierający dane
4. - [4] przesunięcie danych - zawiera liczbę słów 32-bitowych składających się na nagłówek TCP określa jego długość; wielkość nagłowka może być różna ze względu na możliwą zmienną liczbę opcji
- [6] zarezerwowane dla przyszłych zastosowań - wszystkie muszą być ustawione na zero
- [1] flaga URG - 1 oznacza ważność pola "wskaźnik pilności" pilny
- [1] flaga ACK - 1 oznacza ważność pola "numer potwierdzenia" potwierdzenie otrzymania poprzedniego pakietu "usłyszałem cię"
- [1] flaga PSH - 1 oznacza wykonanie funkcji push wysyłanie danych
- [1] flaga RST - 1 oznacza wykonanie resetu połączenia zerwanie połączenia
- [1] flaga SYN - 1 oznacza wykonanie synchronizacji numerów sekwencyjnych numery synchronizacji sekwencji, używane w celu ustanowienia połączenia zainicjowanie sesji, "chciałbym porozmawiać"
- [1] flaga FIN - 1 oznacza koniec transmisji (koniec danych) nadawca zakończył połączenie, używane w celu zakończenia połączenia
- [16] szerokość okna - pozwala odbiorcy poinformować nadawcę ile bajtów jest w stanie odebrać w danej chwili; ilość oktetów możliwych do zakceptowania przez host wysyłający bieżący fragment
5. - [16] suma kontrolna - informuje czy transmisja przebiegła bezbłędnie, pozwala wykryć ewentualne przekłamania danych (obliczana dla całego pakietu łącznie z nagłówkiem i tzw. pseudonagłówkiem)
- [16] wskaźnik priorytetu - np. wskaźnik "wysoki priorytet" pozwala wyróżnić wiadomości, które sa szczególnie ważne, np. informacje o zakłóceniach w pracy sieci, ma znaczenie tylko jeśli jest ustawiona flaga URG, specyfikuje ona położenie ważnych danych w przesyłanym segmencie; wartość ta nie ma żadnego znaczenia dla samego protokołu TCP, może jednak być interpretowana przez aplikację wyższego poziomu
6. - [32] opcje - lista opcji nie jest ustalona i może się zmieniać, niezależnie od ilości są one w całości uwzględniane przy liczeniu sumy kontrolnej; istnieją dwa możliwe formaty opcji:

- pojedynczy oktet specyfikujący rodzaj opcji
- oktet specyfikujący rodzaj opcji, podający długość opcji, oktety danych opcji

aktualnie zdefiniowane rodzaje opcji są następujące:
- 0 - (End of Option List) koniec listy opcji; (postać: 000000) oznacza, że lista opcji się skończyła, można go użyć tylko wówczas jeśli lista opcji się skończyła a nie po każdej z nich oraz jeśli koniec opcji nie oznacza jednocześnie końca nagłowka TCP
- 1 - (No Operation) brak operacji, nic nie rób; (postać: 00000001) może być używany między innymi opcjami dla ich logicznego rozdzielenia, jednak takie rozdzielenie nie jest obligatoryjne i host odbierający musi być przygotowany do obsługi listy opcji nie zawierającej znaczników rozdzielających
- 2 - (Maximum segment size) maksymalny rozmiar segmentu (postać: 00000010 00000100) pierwszy bajt to rodzaj opcji drugi określa jej długość w oktetach (tu jest to cztery), dalej następują dwa bity danych, opcja ta na 16 bitach danych określa maksymalny rozmiar segmentu danych przyjmowany przez dany host; informacja ta wysyłana jest jedynie podczas inicjowania połączenia logicznego; jeśli nie jest używana oznacza to, że dozwolone są dowolne rozmiary segmentów
- znak wypełnienia - opcje muszą zajmować wielokrotność 32-bitowych słów, jeśli zajmują mniej pozostałe miejsce zajmuje tzw. wypełnienie, czyli wolne bity wypełnia się zerami

Tzw. pseudonagłówek składajacy się z trzech 32-bitowych słów (w nawiasach kwadratowych długość pola nagłówka w bitach):

1. - [32] adres źródłowy
2. - [32] adres docelowy
3. - [] zero
- [] protokół
- [] długość nagłówka

Poszczególne implementacje mogą różnić się w szczegółach jeśli chodzi o implementację interfejsu, niemniej każda z nich musi obsługiwać pewien standardowy zestaw usług tak by zagwarantować odpowiednią hierarchię protokołów. Oprócz przyjmowania komend musi również zwrócić pewne informacje o swoich usługach, można podzielić je na dwie grupy:

- ogólne informacje o połączeniu (np. o przerwaniu czy zamknięciu)
- odpowiedzi na otrzymane komendy informujące o tym czy zakończyły się sukcesem czy porażką (kod błędu)

Poszczególne polecenia TCP. 

OPEN

OPEN (port lokalny, gniazdo docelowe, flaga active/passive [, timeout] [, precedense] [, security/compartment] [, options])
identyfikacja procesów i sprawdzanie praw do używania konkretnych połączeń, w zależności od implementacji identyfikatory będą dostarczane albo przez TCP albo przez protokół warstwy niższej (np. IP)
flaga ustawiona na passive oznacza, że system ma oczekiwać na połączenia przychodzące, jeśli zdefiniuje się gniazda system będzie oczekiwał tylko na określonych gniazdach, jeśli nie zostanie zdefiniowane będzie przyjmował wszystkie połączenia
flaga ustawiona na active - TCP od razu zacznie procedurę synchronizacji i nawiązania połączenia
timeout (opcjonalnie) zdefiniowanie czasu w jaki wiadomość musi zostać dostarczona, w przeciwnym wypadku połaczenie zostanie przerwane; domyślnie 5 minut
sprawdzanie uprawnień użytkownika do otwarcia połączenia z daną "ważnością" (precedence) oraz jego poziom bezpieczeństwa, jeśli w wywołaniu nie zostaną podane parametry zostaną użyte wartości domyślne; protokół przymie połaczenie tylko wtedy jeśli security/compartment po obu stronach są takie same oraz kiedy ważność jest taka sama lub większa niż w wywołaniu open
po uzyskaniu poprawnego połączenia użytkownikowi zostanie zwrócona jego nazwa, która może być używana do jego definiowania zamiast pary (gniazdo lokalne/gniazdo zewnętrzne). 

SEND

SEND (lokalna nazwa połączenia, adres bufora, ilość danych, flaga PUSH, flaga URGENT [, timeout])
wysłanie danych z bufora, którego adres podany jest w parametrach do wyspecyfikowanego połączenia
jeśli połączenie nie zostało wcześniej otwarte zwykle zgłoszony jest błąd, jednak niektóre implementacje mogą automatycznie wywołać open, jeśli proces wywołujący send nie jest uprawniony do korzystania z danego połączenia zgłoszony jest błąd
ustawienie flagi PUSH - dane mają być transmitowane do systemu odbierającego natychmiast oraz, że flaga ta będzie dodana do ostatniego segmentu TCP tworzonego w buforze; jeśli ta flaga nie jest ustawiona dane mogą być składane z danymi z równoległych procesów wywołujących funkcję SEND w celu zwiększenia efektywności transmisji
ustawienie flagi URGENT - segmenty wysyłane do portu przeznaczenia będą miały dodatkowy wskaźnik URGENT, który zostanie przekazany przez TCP do procesu, który żądał danych, jeśli ich wcześniejsza porcja nie została jeszcze przetworzona, wymusza to przetwarzanie pilnych danych przez proces odbierający, jeśli dane są przetwarzane na bieżąco TCP nie przekazuje wskaźnika do procesu
timeout - jego podanie zmieni wartość domyślną; w najprostszej implementacji funkcja SEND nie zwróci sterowania dopóki transmisja nie zakończy się sukcesem lub nie nastąpi przekroczenie czasu podane parametrem timeout, ale jeśli z obu stron połączenia następują próby wysyłania a żaden proces nie odbiera danych może nastąpić zablokowanie więc bardziej zaawansowane systemy zwracają sterowanie do procesu od razu po wywołaniu, dzięki temu proces może kontrolować jednocześnie wysyłanie kilku segmentów danych

RECEIVE

RECEIVE (lokalna nazwa połączenia, adres bufora, wielkość bufora)
Przydziela bufor pamięci dla podanego połączenia; jeśli nie otwarto wcześniej połaczenia poleceniem OPEN lub proces nie ma uprawnień do korzystania z połączenia identyfikowanego przez parametr nazwa wygenerowany zostanie błąd
zakończenie występuje tak samo jak w SEND
bufor przyjmuje tyle danych ile wynosi jego wielkość a potem przekazuje je do procesu, jeśli otrzymany zostanie sygnał PUSH nastąpi bezzwłoczne przekazanie danych do procesu wraz z informacją o przyczynie

CLOSE

CLOSE (lokalna nazwa połączenia)
zamknięcie połączenia; jeśli nie zostało wcześniej otwarte lub proces nie ma uprawnień do zamknięcia podanego w parametrze połączenia zostanie wygenerowany błąd
najpierw zostaną wysłane ostatnie dane, jeśli jakieś są w buforze, proces musi też nadal odbierać dane, których nie zakończył wysyłać nadawca, fizyczne zamknięcie kanału nastąpi dopiero po uzgodnieniu przez oba procesy, że nie ma już żadnych danych do wysłania
gdy proces inicjujący zamknięcie z jakichś powodów nie może przyjąć ostatnich danych CLOSE generuje sygnał ABOR

STATUS

STATUS (lokalna nazwa połączenia)
podaje bieżące informacje o stanie połączenia opierając się na danych zawartych w bloku kontroli transmisji

- gniazdo lokalne (local socket)
- gniazdo zewnętrzne (foreign socket)
- lokalna nazwa połączenia (local connection name)
- okno odbioru (receive window)
- okno wysyłania (send window)
- stan połączenia (connection state)
- ilość buforów oczekujących na potwierdzenia (number of buffers awaiting acknoledgement)
- liczba buforów w trakcie odbioru (number of buffers pending receipt)
- stan wskaźnika pilności (urgent state)
- pierwszeństwo (precedence)
- opcje bezpieczeństwa (security options)
- timeout (transmission timeout)

w zależności od stanu połączenia lub implementacji część wskaźników może nie być dostępna lub nie mieć znaczenia
informacje o połączeniu mogą uzyskać tylko procesy mające odpowiednie uprawnienia

ABOR

ABOR (lokalna nazwa połączenia)
natychmiastowe przerwanie wykonywania będących w użyciu funkcji SEND i RECEIVE, usunięcie bloku kontroli transmisji oraz wysłanie sygnału RESET do procesu po drugiej stronie połączenia
w zależności od implementacji użytkownik otrzyma potwierdzenie wykonania ABOR dla każdego będącego w toku wykonywania polecenia SEND i RECEIVE lub jedno wspólne dla całego połączenia

**UDP (User Datagram Protocol)**

Nagłówek składa się z dwóch 32-bitowych słów, po których następuje ciąg danych (w nawiasach kwadratowych ilość bitów):

1. - [16] port źródłowy (source port) - port z którego korzysta proces wysyłający, wypełnienie tego pola jest opcjonalne, może być tam wartość zero; należy podać jeśli wymagamy odpowiedzi od hosta odbierającego
- [16] port przeznaczenia (destination port) - port pod który jest wysyłany datagram
2. - [16] długość - wielkość datagramu (łącznie z nagłówkiem) w bajtach; minimalna wielkość to 8
- [16] suma kontrolna nagłówka - liczona tak samo jak w przypadku TCP; jeśli pole to zawiera zero system odbierający będzie to traktował jakby host wysyłający nie wyliczył sumy (nawet jeśli rzeczywiście wynosi zero) gdyż protokół wyższego poziomu tego nie wymagał

Przed nagłówkiem właściwym znajduje się tzw. pseudonagłowek, składający się z trzech 32-bitowych słów (w nawiasach kwadratowych ilość bitów):

1. - [32] adres źródłowy
2. - [32] adres przeznaczenia
3. - [] zera
- [] protokół
- [] długość UDP

### Materiały

#### Artykuły

- Magazyn Internet: Jarosław Rafa "Internet od podstaw" cz 1-2 3-4/97; Marcin Kuchniak"Geneza i rozwój internetu" cz 1-2 7/8-9/97; Jacek Prucia "Sieciowe adresy" 8/98; Tomasz Tatar "Sekrety routingu" 11/98; Marcin Lis "Protokoły TCP/IP" cz 1-9 7-8/97-6/98
- CHIP: Marcin Pawlak "Tajemnicze rozmowy przeglądarki", Cztery liczby, które zawładnęły światem" 2/99; Marcin Pawlak "Nowy Internet?" 7/99; Piotr Daniszewski "W stogu siana" 8/00; Artur Nowicki "Tajniki TCP/IP" 11/00; Marcin Nowak, Marcin Pawlak "WWW dla wszystkich" 9/99; Grzegorz Dąbrowski "NATura sieci" 1/03; Marcin Nowak "Jaki to komputer" 4/04;
- Komputer Świat: KW "Apacz w pececie" 2/2003
- .net: Marek Dudkowski "Jak robią to karty sieciowe" 7/00;

#### Książki

- [Aeleen Frisch "UNIX - Administracja systemu. Wydanie trzecie"](#)
- [Matt Welsh, Matthias Kalle Dalheimer & Lar Kaufman "Linux"](#)
- ["Linux Network Administrator's Guide"](#)
- [Craig Hunt "TCP/IP Network Administration"](#)
- [Cricket Liu, Paul Albitz "DNS i BIND"](#)
- [Douglas Comer "Internetworking with TCP/IP"](#)
- [W. Richard Stevens "TCP/IP Ilustrated"](#)

#### Odnośniki

- Wikipedia: [IPv4 (eng.)](http://en.wikipedia.org/wiki/IPv4), [IPv4 (pl.)](http://pl.wikipedia.org/wiki/IPv4), [IPv6 (eng.)](http://en.wikipedia.org/wiki/IPv6), [IPv6 (pl.)](http://pl.wikipedia.org/wiki/IPv6), [Internet_Protocol (eng.)](http://en.wikipedia.org/wiki/Internet_Protocol), [IP (pl.)](http://pl.wikipedia.org/wiki/IP), [IP_address (eng.)](http://en.wikipedia.org/wiki/IP_address), [Internet_Control_Message_Protocol (eng.](http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol), [IANA (eng.)](http://en.wikipedia.org/wiki/IANA), [IANA (pl.)](http://pl.wikipedia.org/wiki/IANA), [InterNIC (eng.)](http://en.wikipedia.org/wiki/InterNIC), [IETF (eng.)](http://en.wikipedia.org/wiki/IETF), [IETF (pl.)](http://pl.wikipedia.org/wiki/IETF), [Simple_Network_Management_Protocol (eng.)](http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol), [SNMP (.pl)](http://pl.wikipedia.org/wiki/SNMP), [DNS (pl.)](http://pl.wikipedia.org/wiki/DNS), [Domain_Name_System (eng.)](http://en.wikipedia.org/wiki/Domain_Name_System), [Internet_protocol_suite (eng.)](http://en.wikipedia.org/wiki/Internet_protocol_suite), [TCP-IP (pl.)](http://pl.wikipedia.org/wiki/TCP-IP), [Transmission_Control_Protocol (ang.)](http://en.wikipedia.org/wiki/Transmission_Control_Protocol), [TCP (pl.)](http://pl.wikipedia.org/wiki/TCP), [User_Datagram_Protocol](http://en.wikipedia.org/wiki/User_Datagram_Protocol), [Address_Resolution_Protocol (eng.)](http://en.wikipedia.org/wiki/Address_Resolution_Protocol), [Internet_Society (pl.)](http://pl.wikipedia.org/wiki/Internet_Society), [Internet_Society (eng.)](http://en.wikipedia.org/wiki/Internet_Society), [Classless Inter-Domain Routing (eng.)](http://en.wikipedia.org/wiki/CIDR), [DHCP (pl.)](http://pl.wikipedia.org/wiki/DHCP), [Dynamic_Host_Configuration_Protocol (emg.)](http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol), [NAT (eng.)](http://en.wikipedia.org/wiki/NAT), [NAT (pl.)](http://pl.wikipedia.org/wiki/NAT), [Classes_of_IP_addresses (eng.)](http://en.wikipedia.org/wiki/Classes_of_IP_addresses), [Subnetwork (eng.)](http://en.wikipedia.org/wiki/Subnetwork), [Url (eng.)](http://en.wikipedia.org/wiki/Url), [Uniform_Resource_Identifier (eng.)](http://en.wikipedia.org/wiki/Uniform_Resource_Identifier), [FQDN (eng.)](http://en.wikipedia.org/wiki/FQDN), [Firewall_(networking) (eng.)](http://en.wikipedia.org/wiki/Firewall_(networking)), [URL_(informatyka) (pl.)](http://pl.wikipedia.org/wiki/URL_(informatyka)), [URI (pl.)](http://pl.wikipedia.org/wiki/URI), [Zapora_sieciowa (pl.)](http://pl.wikipedia.org/wiki/Zapora_sieciowa), [Network_address_translation (eng.)](http://en.wikipedia.org/wiki/Network_address_translation), [Port_address_translation (eng.)](http://en.wikipedia.org/wiki/Port_address_translation), [Routing (eng.)](http://en.wikipedia.org/wiki/Routing), [Stateful_firewall (eng.)](http://en.wikipedia.org/wiki/Stateful_firewall), [Stateless_firewall (eng.)](http://en.wikipedia.org/wiki/Stateless_firewall), [Netfilter (eng.)](http://en.wikipedia.org/wiki/Netfilter), [Bastion_Host (eng.)](http://en.wikipedia.org/wiki/Bastion_Host), [Demilitarized_Zone (eng.)](http://en.wikipedia.org/wiki/Demilitarized_Zone), [Routing (.pl)](http://pl.wikipedia.org/wiki/Routing), [Network_layer_firewall (eng.)](http://en.wikipedia.org/wiki/Network_layer_firewall), [Proxy_server (eng.)](http://en.wikipedia.org/wiki/Proxy_server), [URN (pl.)](http://pl.wikipedia.org/wiki/URN), [URN (eng.)](http://en.wikipedia.org/wiki/URN), [Application_layer_firewall (eng.)](http://en.wikipedia.org/wiki/Application_layer_firewall), [Router (eng.)](http://en.wikipedia.org/wiki/Router), [Koncentrator (pl.)](http://pl.wikipedia.org/wiki/Koncentrator), [Router (pl.)](http://pl.wikipedia.org/wiki/Router), [Hub (eng.)](http://en.wikipedia.org/wiki/Hub), [Hub (pl.)](http://pl.wikipedia.org/wiki/Hub), [Switch (pl.)](http://pl.wikipedia.org/wiki/Switch), [Switches (eng.)](http://en.wikipedia.org/wiki/Switches), [Modem (pl.)](http://pl.wikipedia.org/wiki/Modem), [Modem (eng.)](http://en.wikipedia.org/wiki/Modem), [Point-to-Point_Protocol (eng.)](http://en.wikipedia.org/wiki/Point-to-Point_Protocol), [PPP (pl.)](http://pl.wikipedia.org/wiki/PPP), [Server (eng.)](http://en.wikipedia.org/wiki/Server), [Client-server (eng.)](http://en.wikipedia.org/wiki/Client-server), [Client_(computing) (eng.)](http://en.wikipedia.org/wiki/Client_(computing)), [Serwer (pl.)](http://pl.wikipedia.org/wiki/Serwer), [Serwer_internetowy (pl.)](http://pl.wikipedia.org/wiki/Serwer_internetowy), [Host (pl.)](http://pl.wikipedia.org/wiki/Host), [Host (eng.)](http://en.wikipedia.org/wiki/Host), [Sieć_rozległa](http://pl.wikipedia.org/wiki/Sieć_rozległa), [Wide_area_network](http://en.wikipedia.org/wiki/Wide_area_network), [Sieć_lokalna](http://pl.wikipedia.org/wiki/Sieć_lokalna), [Local_area_network](http://en.wikipedia.org/wiki/Local_area_network), [Ethernet (eng.)](http://en.wikipedia.org/wiki/Ethernet), [Ethernet (pl.)](http://pl.wikipedia.org/wiki/Ethernet), [Wi-Fi (eng.)](http://en.wikipedia.org/wiki/Wi-Fi), [WiFi (pl.)](http://pl.wikipedia.org/wiki/WiFi), [Token_ring (eng.)](http://en.wikipedia.org/wiki/Token_ring), [Token_Ring (pl.)](http://pl.wikipedia.org/wiki/Token_Ring), [Fiber_distributed_data_interface (eng.)](http://en.wikipedia.org/wiki/Fiber_distributed_data_interface), [FDDI (pl.)](http://pl.wikipedia.org/wiki/FDDI), [Internet_Society (pl.)](http://pl.wikipedia.org/wiki/Internet_Society), [Internet_Society (eng.)](http://en.wikipedia.org/wiki/Internet_Society), [InterNIC (eng.)](http://en.wikipedia.org/wiki/InterNIC), [IANA (eng.)](http://en.wikipedia.org/wiki/IANA), [Internet_protocol_suite](http://en.wikipedia.org/wiki/Internet_protocol_suite), [IP_address](http://en.wikipedia.org/wiki/IP_address), [IPv4](http://en.wikipedia.org/wiki/IPv4), [IETF (eng.)](http://en.wikipedia.org/wiki/IETF), [Classful_network (eng.)](http://en.wikipedia.org/wiki/Classful_network)
- CHIP.pl: [Nowy Internet? [1999-07-01]](http://www.chip.pl/archiwum/article_36754.html), [Tak działa TCP/IP [1997-10-01]](http://www.chip.pl/archiwum/article_30916.html), [W stogu siana [2000-08-10]](http://www.chip.pl/archiwum/article_11769.html)
- [Index for /home/suod/tor/working/saclass/Slides/tcpip](http://bio3d.colorado.edu/~tor/sadocs/tcpip/index.html)
- CHIP.pl: [Okna otwarte dla Pingwina [2005-05-10]](http://www.chip.pl/arts/n/article_131712.html) [Na straży sieci [2005-06-22]](http://www.chip.pl/arts/n/article_134990.html), [Bo pula się wyczerpuje [2005-07-28]](http://www.chip.pl/arts/n/article_138314.html)
- [Governing the Internet](http://www.astalavista.com//data/governing_the_internet.htm)
- [Internetworking Models](http://www.astalavista.com//data/models.shtml)
- [System nazw domen (DNS) i konfiguracja serwera DNS (program BIND)](http://www.math.uni.lodz.pl/~polrola/strony/piiss/dns.html)
- [HOWTO.PL: Lista stron](http://www.howto.pl/modules.php?name=Content)
- Webdeweloper.pl - Bezpieczne sieci: [(1)](http://webdeveloper.pl/bezpieczne_sieci__1,123,1,1,pl.html), [(2)](http://webdeveloper.pl/bezpieczne_sieci__2,124,1,1,pl.html)
- [Optymalizacja połączeń internetowych - wybrane parametry](http://www.agavk.p9.pl/strony/inter_mtu.php)
- [Budujemy Firewall](http://www.clico.pl/software/checkpoint/html/budujemy_firewall.html) - (1997)
- haking.pl: [Sniffowanie w sieciach przełączanych](http://www.haking.pl/pl/tutorials/switch/switch.html)

- [The Independent: Dekada internetu](http://wiadomosci.o2.pl/?s=514&t=4218)
- Bleeping Computer: [Basic Internet Concepts](http://www.bleepingcomputer.com/forums/index.php?act=Tutorials&CODE=01&CID=16), [Intermediate Internet Concepts](http://www.bleepingcomputer.com/forums/index.php?act=Tutorials&CODE=01&CID=39), [Advanced Internet Concepts](http://www.bleepingcomputer.com/forums/index.php?act=Tutorials&CODE=01&CID=17)

##### DNS

- [The DNS GLOSSARY](http://www.menandmice.com/online_docs_and_faq/glossary/glossarytoc.htm)
- hacking.pl: [Zmiany w domenie .com [2006-03-02]](http://hacking.pl/5789), [Rozwiązania dynamicznej aktualizacji IP [2006-03-19]](http://hacking.pl/5851)

##### TCP/IP

- [Unix System Administration: PART II Network Services](http://wks.uts.ohio-state.edu/sysadm_course/html/sysadm-294.html) - [18.6.2 Internet (IP) address](http://wks.uts.ohio-state.edu/sysadm_course/html/sysadm-341.html)
- About.com: [Wireless / Networking](http://compnetworking.about.com/)
- [Network Sorcery, Inc. - RFC Sourcebook](http://www.networksorcery.com/enp/default.htm)
- [The TCP/IP Guide](http://www.tcpipguide.com/free/index.htm) - [IP Protocol suite](http://www.networksorcery.com/enp/topic/ipsuite.htm)
- Cisco Systems, Inc.: [Internetworking Technology Handbook](http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/index.htm)
- [Internet Protocol (RFC 791)](http://www.ietf.org/rfc/rfc0791.txt)
- searchWebServices.com Definitions: [IP address](http://searchwebservices.techtarget.com/sDefinition/0,,sid26_gci212381,00.html)
- Sangoma Technologies Corp.: [TCP/IP and IPX routing Tutorial](http://www.sangoma.com/fguide.htm)
- [Connected: An Internet Encyclopedia](http://www.freesoft.org/CIE/index.htm)
- networld.pl: [Protokoły routingu (wersja do wydruku)](http://www.networld.pl/nws/artykuly_txt/20910.html)
- [8.3.2 Transmission Control Protocol - TCP](http://rainbow.mimuw.edu.pl/SO/Linux/Temat08/TCP.html)
- [HOWTO's from Hell: Managing Core Network Services](http://www.microsoft.com/technet/prodtechnol/windowsserver2003/library/ServerHelp/30722e6f-ac62-44b4-839a-30e985b10d76.mspx)
- O'Reilly Linux DevCenter Blog: [IPv6 For Real](http://www.oreillynet.com/linux/blog/2006/09/ipv6_for_real_1.html)
- freeCodeCamp.org [Victoria Drake "What is the TCP/IP Model? Layers and Protocols Explained"](https://www.freecodecamp.org/news/what-is-tcp-ip-layers-and-protocols-explained/)

##### Organizacje

- [A Concise Guide to the Major Internet Bodies](http://www.acm.org/ubiquity/views/v6i5_simoneli.html)

<!-- http://www.nask.org.pl http://www.apnic.net http://www.iahc.org http://www.ripe.net http://www.iana.org http://www.ietf.org http://www.iab.org http://info.iso.org http://rs.internic.net http://www.terena.org.info http://far.mit.edu/diig/Surveys/fnc.html http://www.w3.org/pub/WWW/Consortium/Prospectus/FAQ.html http://www.digi.de http://www.w3.org/pub/WWW/Press/Backgrounder.html http://www.networkcomputing.com/ [NetworkWorld.com](http://www.networkworld.com/) ISC: [Dynamic Host Configuration Protocol (DHCP)](http://www.isc.org/index.pl?/sw/dhcp/) [RASPPPOE](http://www.raspppoe.com/) [FreeBSD.hello.pl](http://www.freebsd.hello.pl/) -->